------------------------------------------------------------------------
r9 | jdg0393 | 2020-10-25 23:50:07 -0500 (Sun, 25 Oct 2020) | 1 line

Collision between player and map. F4 shows tilemap collision boxes.

Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 8)
+++ Source/Scene.h	(revision 9)
@@ -39,6 +39,8 @@
 	std::vector<TileLayer> layers;
 	// List of collision boxes for scene (tile aabbs, usually)
 	std::vector<BoundingBox> clsnBoxes;
+	// Boolean determining if we draw tilemap aabbs
+	bool drawMapClsn = false;
 
 	// Function to add a single layer of a map
 	void loadTileLayer(std::string filename, eSpriteType tileSpriteKey);
Index: Source/SimpleMapScene.cpp
===================================================================
--- Source/SimpleMapScene.cpp	(revision 8)
+++ Source/SimpleMapScene.cpp	(revision 9)
@@ -24,8 +24,13 @@
 }
 
 void SimpleMapScene::update() {
+	// Handling controls specific to the scene
 	handleKeyboard();
+	// Core scene update, including updating objects
 	Scene::update();
+	// Check for the player colliding with the tilemap
+	checkPlyClsn();
+	// Update the camera position if we're following the player
 	if (followTarget)
 		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
 }
@@ -54,6 +59,10 @@
 	// Toggle camera mode
 	if (m_pKeyboard->TriggerDown('Z'))
 		shouldFollow ? camMapVision() : camFollowVision(player);
+
+	// Toggle drawing of tilemap collision boxes
+	if (m_pKeyboard->TriggerDown(VK_F4))
+		drawMapClsn = drawMapClsn ? false : true;
 }
 
 void SimpleMapScene::_handleMoveKeys() {
@@ -91,4 +100,14 @@
 	// No movement
 	else
 		player->setVelocity(0, player->getAngle());
+}
+
+void SimpleMapScene::checkPlyClsn() {
+	// Determine if the player is colliding with the map
+	bool hit = false;
+	for (auto i = clsnBoxes.begin(); i != clsnBoxes.end() && !hit; i++)
+		hit = player->m_sAabb.Intersects(*i);
+	// If the player is colliding, move them back
+	if (hit)
+		player->unmove();
 }
\ No newline at end of file
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 8)
+++ Source/Renderer.cpp	(revision 9)
@@ -25,6 +25,7 @@
 
 	// Loading of images goes here
 	Load(BACKGROUND, "background");
+	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(HUMAN_IDLE, "human_idle");
 
@@ -31,4 +32,18 @@
 	EndResourceUpload();
 } //LoadImages
 
+/// Draw an axially aligned bounding box using the green line sprite.
+/// \param aabb An axially aligned bounding box.
+void CRenderer::DrawBoundingBox(const BoundingBox& aabb) {
+	const Vector3 center = aabb.Center;
+	const Vector3 extent = aabb.Extents;
 
+	CSpriteDesc3D clsnSprite;
+	clsnSprite.m_nSpriteIndex = GREENLINE_SPRITE;
+	clsnSprite.m_fAlpha = 0.5;
+	clsnSprite.m_vPos = { center.x, center.y, -5 };
+	clsnSprite.m_fXScale = extent.x;
+	clsnSprite.m_fYScale = extent.y;
+
+	Draw(clsnSprite);
+} //DrawBoundingBox
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 8)
+++ Source/Game.cpp	(revision 9)
@@ -68,7 +68,6 @@
 		m_pRenderer->DrawScreenText(s.c_str(), pos, Colors::LightGreen);
 	}
 
-
 	m_pRenderer->EndFrame();
 
 } //RenderFrame
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 8)
+++ Source/PlayerCharacter.cpp	(revision 9)
@@ -3,7 +3,9 @@
 
 PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z) :
 	GameObject(scene, HUMAN_IDLE, x, y, z)
-{}
+{
+	m_sAabb = BoundingBox({ x,y,z }, { 4,4,4 });
+}
 
 void PlayerCharacter::update() {
 	//printf("PlayerCharacter::update()");
@@ -11,13 +13,28 @@
 }
 
 void PlayerCharacter::move() {
+	// Store the current position
+	oldPos = { m_vPos.x, m_vPos.y };
 	// Get the time passed since last frame
 	const float t = m_pStepTimer->GetElapsedSeconds();
 	// Move based on velocity (in px/s) * time (in s)
 	m_vPos.x += velocity.x * t;
 	m_vPos.y += velocity.y * t;
+	// Update the bounding box location
+	m_sAabb.Center.x = m_vPos.x;
+	m_sAabb.Center.y = m_vPos.y;
 }
 
+void PlayerCharacter::unmove() {
+	// Store the current position
+	Vector2 nowPos = { m_vPos.x, m_vPos.y };
+	// Move back to the old position
+	m_vPos.x = oldPos.x;
+	m_vPos.y = oldPos.y;
+	// Set the new "old" position (which is actually where we started this frame)
+	oldPos = nowPos;
+}
+
 void PlayerCharacter::setVelocity(float speed, float angle_in_degrees) {
 	// The desired speed
 	this->speed = speed;
Index: Source/SimpleMapScene.h
===================================================================
--- Source/SimpleMapScene.h	(revision 8)
+++ Source/SimpleMapScene.h	(revision 9)
@@ -21,5 +21,6 @@
 	bool shouldFollow = false; // Whether the camera is following
 	void handleKeyboard(); // Handler for the keyboard
 	void _handleMoveKeys(); // Internal function used by keyboard handler
+	void checkPlyClsn();
 };
 
Index: Source/Renderer.h
===================================================================
--- Source/Renderer.h	(revision 8)
+++ Source/Renderer.h	(revision 9)
@@ -11,9 +11,10 @@
 /// CRenderer handles the game-specific rendering tasks, relying on
 /// the base class to do all of the actual API-specific rendering.
 
-class CRenderer: public CSpriteRenderer{
-  public:
-    CRenderer(); ///< Constructor.
+class CRenderer : public CSpriteRenderer {
+public:
+	CRenderer(); ///< Constructor.
 
-    void LoadImages(); ///< Load images.
+	void DrawBoundingBox(const BoundingBox& aabb);
+	void LoadImages(); ///< Load images.
 }; //CRenderer
\ No newline at end of file
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 8)
+++ Source/GameDefines.h	(revision 9)
@@ -13,5 +13,6 @@
 	BACKGROUND,
 	SIMPLE_TILE,
 	HUMAN_IDLE,
+	GREENLINE_SPRITE,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 8)
+++ Source/PlayerCharacter.h	(revision 9)
@@ -10,9 +10,11 @@
 	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
 	void update() override; // Character's update loop, runs every frame
 	void move(); // Move the character once based on their velocity
+	void unmove(); // Undo the character's last movement
 	float getAngle() { return angle; } // Get the current angle in degrees
 	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
 private:
+	Vector2 oldPos; // Stores the position from the previous frame
 	float angle = 0; // Angle of the character in degrees
 	float speed = 0; // Speed of the character regardless of direction
 	Vector2 velocity = { 0,0 }; // Velocity of the character, accounts for direction
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 8)
+++ Source/Scene.cpp	(revision 9)
@@ -1,4 +1,5 @@
 #include "Scene.h"
+#include "Random.h"
 
 // Constructor for the Scene object
 // This is not necessarily where we need to create objects, but instead where
@@ -68,8 +69,17 @@
 	});
 
 	// Draw all the objects now that they've been depth sorted
-	for (auto spr : renders)
+	for (auto spr : renders) {
 		m_pRenderer->Draw(*spr);
+	}
+
+	// If we are set to draw tilemap collision boxes, do that now
+	if (drawMapClsn) {
+		for (const BoundingBox& box : clsnBoxes) {
+			m_pRenderer->DrawBoundingBox(box);
+		}
+	}
+
 }
 
 // Adds an object to the list of objects, and returns the object in case we
@@ -97,6 +107,32 @@
 	loadTileLayer(map_name + "_bg.txt", tileSpriteKey);
 	loadTileLayer(map_name + "_fg.txt", tileSpriteKey);
 	loadTileLayer(map_name + "_oh.txt", tileSpriteKey);
+
+	// Points to help with positioning tiles
+	float top = tileSize * tilemapHeight;
+
+	// Create the collisions for the map
+	int numClsnBoxes = 0;
+	std::ifstream inClsn(map_name + "_collision.txt");
+	inClsn >> numClsnBoxes; // Get the number of collision boxes to read
+	for (int i = 0; i < numClsnBoxes; i++) {
+		float x, y, w, h;
+		// Read in a collision box in order of coordinates then size
+		inClsn >> x >> y >> w >> h;
+		// Collision box object
+		BoundingBox clsnBox;
+		// Determine coordinates for aabb
+		float x0 = x;
+		float x1 = x0 + w;
+		// Y coordinates from the map are top->bottom, larc axis is bottom->top
+		// So we have to convert this.
+		float y0 = top - y;
+		float y1 = y0 - h;
+		// Create the box from coordinates
+		BoundingBox::CreateFromPoints(clsnBox, { x0, y0 }, { x1, y1 });
+		// Add the collision box to the list
+		clsnBoxes.push_back(clsnBox);
+	}
 }
 
 void Scene::loadTileLayer(std::string filename, eSpriteType tileSpriteKey) {

------------------------------------------------------------------------
r11 | amm0837 | 2020-10-26 18:51:53 -0500 (Mon, 26 Oct 2020) | 1 line

Added Tower class. Began working on having towers fire bullets at other objects. Was having a memory access violation when creating bullets, the fire() call is commented out for the time being.

Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 10)
+++ Source/Source.vcxproj.filters	(revision 11)
@@ -17,6 +17,9 @@
     <ClCompile Include="PlayerCharacter.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="Tower.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -36,6 +39,9 @@
     <ClInclude Include="PlayerCharacter.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="Tower.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Main.cpp
===================================================================
--- Source/Main.cpp	(revision 10)
+++ Source/Main.cpp	(revision 11)
@@ -6,7 +6,7 @@
 
 #ifdef _DEBUG
 #define USE_DEBUG_CONSOLE ///< Define to use a console window for debug messages.
-#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
+//#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
 #endif
 
 static CWindow g_cWindow; ///< The window class.
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 10)
+++ Source/Scene.cpp	(revision 11)
@@ -168,3 +168,11 @@
 		}
 	}
 }
+
+GameObject* Scene::getTarget() {
+	for (auto it = begin(objectList); it != end(objectList); ++it) {
+		if ((*it)->getSpriteType() == 2) {
+			return *it;
+		}
+	}
+}
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(nonexistent)
+++ Source/Tower.cpp	(revision 11)
@@ -0,0 +1,32 @@
+#include "Tower.h"
+
+
+Tower::Tower(Scene* scene, float x = 0, float y = 0, float z = 0) :
+	GameObject(scene, TOWER1, x, y, z)
+{	
+	objScene = scene;
+}
+void Tower::update() {
+	//printf("update function for tower \n");
+	move();
+}
+void Tower::move() {
+	
+	//fire(objScene->getTarget(), BULLET1);
+	//printf("fired a bullet\n");
+}
+void Tower::fire(GameObject* p, eSpriteType t) {
+	Vector3 direction;
+	const Vector3 view = p->getViewVect();
+	Vector3 pos = p->getPos();
+
+	GameObject * b = objScene->addObject(new GameObject(objScene, t, pos.x,pos.y,pos.z));
+	//printf("created bullet object\n");
+	const Vector3 norm(view.y, -view.x, 0.85);
+	const Vector3 bullet_speed(500.0f, 0.0f, 0.0f);
+	b->setVel(bullet_speed);
+
+}
+void Tower::setRoll(float angle) {
+
+}
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 10)
+++ Source/GameObject.cpp	(revision 11)
@@ -1,5 +1,6 @@
 #include "GameObject.h"
 
+
 GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x, float y, float z) {
 	this->scene = scene;
 	this->m_vPos = Vector3(x, y, z);
@@ -8,4 +9,29 @@
 
 void GameObject::update() {
 	//printf("GameObject::update()\n");
+\
+}
+
+void GameObject::setRoll(float angle) {
+	m_fRoll = angle;
+}
+
+float GameObject::getRoll() {
+	return m_fRoll;
+}
+Vector3 GameObject::getViewVect() {
+	return Vector3(-sinf(m_fRoll), cosf(m_fRoll), 0.85);
+}
+
+const Vector3& GameObject::getPos() {
+	return m_vPos;
+}
+void GameObject::setVel(const Vector3& v) {
+	m_vVelocity = v;
+}
+const Vector3& GameObject::getVel() {
+	return m_vVelocity;
+}
+int GameObject::getSpriteType() {
+	return m_nSpriteIndex;
 }
\ No newline at end of file
Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 10)
+++ Source/Scene.h	(revision 11)
@@ -26,6 +26,7 @@
 	virtual void render();
 	GameObject* addObject(GameObject* obj); // Adds an object to the list
 	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
+	GameObject* getTarget();
 protected:
 	CGame* game; // Reference to game which created this scene
 	std::vector<GameObject*> objectList; // Game objects managed by this scene
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(nonexistent)
+++ Source/Tower.h	(revision 11)
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GameObject.h"
+#include "SimpleMapScene.h"
+
+class Tower : public GameObject {
+public:
+	Tower(Scene* scene, float x, float y, float z);
+	void update();
+	void move();
+	void fire(GameObject* p, eSpriteType t);
+
+	void setRoll(float angle);
+
+private:
+
+	Scene* objScene;
+};
\ No newline at end of file
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 10)
+++ Source/GameObject.h	(revision 11)
@@ -2,18 +2,31 @@
 #include "Component.h"
 #include "GameDefines.h"
 #include "SpriteDesc.h"
+#include "Common.h"
+//#include "SimpleMapScene.h"
 
 // Forward declarations of classes that will exist
 // (We can't just include it b/c of circular dependency
 class Scene;
 
-class GameObject : public CComponent, public CSpriteDesc3D
+class GameObject : public CComponent, public CSpriteDesc3D, public CCommon
 {
 public:
 	// Constructor with default position
-	GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x = 0, float y = 0, float z = 0);
+	GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
 	virtual void update(); // Method runs every tick/update
+
+	void setRoll(float angle);
+	float getRoll();
+	void setVel(const Vector3& v);
+	int getSpriteType();
+	const Vector3& getVel();
+	const Vector3& getPos();
+
+	Vector3 getViewVect();
 private:
 	Scene* scene; // Scene which manages this object
+	Vector3 m_vVelocity = Vector3::Zero;
+	
 };
 
Index: Source/SimpleMapScene.cpp
===================================================================
--- Source/SimpleMapScene.cpp	(revision 10)
+++ Source/SimpleMapScene.cpp	(revision 11)
@@ -19,8 +19,10 @@
 	// Tilemap overhead layer is rendered at .8z, foreground at .9z
 	// So we place the human in between at .85z
 	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, 50, 50, .85));
+	addObject(new Tower(this, 100, 100, 0.85));  //adds a tower, want to make placement user specified
 	// Set the camera to follow the player
 	camFollowVision(player);
+	
 }
 
 void SimpleMapScene::update() {
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 10)
+++ Source/Renderer.cpp	(revision 11)
@@ -28,6 +28,8 @@
 	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(HUMAN_IDLE, "human_idle");
+	Load(BULLET1, "bullet1");
+	Load(TOWER1, "tower1");
 
 	EndResourceUpload();
 } //LoadImages
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 10)
+++ Source/Source.vcxproj	(revision 11)
@@ -172,6 +172,7 @@
     <ClCompile Include="Renderer.cpp" />
     <ClCompile Include="Scene.cpp" />
     <ClCompile Include="SimpleMapScene.cpp" />
+    <ClCompile Include="Tower.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -183,6 +184,7 @@
     <ClInclude Include="Scene.h" />
     <ClInclude Include="SimpleMapScene.h" />
     <ClInclude Include="Sndlist.h" />
+    <ClInclude Include="Tower.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/SimpleMapScene.h
===================================================================
--- Source/SimpleMapScene.h	(revision 10)
+++ Source/SimpleMapScene.h	(revision 11)
@@ -1,6 +1,7 @@
 #pragma once
 #include "Scene.h"
 #include "PlayerCharacter.h"
+#include "Tower.h"
 
 // Forward declarations for circular dependency
 class CGame;

------------------------------------------------------------------------
r12 | amm0837 | 2020-10-26 18:52:46 -0500 (Mon, 26 Oct 2020) | 1 line

Resolved conflicts

Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 11)
+++ Source/GameDefines.h	(revision 12)
@@ -13,6 +13,7 @@
 	BACKGROUND,
 	SIMPLE_TILE,
 	HUMAN_IDLE,
-	GREENLINE_SPRITE,
+	BULLET1,
+	TOWER1,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType

------------------------------------------------------------------------
r13 | jdg0393 | 2020-10-26 23:37:32 -0500 (Mon, 26 Oct 2020) | 1 line

Fixed GREENLINE_SPRITE for collision box rendering.

Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 12)
+++ Source/GameDefines.h	(revision 13)
@@ -11,6 +11,7 @@
 /// Note: NUM_SPRITES must be last.
 enum eSpriteType {
 	BACKGROUND,
+	GREENLINE_SPRITE,
 	SIMPLE_TILE,
 	HUMAN_IDLE,
 	BULLET1,

------------------------------------------------------------------------
r14 | amm0837 | 2020-10-28 18:42:16 -0500 (Wed, 28 Oct 2020) | 1 line

made more progress on firing a bullet at a specified object. Still getting an access violation when calling the fire() function.

Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 13)
+++ Source/Scene.cpp	(revision 14)
@@ -33,8 +33,10 @@
 void Scene::update() {
 	//printf("Scene::update()\n");
 	// Update every game object managed by this scene
+	//printf("objlist size %d", objectList.size());
 	for (GameObject*& obj : objectList) {
 		obj->update();
+		
 	}
 }
 
@@ -89,6 +91,7 @@
 // in the scene's list, all in one line.
 GameObject* Scene::addObject(GameObject* obj) {
 	objectList.push_back(obj);
+	//printf("added object %d", obj->getSpriteType());
 	return obj;
 }
 
@@ -169,10 +172,12 @@
 	}
 }
 
+//returns a pointer to an object for towers to target
 GameObject* Scene::getTarget() {
 	for (auto it = begin(objectList); it != end(objectList); ++it) {
-		if ((*it)->getSpriteType() == 2) {
+		if ((*it)->getSpriteType() == 3) {
 			return *it;
 		}
 	}
+	//return objectList[1];
 }
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 13)
+++ Source/GameObject.h	(revision 14)
@@ -3,6 +3,7 @@
 #include "GameDefines.h"
 #include "SpriteDesc.h"
 #include "Common.h"
+#include "StepTimer.h"
 //#include "SimpleMapScene.h"
 
 // Forward declarations of classes that will exist
@@ -18,15 +19,17 @@
 
 	void setRoll(float angle);
 	float getRoll();
-	void setVel(const Vector3& v);
+	void setVel(const Vector2& v);
 	int getSpriteType();
-	const Vector3& getVel();
+	const Vector2& getVel();
 	const Vector3& getPos();
 
-	Vector3 getViewVect();
+	Vector2 getViewVect();
+
+
 private:
 	Scene* scene; // Scene which manages this object
-	Vector3 m_vVelocity = Vector3::Zero;
+	Vector2 m_vVelocity = Vector2::Zero;
 	
 };
 
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 13)
+++ Source/Tower.h	(revision 14)
@@ -2,6 +2,7 @@
 
 #include "GameObject.h"
 #include "SimpleMapScene.h"
+#include "stepTimer.h"
 
 class Tower : public GameObject {
 public:
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 13)
+++ Source/GameObject.cpp	(revision 14)
@@ -9,9 +9,12 @@
 
 void GameObject::update() {
 	//printf("GameObject::update()\n");
-\
+	const float t = m_pStepTimer->GetElapsedSeconds();
+	m_vPos.x += m_vVelocity.x * t;
+	m_vPos.y += m_vVelocity.y * t;
 }
 
+
 void GameObject::setRoll(float angle) {
 	m_fRoll = angle;
 }
@@ -19,17 +22,17 @@
 float GameObject::getRoll() {
 	return m_fRoll;
 }
-Vector3 GameObject::getViewVect() {
-	return Vector3(-sinf(m_fRoll), cosf(m_fRoll), 0.85);
+Vector2 GameObject::getViewVect() {
+	return Vector2(-sinf(m_fRoll), cosf(m_fRoll));
 }
 
 const Vector3& GameObject::getPos() {
 	return m_vPos;
 }
-void GameObject::setVel(const Vector3& v) {
+void GameObject::setVel(const Vector2& v) {
 	m_vVelocity = v;
 }
-const Vector3& GameObject::getVel() {
+const Vector2& GameObject::getVel() {
 	return m_vVelocity;
 }
 int GameObject::getSpriteType() {
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 13)
+++ Source/Tower.cpp	(revision 14)
@@ -5,6 +5,7 @@
 	GameObject(scene, TOWER1, x, y, z)
 {	
 	objScene = scene;
+	setRoll(XM_2PI);
 }
 void Tower::update() {
 	//printf("update function for tower \n");
@@ -12,21 +13,32 @@
 }
 void Tower::move() {
 	
-	//fire(objScene->getTarget(), BULLET1);
+	//fire(this, BULLET1);
 	//printf("fired a bullet\n");
 }
 void Tower::fire(GameObject* p, eSpriteType t) {
-	Vector3 direction;
-	const Vector3 view = p->getViewVect();
+	const Vector2 view = p->getViewVect();
 	Vector3 pos = p->getPos();
-
+	
 	GameObject * b = objScene->addObject(new GameObject(objScene, t, pos.x,pos.y,pos.z));
-	//printf("created bullet object\n");
-	const Vector3 norm(view.y, -view.x, 0.85);
-	const Vector3 bullet_speed(500.0f, 0.0f, 0.0f);
-	b->setVel(bullet_speed);
 
+	//find target for tower
+	GameObject* target = objScene->getTarget();
+	printf("target: %d", target->getSpriteType());
+
+	//set bullet direction to enemy direction
+	const Vector3 dir = b->getPos() - target->getPos();
+	b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
+
+	const Vector3 norm(view.y, view.x, 0.85f);
+
+	printf("created bullet object\n");
+	//const Vector3 norm(view.y, -view.x, 0.85);
+	
+	b->setVel(p->getVel() + 500.0f *view);
+	b->setRoll(b->m_fRoll);
+
 }
 void Tower::setRoll(float angle) {
-
+	GameObject::setRoll(angle);
 }

------------------------------------------------------------------------
r15 | amm0837 | 2020-10-29 16:01:39 -0500 (Thu, 29 Oct 2020) | 1 line



Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 14)
+++ Source/Tower.cpp	(revision 15)
@@ -13,7 +13,7 @@
 }
 void Tower::move() {
 	
-	//fire(this, BULLET1);
+	fire(this, BULLET1);
 	//printf("fired a bullet\n");
 }
 void Tower::fire(GameObject* p, eSpriteType t) {
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 14)
+++ Source/GameObject.cpp	(revision 15)
@@ -8,7 +8,7 @@
 }
 
 void GameObject::update() {
-	//printf("GameObject::update()\n");
+	printf("GameObject::update()\n");
 	const float t = m_pStepTimer->GetElapsedSeconds();
 	m_vPos.x += m_vVelocity.x * t;
 	m_vPos.y += m_vVelocity.y * t;

------------------------------------------------------------------------
r16 | jdg0393 | 2020-10-29 16:46:34 -0500 (Thu, 29 Oct 2020) | 1 line

Fixed update method in Scene screaming when the vector changes.

Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 15)
+++ Source/GameObject.h	(revision 16)
@@ -27,9 +27,9 @@
 	Vector2 getViewVect();
 
 
-private:
+protected:
 	Scene* scene; // Scene which manages this object
 	Vector2 m_vVelocity = Vector2::Zero;
-	
+
 };
 
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 15)
+++ Source/Tower.h	(revision 16)
@@ -7,7 +7,7 @@
 class Tower : public GameObject {
 public:
 	Tower(Scene* scene, float x, float y, float z);
-	void update();
+	void update() override;
 	void move();
 	void fire(GameObject* p, eSpriteType t);
 
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 15)
+++ Source/Scene.cpp	(revision 16)
@@ -32,11 +32,15 @@
 // the update method of game objects.
 void Scene::update() {
 	//printf("Scene::update()\n");
+	//vector<GameObject*> objects = objectList;
 	// Update every game object managed by this scene
 	//printf("objlist size %d", objectList.size());
-	for (GameObject*& obj : objectList) {
-		obj->update();
-		
+	//for (GameObject*& obj : objects) {
+	//	obj->update();
+	//}
+	int sz = objectList.size();
+	for (int i = 0; i < sz; i++) {
+		objectList[i]->update();
 	}
 }
 
@@ -175,7 +179,7 @@
 //returns a pointer to an object for towers to target
 GameObject* Scene::getTarget() {
 	for (auto it = begin(objectList); it != end(objectList); ++it) {
-		if ((*it)->getSpriteType() == 3) {
+		if ((*it)->getSpriteType() == HUMAN_IDLE) {
 			return *it;
 		}
 	}
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 15)
+++ Source/Tower.cpp	(revision 16)
@@ -12,7 +12,6 @@
 	move();
 }
 void Tower::move() {
-	
 	fire(this, BULLET1);
 	//printf("fired a bullet\n");
 }

------------------------------------------------------------------------
r17 | amm0837 | 2020-10-30 11:56:23 -0500 (Fri, 30 Oct 2020) | 1 line

Bullets track another objects position and fire at them. Once we have enemy sprites, we just have to change the target for the tower. Also the bullet fire rate is 1 bullet per second.

Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 16)
+++ Source/Tower.h	(revision 17)
@@ -14,6 +14,6 @@
 	void setRoll(float angle);
 
 private:
-
+	float m_fGunTimer = 0.0f;
 	Scene* objScene;
 };
\ No newline at end of file
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 16)
+++ Source/GameObject.cpp	(revision 17)
@@ -23,7 +23,7 @@
 	return m_fRoll;
 }
 Vector2 GameObject::getViewVect() {
-	return Vector2(-sinf(m_fRoll), cosf(m_fRoll));
+	return Vector2(sinf(m_fRoll), -cosf(m_fRoll));
 }
 
 const Vector3& GameObject::getPos() {
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 16)
+++ Source/Tower.cpp	(revision 17)
@@ -12,31 +12,37 @@
 	move();
 }
 void Tower::move() {
-	fire(this, BULLET1);
+	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
+		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
+		fire(this, BULLET1);
+	}
+
+	
 	//printf("fired a bullet\n");
 }
 void Tower::fire(GameObject* p, eSpriteType t) {
-	const Vector2 view = p->getViewVect();
+
+	
 	Vector3 pos = p->getPos();
 	
+	
 	GameObject * b = objScene->addObject(new GameObject(objScene, t, pos.x,pos.y,pos.z));
-
+	
 	//find target for tower
 	GameObject* target = objScene->getTarget();
-	printf("target: %d", target->getSpriteType());
+	
 
 	//set bullet direction to enemy direction
 	const Vector3 dir = b->getPos() - target->getPos();
 	b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
-
+	const Vector2 view = b->getViewVect();
 	const Vector3 norm(view.y, view.x, 0.85f);
 
-	printf("created bullet object\n");
-	//const Vector3 norm(view.y, -view.x, 0.85);
 	
-	b->setVel(p->getVel() + 500.0f *view);
+	
+	b->setVel(p->getVel() + 300.0f *view);
 	b->setRoll(b->m_fRoll);
-
+	
 }
 void Tower::setRoll(float angle) {
 	GameObject::setRoll(angle);

------------------------------------------------------------------------
r18 | amm0837 | 2020-10-30 13:15:51 -0500 (Fri, 30 Oct 2020) | 1 line

PC can place towers in their current position by pressing 'T'. The PC can also remove towers by pressing 'X'. This will delete whichever tower is closest to the PC at the time of button press. Also added gun sound to tower.

Index: Source/Sndlist.h
===================================================================
--- Source/Sndlist.h	(revision 17)
+++ Source/Sndlist.h	(revision 18)
@@ -11,5 +11,5 @@
 /// The sounds must be listed here in the same order that
 /// they are in the sound settings XML file.
 enum eSoundType {
-	CLANG_SOUND, UMPH_SOUND
+	GUN_SOUND, CLANG_SOUND,
 }; //eSoundType
\ No newline at end of file
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 17)
+++ Source/Scene.cpp	(revision 18)
@@ -99,6 +99,17 @@
 	return obj;
 }
 
+	//param object is the object to be deleted. REmoves object from objectlist
+void Scene::deleteObject(GameObject* object) {
+	for (std::vector<GameObject*>::iterator it = objectList.begin(); it != objectList.end(); it++) {
+		if (*it == object) {
+			objectList.erase(it);
+			return;
+		}
+	}
+	
+}
+
 void Scene::loadTileMap(std::string map_name, eSpriteType tileSpriteKey) {
 	// Add path to front of map_name
 	map_name = "Media\\Maps\\" + map_name + "\\" + map_name;
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 17)
+++ Source/Tower.cpp	(revision 18)
@@ -21,25 +21,19 @@
 	//printf("fired a bullet\n");
 }
 void Tower::fire(GameObject* p, eSpriteType t) {
-
-	
+	m_pAudio->play(GUN_SOUND);
 	Vector3 pos = p->getPos();
 	
-	
 	GameObject * b = objScene->addObject(new GameObject(objScene, t, pos.x,pos.y,pos.z));
 	
 	//find target for tower
 	GameObject* target = objScene->getTarget();
 	
-
 	//set bullet direction to enemy direction
 	const Vector3 dir = b->getPos() - target->getPos();
 	b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
-	const Vector2 view = b->getViewVect();
-	const Vector3 norm(view.y, view.x, 0.85f);
-
-	
-	
+	const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
+													//the direction of bullet velocity
 	b->setVel(p->getVel() + 300.0f *view);
 	b->setRoll(b->m_fRoll);
 	
Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 17)
+++ Source/Scene.h	(revision 18)
@@ -24,7 +24,8 @@
 	virtual void create();
 	virtual void update();
 	virtual void render();
-	GameObject* addObject(GameObject* obj); // Adds an object to the list
+	GameObject* addObject(GameObject* obj);// Adds an object to the list
+	void deleteObject(GameObject* object);//Remove an object from the scene, mainly to allow the user to destroy a misplaced tower
 	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
 	GameObject* getTarget();
 protected:
Index: Source/SimpleMapScene.cpp
===================================================================
--- Source/SimpleMapScene.cpp	(revision 17)
+++ Source/SimpleMapScene.cpp	(revision 18)
@@ -19,7 +19,6 @@
 	// Tilemap overhead layer is rendered at .8z, foreground at .9z
 	// So we place the human in between at .85z
 	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, 50, 50, .85));
-	addObject(new Tower(this, 100, 100, 0.85));  //adds a tower, want to make placement user specified
 	// Set the camera to follow the player
 	camFollowVision(player);
 	
@@ -65,6 +64,16 @@
 	// Toggle drawing of tilemap collision boxes
 	if (m_pKeyboard->TriggerDown(VK_F4))
 		drawMapClsn = drawMapClsn ? false : true;
+	//Press T to place a tower at the PC's current location
+	if (m_pKeyboard->TriggerDown('T')) {
+		Vector3 pos = player->getPos();
+		addObject(new Tower(this, pos.x, pos.y, 0.85));
+	}
+
+	if (m_pKeyboard->TriggerDown('X')) {
+		GameObject* tow = getClosestTower();
+		deleteObject(tow);
+	}
 }
 
 void SimpleMapScene::_handleMoveKeys() {
@@ -112,4 +121,24 @@
 	// If the player is colliding, move them back
 	if (hit)
 		player->unmove();
+}
+	//returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
+GameObject* SimpleMapScene::getClosestTower() {
+	Vector3 playerPos = player->getPos();
+	Vector3 towerPos;
+	GameObject* tow = NULL;
+	float difX = 1000, difY = 1000, dif = 1000;
+	for (GameObject*& obj : objectList) {
+		if (obj->getSpriteType() == TOWER1) {
+			towerPos = obj->getPos();
+			difX = abs(playerPos.x - towerPos.x);
+			difY = abs(playerPos.y - towerPos.y);
+			if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif) {
+				dif = sqrt(pow(difX, 2) + pow(difY, 2));
+				tow = obj;
+			}
+		}
+	}
+	return tow;
+	
 }
\ No newline at end of file
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 17)
+++ Source/Renderer.cpp	(revision 18)
@@ -31,6 +31,7 @@
 	Load(BULLET1, "bullet1");
 	Load(TOWER1, "tower1");
 
+
 	EndResourceUpload();
 } //LoadImages
 
Index: Source/SimpleMapScene.h
===================================================================
--- Source/SimpleMapScene.h	(revision 17)
+++ Source/SimpleMapScene.h	(revision 18)
@@ -15,6 +15,7 @@
 	void update() override;
 	void camFollowVision(GameObject* target); // Set the camera to follow a target
 	void camMapVision(); // Set the camera to center on the tilemap
+	GameObject* getClosestTower();//returns the tower closest to the PC
 private:
 	PlayerCharacter* player = nullptr; // Reference to the player character
 	Vector3 defPos; // Default "true size" camera position

------------------------------------------------------------------------
r19 | jdg0393 | 2020-10-31 14:33:28 -0500 (Sat, 31 Oct 2020) | 1 line

Fixed memory leak and modified Tower to better conform to design pattern.

Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 18)
+++ Source/Tower.cpp	(revision 19)
@@ -3,40 +3,39 @@
 
 Tower::Tower(Scene* scene, float x = 0, float y = 0, float z = 0) :
 	GameObject(scene, TOWER1, x, y, z)
-{	
+{
 	objScene = scene;
 	setRoll(XM_2PI);
 }
 void Tower::update() {
 	//printf("update function for tower \n");
-	move();
-}
-void Tower::move() {
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
 		fire(this, BULLET1);
 	}
+}
 
-	
-	//printf("fired a bullet\n");
+GameObject* Tower::calcTarget() {
+	return ((SimpleMapScene*)scene)->getPlayer();
 }
+
 void Tower::fire(GameObject* p, eSpriteType t) {
 	m_pAudio->play(GUN_SOUND);
 	Vector3 pos = p->getPos();
-	
-	GameObject * b = objScene->addObject(new GameObject(objScene, t, pos.x,pos.y,pos.z));
-	
+
+	GameObject* b = objScene->addObject(new GameObject(objScene, t, pos.x, pos.y, pos.z));
+
 	//find target for tower
-	GameObject* target = objScene->getTarget();
-	
+	target = calcTarget();
+
 	//set bullet direction to enemy direction
 	const Vector3 dir = b->getPos() - target->getPos();
 	b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
 	const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
 													//the direction of bullet velocity
-	b->setVel(p->getVel() + 300.0f *view);
+	b->setVel(p->getVel() + 300.0f * view);
 	b->setRoll(b->m_fRoll);
-	
+
 }
 void Tower::setRoll(float angle) {
 	GameObject::setRoll(angle);
Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 18)
+++ Source/Scene.h	(revision 19)
@@ -27,7 +27,6 @@
 	GameObject* addObject(GameObject* obj);// Adds an object to the list
 	void deleteObject(GameObject* object);//Remove an object from the scene, mainly to allow the user to destroy a misplaced tower
 	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
-	GameObject* getTarget();
 protected:
 	CGame* game; // Reference to game which created this scene
 	std::vector<GameObject*> objectList; // Game objects managed by this scene
@@ -35,7 +34,7 @@
 	int tilemapWidth = 0; // Width of tilemap in tiles
 	int tilemapHeight = 0; // Height of tilemap in tiles
 	// Data about tile graphic
-	eSpriteType tileset; // Sprite index to use for rendering tilemap
+	eSpriteType tileset = SIMPLE_TILE; // Sprite index to use for rendering tilemap
 	int tileSize = 0; // Width and height of tile in pixels (must be square)
 	// Tile layers that should be displayed
 	std::vector<TileLayer> layers;
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 18)
+++ Source/Tower.h	(revision 19)
@@ -8,12 +8,12 @@
 public:
 	Tower(Scene* scene, float x, float y, float z);
 	void update() override;
-	void move();
+	GameObject* calcTarget();
 	void fire(GameObject* p, eSpriteType t);
-
 	void setRoll(float angle);
 
 private:
+	GameObject* target = nullptr;
 	float m_fGunTimer = 0.0f;
 	Scene* objScene;
 };
\ No newline at end of file
Index: Source/SimpleMapScene.cpp
===================================================================
--- Source/SimpleMapScene.cpp	(revision 18)
+++ Source/SimpleMapScene.cpp	(revision 19)
@@ -21,7 +21,7 @@
 	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, 50, 50, .85));
 	// Set the camera to follow the player
 	camFollowVision(player);
-	
+
 }
 
 void SimpleMapScene::update() {
@@ -64,6 +64,7 @@
 	// Toggle drawing of tilemap collision boxes
 	if (m_pKeyboard->TriggerDown(VK_F4))
 		drawMapClsn = drawMapClsn ? false : true;
+	
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('T')) {
 		Vector3 pos = player->getPos();
@@ -122,7 +123,13 @@
 	if (hit)
 		player->unmove();
 }
-	//returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
+
+// Provides the player character pointer
+PlayerCharacter* SimpleMapScene::getPlayer() {
+	return player;
+}
+
+//returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
 GameObject* SimpleMapScene::getClosestTower() {
 	Vector3 playerPos = player->getPos();
 	Vector3 towerPos;
@@ -140,5 +147,5 @@
 		}
 	}
 	return tow;
-	
+
 }
\ No newline at end of file
Index: Source/SimpleMapScene.h
===================================================================
--- Source/SimpleMapScene.h	(revision 18)
+++ Source/SimpleMapScene.h	(revision 19)
@@ -15,6 +15,7 @@
 	void update() override;
 	void camFollowVision(GameObject* target); // Set the camera to follow a target
 	void camMapVision(); // Set the camera to center on the tilemap
+	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
 private:
 	PlayerCharacter* player = nullptr; // Reference to the player character
Index: Source/Main.cpp
===================================================================
--- Source/Main.cpp	(revision 18)
+++ Source/Main.cpp	(revision 19)
@@ -6,7 +6,7 @@
 
 #ifdef _DEBUG
 #define USE_DEBUG_CONSOLE ///< Define to use a console window for debug messages.
-//#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
+#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
 #endif
 
 static CWindow g_cWindow; ///< The window class.
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 18)
+++ Source/Scene.cpp	(revision 19)
@@ -99,15 +99,15 @@
 	return obj;
 }
 
-	//param object is the object to be deleted. REmoves object from objectlist
+// param object is the object to be deleted. REmoves object from objectlist and frees memory
 void Scene::deleteObject(GameObject* object) {
 	for (std::vector<GameObject*>::iterator it = objectList.begin(); it != objectList.end(); it++) {
 		if (*it == object) {
 			objectList.erase(it);
-			return;
+			break;
 		}
 	}
-	
+	delete object;
 }
 
 void Scene::loadTileMap(std::string map_name, eSpriteType tileSpriteKey) {
@@ -186,13 +186,3 @@
 		}
 	}
 }
-
-//returns a pointer to an object for towers to target
-GameObject* Scene::getTarget() {
-	for (auto it = begin(objectList); it != end(objectList); ++it) {
-		if ((*it)->getSpriteType() == HUMAN_IDLE) {
-			return *it;
-		}
-	}
-	//return objectList[1];
-}

------------------------------------------------------------------------
r21 | jdg0393 | 2020-10-31 19:36:32 -0500 (Sat, 31 Oct 2020) | 1 line

Player character updates their direction.

Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 20)
+++ Source/GameObject.cpp	(revision 21)
@@ -8,7 +8,7 @@
 }
 
 void GameObject::update() {
-	printf("GameObject::update()\n");
+	//printf("GameObject::update()\n");
 	const float t = m_pStepTimer->GetElapsedSeconds();
 	m_vPos.x += m_vVelocity.x * t;
 	m_vPos.y += m_vVelocity.y * t;
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 20)
+++ Source/PlayerCharacter.cpp	(revision 21)
@@ -10,8 +10,16 @@
 void PlayerCharacter::update() {
 	//printf("PlayerCharacter::update()");
 	move();
+	animate();
 }
 
+void PlayerCharacter::animate() {
+	// Set the direction the player should be facing
+	_calcDirection();
+	// Set the frame the player should use
+	m_nCurrentFrame = 0 + (direction * 4);
+}
+
 void PlayerCharacter::move() {
 	// Store the current position
 	oldPos = { m_vPos.x, m_vPos.y };
@@ -51,4 +59,26 @@
 	//printf("%fvx %fvy\n", xSpeed, ySpeed);
 	// Set the player's velocity
 	velocity = { xSpeed, ySpeed };
+}
+
+void PlayerCharacter::_calcDirection() {
+	if ((int)angle % 90 != 0) {
+		direction = angle / 90;
+	}
+	else if ((int)angle == 90) {
+		if (direction == 2) direction = 1;
+		else if (direction == 3) direction = 0;
+	}
+	else if ((int)angle == 270) {
+		if (direction == 0) direction = 3;
+		else if (direction == 1) direction = 2;
+	}
+	else if ((int)angle == 0) {
+		if (direction == 1) direction = 0;
+		else if (direction == 2) direction = 3;
+	}
+	else if ((int)angle == 180) {
+		if (direction == 0) direction = 1;
+		else if (direction == 3) direction = 2;
+	}
 }
\ No newline at end of file
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 20)
+++ Source/PlayerCharacter.h	(revision 21)
@@ -9,6 +9,7 @@
 public:
 	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
 	void update() override; // Character's update loop, runs every frame
+	void animate(); // Animates the character and sets their sprite
 	void move(); // Move the character once based on their velocity
 	void unmove(); // Undo the character's last movement
 	float getAngle() { return angle; } // Get the current angle in degrees
@@ -15,7 +16,9 @@
 	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
 private:
 	Vector2 oldPos; // Stores the position from the previous frame
+	int direction = 0; // Stores the direction as a number 0-3
 	float angle = 0; // Angle of the character in degrees
 	float speed = 0; // Speed of the character regardless of direction
 	Vector2 velocity = { 0,0 }; // Velocity of the character, accounts for direction
+	void _calcDirection();
 };

------------------------------------------------------------------------
r22 | jdg0393 | 2020-10-31 21:33:00 -0500 (Sat, 31 Oct 2020) | 1 line

Code separation for tile-based scenes. Prep work for loading paths.

Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 21)
+++ Source/Tower.h	(revision 22)
@@ -1,7 +1,7 @@
 #pragma once
 
 #include "GameObject.h"
-#include "SimpleMapScene.h"
+#include "BaseLevelScene.h"
 #include "stepTimer.h"
 
 class Tower : public GameObject {
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 21)
+++ Source/Game.cpp	(revision 22)
@@ -8,7 +8,10 @@
 #include "ComponentIncludes.h"
 
 CGame::~CGame() {
-	if (activeScene) delete activeScene;
+	if (activeScene) {
+		printf("Deleting active scene!\n");
+		delete activeScene;
+	}
 } //destructor
 
 /// Initialize the renderer and the object manager, load 
@@ -22,7 +25,7 @@
 	// Start the initial scene, maybe this should be a main menu?
 	// (We pass a pointer to this object because the scene has a circular
 	// reference for things such as swapping itself with another scene)
-	startScene(new SimpleMapScene(this));
+	startScene(new BaseLevelScene(this));
 } //Initialize
 
 /// Release all of the DirectX12 objects by deleting the renderer.
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 21)
+++ Source/Source.vcxproj	(revision 22)
@@ -171,7 +171,8 @@
     <ClCompile Include="PlayerCharacter.cpp" />
     <ClCompile Include="Renderer.cpp" />
     <ClCompile Include="Scene.cpp" />
-    <ClCompile Include="SimpleMapScene.cpp" />
+    <ClCompile Include="BaseLevelScene.cpp" />
+    <ClCompile Include="TiledScene.cpp" />
     <ClCompile Include="Tower.cpp" />
   </ItemGroup>
   <ItemGroup>
@@ -182,8 +183,9 @@
     <ClInclude Include="PlayerCharacter.h" />
     <ClInclude Include="Renderer.h" />
     <ClInclude Include="Scene.h" />
-    <ClInclude Include="SimpleMapScene.h" />
+    <ClInclude Include="BaseLevelScene.h" />
     <ClInclude Include="Sndlist.h" />
+    <ClInclude Include="TiledScene.h" />
     <ClInclude Include="Tower.h" />
   </ItemGroup>
   <ItemGroup>
Index: Source/Game.h
===================================================================
--- Source/Game.h	(revision 21)
+++ Source/Game.h	(revision 22)
@@ -6,7 +6,7 @@
 #include "Component.h"
 #include "Common.h"
 #include "Settings.h"
-#include "SimpleMapScene.h"
+#include "BaseLevelScene.h"
 
 /// \brief The game class.
 class CGame :
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 21)
+++ Source/Source.vcxproj.filters	(revision 22)
@@ -11,9 +11,6 @@
     <ClCompile Include="GameObject.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
-    <ClCompile Include="SimpleMapScene.cpp">
-      <Filter>Scenes</Filter>
-    </ClCompile>
     <ClCompile Include="PlayerCharacter.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
@@ -20,6 +17,12 @@
     <ClCompile Include="Tower.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="BaseLevelScene.cpp">
+      <Filter>Scenes</Filter>
+    </ClCompile>
+    <ClCompile Include="TiledScene.cpp">
+      <Filter>Scenes</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -33,9 +36,6 @@
     <ClInclude Include="GameObject.h">
       <Filter>Objects</Filter>
     </ClInclude>
-    <ClInclude Include="SimpleMapScene.h">
-      <Filter>Scenes</Filter>
-    </ClInclude>
     <ClInclude Include="PlayerCharacter.h">
       <Filter>Objects</Filter>
     </ClInclude>
@@ -42,6 +42,12 @@
     <ClInclude Include="Tower.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="BaseLevelScene.h">
+      <Filter>Scenes</Filter>
+    </ClInclude>
+    <ClInclude Include="TiledScene.h">
+      <Filter>Scenes</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 21)
+++ Source/Scene.cpp	(revision 22)
@@ -59,16 +59,6 @@
 		renders.push_back(objAsSprite);
 	}
 
-	// Add each layer of the tilemap to render list
-	for (TileLayer& layer : layers) {
-		for (vector<CSpriteDesc3D>& row : layer) {
-			for (CSpriteDesc3D& col : row) {
-				if (m_pRenderer->BoxInFrustum(col.m_sAabb))
-					renders.push_back(&col);
-			}
-		}
-	}
-
 	// Depth sort the render list
 	stable_sort(renders.begin(), renders.end(), [](CSpriteDesc3D* a, CSpriteDesc3D* b) {
 		return a->m_vPos.z > b->m_vPos.z;
@@ -78,14 +68,6 @@
 	for (auto spr : renders) {
 		m_pRenderer->Draw(*spr);
 	}
-
-	// If we are set to draw tilemap collision boxes, do that now
-	if (drawMapClsn) {
-		for (const BoundingBox& box : clsnBoxes) {
-			m_pRenderer->DrawBoundingBox(box);
-		}
-	}
-
 }
 
 // Adds an object to the list of objects, and returns the object in case we
@@ -109,80 +91,3 @@
 	}
 	delete object;
 }
-
-void Scene::loadTileMap(std::string map_name, eSpriteType tileSpriteKey) {
-	// Add path to front of map_name
-	map_name = "Media\\Maps\\" + map_name + "\\" + map_name;
-	//printf("%s", map_name.c_str());
-	// Load data about the tilemap
-	std::ifstream inData(map_name + "_data.txt");
-	// Load the data in a predetermined order
-	inData >> tileSize >> tilemapWidth >> tilemapHeight;
-	// Close the data file
-	inData.close();
-
-	// Load each of the main 3 display layers
-	loadTileLayer(map_name + "_bg.txt", tileSpriteKey);
-	loadTileLayer(map_name + "_fg.txt", tileSpriteKey);
-	loadTileLayer(map_name + "_oh.txt", tileSpriteKey);
-
-	// Points to help with positioning tiles
-	float top = tileSize * tilemapHeight;
-
-	// Create the collisions for the map
-	int numClsnBoxes = 0;
-	std::ifstream inClsn(map_name + "_collision.txt");
-	inClsn >> numClsnBoxes; // Get the number of collision boxes to read
-	for (int i = 0; i < numClsnBoxes; i++) {
-		float x, y, w, h;
-		// Read in a collision box in order of coordinates then size
-		inClsn >> x >> y >> w >> h;
-		// Collision box object
-		BoundingBox clsnBox;
-		// Determine coordinates for aabb
-		float x0 = x;
-		float x1 = x0 + w;
-		// Y coordinates from the map are top->bottom, larc axis is bottom->top
-		// So we have to convert this.
-		float y0 = top - y;
-		float y1 = y0 - h;
-		// Create the box from coordinates
-		BoundingBox::CreateFromPoints(clsnBox, { x0, y0 }, { x1, y1 });
-		// Add the collision box to the list
-		clsnBoxes.push_back(clsnBox);
-	}
-}
-
-void Scene::loadTileLayer(std::string filename, eSpriteType tileSpriteKey) {
-	// Get the index of the layers vector we will be pushing a layer to
-	int i = layers.size();
-	// Push a new layer
-	layers.push_back(TileLayer());
-	// Open the correct file
-	std::ifstream in(filename);
-
-	// For the number of rows
-	for (int r = 0; r < tilemapHeight; r++) {
-		// Add a new row to the map
-		layers[i].push_back(std::vector<CSpriteDesc3D>());
-		// For the number of columns
-		for (int c = 0; c < tilemapWidth; c++) {
-			int tileID;
-			in >> tileID;
-			if (tileID >= 0) {
-				CSpriteDesc3D desc;
-				desc.m_nSpriteIndex = tileSpriteKey;
-				desc.m_nCurrentFrame = tileID;
-				// Larc engine uses a mathematical axis, so +y is upwards
-				// and lower Z values render on top
-				desc.m_vPos = Vector3((c * tileSize) + 4, (r * tileSize * -1) + (tilemapHeight * tileSize) - 4, 1 - (i / 10.0));
-				BoundingBox b;
-				Vector3 p = desc.m_vPos;
-				b.Center = { p.x, p.y, p.z };
-				b.Extents = { 4, 4, 4 };
-				desc.m_sAabb = b;
-				layers[i][r].push_back(desc);
-			}
-		}
-	}
-}
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 21)
+++ Source/Tower.cpp	(revision 22)
@@ -16,7 +16,7 @@
 }
 
 GameObject* Tower::calcTarget() {
-	return ((SimpleMapScene*)scene)->getPlayer();
+	return ((BaseLevelScene*)scene)->getPlayer();
 }
 
 void Tower::fire(GameObject* p, eSpriteType t) {
Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 21)
+++ Source/Scene.h	(revision 22)
@@ -11,9 +11,6 @@
 // (We can't just include it b/c of circular dependency
 class CGame;
 
-// Type aliases
-typedef std::vector<std::vector<CSpriteDesc3D>> TileLayer;
-
 class Scene :
 	public CCommon,
 	public CComponent
@@ -20,30 +17,14 @@
 {
 public:
 	Scene(CGame* game);
-	~Scene();
+	virtual ~Scene();
 	virtual void create();
 	virtual void update();
 	virtual void render();
 	GameObject* addObject(GameObject* obj);// Adds an object to the list
 	void deleteObject(GameObject* object);//Remove an object from the scene, mainly to allow the user to destroy a misplaced tower
-	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
 protected:
 	CGame* game; // Reference to game which created this scene
 	std::vector<GameObject*> objectList; // Game objects managed by this scene
-	// Data about the tilemap
-	int tilemapWidth = 0; // Width of tilemap in tiles
-	int tilemapHeight = 0; // Height of tilemap in tiles
-	// Data about tile graphic
-	eSpriteType tileset = SIMPLE_TILE; // Sprite index to use for rendering tilemap
-	int tileSize = 0; // Width and height of tile in pixels (must be square)
-	// Tile layers that should be displayed
-	std::vector<TileLayer> layers;
-	// List of collision boxes for scene (tile aabbs, usually)
-	std::vector<BoundingBox> clsnBoxes;
-	// Boolean determining if we draw tilemap aabbs
-	bool drawMapClsn = false;
-
-	// Function to add a single layer of a map
-	void loadTileLayer(std::string filename, eSpriteType tileSpriteKey);
 };
 

------------------------------------------------------------------------
r23 | jdg0393 | 2020-10-31 21:33:58 -0500 (Sat, 31 Oct 2020) | 1 line

Forgot to add these files last commit.

Index: Source/SimpleMapScene.cpp (deleted)
===================================================================
Index: Source/SimpleMapScene.h (deleted)
===================================================================
Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(nonexistent)
+++ Source/TiledScene.cpp	(revision 23)
@@ -0,0 +1,125 @@
+#include "TiledScene.h"
+#include "Game.h"
+
+TiledScene::TiledScene(CGame* game) : Scene(game) {}
+
+TiledScene::~TiledScene() { }
+
+void TiledScene::render() {
+	//printf("Scene::render()\n");
+	// Render list so that all the objects are depth sorted
+	vector<CSpriteDesc3D*> renders;
+
+	// Add every game object managed by this scene to render list
+	for (GameObject*& obj : objectList) {
+		// Object needs to be treated as a sprite descriptor
+		CSpriteDesc3D* objAsSprite = obj;
+		// Draw the object
+		renders.push_back(objAsSprite);
+	}
+
+	// Add each layer of the tilemap to render list
+	for (TileLayer& layer : layers) {
+		for (vector<CSpriteDesc3D>& row : layer) {
+			for (CSpriteDesc3D& col : row) {
+				if (m_pRenderer->BoxInFrustum(col.m_sAabb))
+					renders.push_back(&col);
+			}
+		}
+	}
+
+	// Depth sort the render list
+	stable_sort(renders.begin(), renders.end(), [](CSpriteDesc3D* a, CSpriteDesc3D* b) {
+		return a->m_vPos.z > b->m_vPos.z;
+	});
+
+	// Draw all the objects now that they've been depth sorted
+	for (auto spr : renders) {
+		m_pRenderer->Draw(*spr);
+	}
+
+	// If we are set to draw tilemap collision boxes, do that now
+	if (drawMapClsn) {
+		for (const BoundingBox& box : clsnBoxes) {
+			m_pRenderer->DrawBoundingBox(box);
+		}
+	}
+}
+
+void TiledScene::loadTileMap(std::string map_name, eSpriteType tileSpriteKey) {
+	// Add path to front of map_name
+	map_name = "Media\\Maps\\" + map_name + "\\" + map_name;
+	//printf("%s", map_name.c_str());
+	// Load data about the tilemap
+	std::ifstream inData(map_name + "_data.txt");
+	// Load the data in a predetermined order
+	inData >> tileSize >> tilemapWidth >> tilemapHeight;
+	// Close the data file
+	inData.close();
+
+	// Load each of the main 3 display layers
+	loadTileLayer(map_name + "_bg.txt", tileSpriteKey);
+	loadTileLayer(map_name + "_fg.txt", tileSpriteKey);
+	loadTileLayer(map_name + "_oh.txt", tileSpriteKey);
+
+	// Points to help with positioning tiles
+	float top = tileSize * tilemapHeight;
+
+	// Create the collisions for the map
+	int numClsnBoxes = 0;
+	std::ifstream inClsn(map_name + "_collision.txt");
+	inClsn >> numClsnBoxes; // Get the number of collision boxes to read
+	for (int i = 0; i < numClsnBoxes; i++) {
+		float x, y, w, h;
+		// Read in a collision box in order of coordinates then size
+		inClsn >> x >> y >> w >> h;
+		// Collision box object
+		BoundingBox clsnBox;
+		// Determine coordinates for aabb
+		float x0 = x;
+		float x1 = x0 + w;
+		// Y coordinates from the map are top->bottom, larc axis is bottom->top
+		// So we have to convert this.
+		float y0 = top - y;
+		float y1 = y0 - h;
+		// Create the box from coordinates
+		BoundingBox::CreateFromPoints(clsnBox, { x0, y0 }, { x1, y1 });
+		// Add the collision box to the list
+		clsnBoxes.push_back(clsnBox);
+	}
+}
+
+void TiledScene::loadTileLayer(std::string filename, eSpriteType tileSpriteKey) {
+	// Get the index of the layers vector we will be pushing a layer to
+	int i = layers.size();
+	// Push a new layer
+	layers.push_back(TileLayer());
+	// Open the correct file
+	std::ifstream in(filename);
+
+	// For the number of rows
+	for (int r = 0; r < tilemapHeight; r++) {
+		// Add a new row to the map
+		layers[i].push_back(std::vector<CSpriteDesc3D>());
+		// For the number of columns
+		for (int c = 0; c < tilemapWidth; c++) {
+			int tileID;
+			in >> tileID;
+			if (tileID >= 0) {
+				CSpriteDesc3D desc;
+				desc.m_nSpriteIndex = tileSpriteKey;
+				desc.m_nCurrentFrame = tileID;
+				// Larc engine uses a mathematical axis, so +y is upwards
+				// and lower Z values render on top
+				desc.m_vPos = Vector3((c * tileSize) + 4, (r * tileSize * -1) + (tilemapHeight * tileSize) - 4, 1 - (i / 10.0));
+				BoundingBox b;
+				Vector3 p = desc.m_vPos;
+				b.Center = { p.x, p.y, p.z };
+				b.Extents = { 4, 4, 4 };
+				desc.m_sAabb = b;
+				layers[i][r].push_back(desc);
+			}
+		}
+	}
+	in.close();
+}
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(nonexistent)
+++ Source/BaseLevelScene.cpp	(revision 23)
@@ -0,0 +1,153 @@
+#include "BaseLevelScene.h"
+#include "Game.h"
+
+BaseLevelScene::BaseLevelScene(CGame* game) :
+	TiledScene(game)
+{
+	// Get the default camera position
+	Vector3 pos = m_pRenderer->GetCameraPos();
+}
+
+BaseLevelScene::~BaseLevelScene() { }
+
+void BaseLevelScene::create() {
+	printf("SimpleMapScene::create()\n");
+	// Call parent create() method to create background
+	Scene::create();
+	// Track the original camera position for easy scaling
+	defPos = m_pRenderer->GetCameraPos();
+	// Create the simple tilemap
+	loadTileMap("simple", SIMPLE_TILE);
+	// Tilemap overhead layer is rendered at .8z, foreground at .9z
+	// So we place the human in between at .85z
+	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, 50, 50, .85));
+	// Set the camera to follow the player
+	camFollowVision(player);
+
+}
+
+void BaseLevelScene::update() {
+	// Handling controls specific to the scene
+	handleKeyboard();
+	// Core scene update, including updating objects
+	Scene::update();
+	// Check for the player colliding with the tilemap
+	checkPlyClsn();
+	// Update the camera position if we're following the player
+	if (followTarget)
+		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
+}
+
+void BaseLevelScene::camFollowVision(GameObject* target) {
+	shouldFollow = true;
+	followTarget = target;
+	m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
+}
+
+void BaseLevelScene::camMapVision() {
+	if (tileSize > 0) {
+		shouldFollow = false;
+		followTarget = nullptr;
+		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2) * tileSize, (tilemapHeight / 2) * tileSize, defPos.z / 2));
+	}
+}
+
+void BaseLevelScene::handleKeyboard() {
+	// No need to get the keyboard state, it's done in the Game!
+	// Just check values on the keyboard :)
+
+	// Movement controls
+	_handleMoveKeys();
+
+	// Toggle camera mode
+	if (m_pKeyboard->TriggerDown('Z'))
+		shouldFollow ? camMapVision() : camFollowVision(player);
+
+	// Toggle drawing of tilemap collision boxes
+	if (m_pKeyboard->TriggerDown(VK_F4))
+		drawMapClsn = drawMapClsn ? false : true;
+
+	//Press T to place a tower at the PC's current location
+	if (m_pKeyboard->TriggerDown('T')) {
+		Vector3 pos = player->getPos();
+		addObject(new Tower(this, pos.x, pos.y, 0.85));
+	}
+
+	if (m_pKeyboard->TriggerDown('X')) {
+		GameObject* tow = getClosestTower();
+		deleteObject(tow);
+	}
+}
+
+void BaseLevelScene::_handleMoveKeys() {
+	// Moving of the character
+	if (m_pKeyboard->Down('A'))
+	{
+		// Left-Up
+		if (m_pKeyboard->Down('W'))
+			player->setVelocity(100, 135);
+		// Left-Down
+		else if (m_pKeyboard->Down('S'))
+			player->setVelocity(100, 225);
+		// Left
+		else
+			player->setVelocity(100, 180);
+	}
+	else if (m_pKeyboard->Down('D'))
+	{
+		// Right-Up
+		if (m_pKeyboard->Down('W'))
+			player->setVelocity(100, 45);
+		// Right-Down
+		else if (m_pKeyboard->Down('S'))
+			player->setVelocity(100, 315);
+		// Right
+		else
+			player->setVelocity(100, 0);
+	}
+	// Down
+	else if (m_pKeyboard->Down('S'))
+		player->setVelocity(100, 270);
+	// Up
+	else if (m_pKeyboard->Down('W'))
+		player->setVelocity(100, 90);
+	// No movement
+	else
+		player->setVelocity(0, player->getAngle());
+}
+
+void BaseLevelScene::checkPlyClsn() {
+	// Determine if the player is colliding with the map
+	bool hit = false;
+	for (auto i = clsnBoxes.begin(); i != clsnBoxes.end() && !hit; i++)
+		hit = player->m_sAabb.Intersects(*i);
+	// If the player is colliding, move them back
+	if (hit)
+		player->unmove();
+}
+
+// Provides the player character pointer
+PlayerCharacter* BaseLevelScene::getPlayer() {
+	return player;
+}
+
+//returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
+GameObject* BaseLevelScene::getClosestTower() {
+	Vector3 playerPos = player->getPos();
+	Vector3 towerPos;
+	GameObject* tow = NULL;
+	float difX = 1000, difY = 1000, dif = 1000;
+	for (GameObject*& obj : objectList) {
+		if (obj->getSpriteType() == TOWER1) {
+			towerPos = obj->getPos();
+			difX = abs(playerPos.x - towerPos.x);
+			difY = abs(playerPos.y - towerPos.y);
+			if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif) {
+				dif = sqrt(pow(difX, 2) + pow(difY, 2));
+				tow = obj;
+			}
+		}
+	}
+	return tow;
+
+}
\ No newline at end of file
Index: Source/TiledScene.h
===================================================================
--- Source/TiledScene.h	(nonexistent)
+++ Source/TiledScene.h	(revision 23)
@@ -0,0 +1,46 @@
+#pragma once
+#include <string>
+#include <unordered_map>
+#include "Scene.h"
+
+// Forward declarations of classes that will exist
+// (We can't just include it b/c of circular dependency
+class CGame;
+struct PathPoint;
+
+// Type aliases
+typedef std::vector<std::vector<CSpriteDesc3D>> TileLayer;
+
+class TiledScene :
+	public Scene
+{
+public:
+	TiledScene(CGame* game);
+	virtual ~TiledScene() override;
+	void render() override;
+	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
+protected:
+	// Data about the tilemap
+	int tilemapWidth = 0; // Width of tilemap in tiles
+	int tilemapHeight = 0; // Height of tilemap in tiles
+	// Data about tile graphic
+	eSpriteType tileset = SIMPLE_TILE; // Sprite index to use for rendering tilemap
+	int tileSize = 0; // Width and height of tile in pixels (must be square)
+	// Tile layers that should be displayed
+	std::vector<TileLayer> layers;
+	// List of collision boxes for scene (tile aabbs, usually)
+	std::vector<BoundingBox> clsnBoxes;
+	// List of points on the level's path
+	unordered_map<string, PathPoint> paths;
+	// Boolean determining if we draw tilemap aabbs
+	bool drawMapClsn = false;
+	// Function to add a single layer of a map
+	void loadTileLayer(std::string filename, eSpriteType tileSpriteKey);
+};
+
+struct PathPoint {
+	int x = 0;
+	int y = 0;
+	string next = "null";
+	string name = "";
+};
\ No newline at end of file
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(nonexistent)
+++ Source/BaseLevelScene.h	(revision 23)
@@ -0,0 +1,30 @@
+#pragma once
+#include "TiledScene.h"
+#include "PlayerCharacter.h"
+#include "Tower.h"
+
+// Forward declarations for circular dependency
+class CGame;
+
+class BaseLevelScene :
+	public TiledScene
+{
+public:
+	BaseLevelScene(CGame* game);
+	virtual ~BaseLevelScene() override;
+	void create() override;
+	void update() override;
+	void camFollowVision(GameObject* target); // Set the camera to follow a target
+	void camMapVision(); // Set the camera to center on the tilemap
+	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
+	GameObject* getClosestTower();//returns the tower closest to the PC
+private:
+	PlayerCharacter* player = nullptr; // Reference to the player character
+	Vector3 defPos; // Default "true size" camera position
+	GameObject* followTarget = nullptr; // What the camera follows
+	bool shouldFollow = false; // Whether the camera is following
+	void handleKeyboard(); // Handler for the keyboard
+	void _handleMoveKeys(); // Internal function used by keyboard handler
+	void checkPlyClsn();
+};
+

------------------------------------------------------------------------
r24 | jdg0393 | 2020-11-01 01:21:49 -0600 (Sun, 01 Nov 2020) | 1 line

Goblin prototype that just chases the player.

Index: Source/Character.cpp
===================================================================
--- Source/Character.cpp	(nonexistent)
+++ Source/Character.cpp	(revision 24)
@@ -0,0 +1,78 @@
+#include "Character.h"
+
+Character::Character(Scene* scene, eSpriteType spriteKey, float x, float y, float z) :
+	GameObject(scene, spriteKey, x, y, z)
+{}
+
+void Character::animate() {
+	// Set the direction the player should be facing
+	_calcDirection();
+	// Set the frame the player should use
+	m_nCurrentFrame = 0 + (direction * 4);
+}
+
+void Character::move() {
+	// Store the current position
+	oldPos = { m_vPos.x, m_vPos.y };
+	// Get the time passed since last frame
+	const float t = m_pStepTimer->GetElapsedSeconds();
+	// Move based on velocity (in px/s) * time (in s)
+	m_vPos.x += velocity.x * t;
+	m_vPos.y += velocity.y * t;
+	// Update the bounding box location
+	m_sAabb.Center.x = m_vPos.x;
+	m_sAabb.Center.y = m_vPos.y;
+}
+
+void Character::unmove() {
+	// Store the current position
+	Vector2 nowPos = { m_vPos.x, m_vPos.y };
+	// Move back to the old position
+	m_vPos.x = oldPos.x;
+	m_vPos.y = oldPos.y;
+	// Set the new "old" position (which is actually where we started this frame)
+	oldPos = nowPos;
+	// Update the bounding box location
+	m_sAabb.Center.x = m_vPos.x;
+	m_sAabb.Center.y = m_vPos.y;
+}
+
+void Character::setVelocity(float speed, float angle_in_degrees) {
+	// The desired speed
+	this->speed = speed;
+	// Set the player's angle (we use this elsewhere as well)
+	angle = angle_in_degrees;
+	// Convert the angle to radians for mathematics
+	float angle_in_radians = angle_in_degrees * (MY_PI / 180);
+	// Calculate and round to 4 decimals the x component of the velocity
+	float xSpeed = speed * cos(angle_in_radians);
+	xSpeed = roundf(xSpeed * 10000) / 10000;
+	// Calculate and round to 4 decimals the y component of the velocity
+	float ySpeed = speed * sin(angle_in_radians);
+	ySpeed = roundf(ySpeed * 10000) / 10000;
+	//printf("%fvx %fvy\n", xSpeed, ySpeed);
+	// Set the player's velocity
+	velocity = { xSpeed, ySpeed };
+}
+
+void Character::_calcDirection() {
+	if ((int)angle % 90 != 0) {
+		direction = angle / 90;
+	}
+	else if ((int)angle == 90) {
+		if (direction == 2) direction = 1;
+		else if (direction == 3) direction = 0;
+	}
+	else if ((int)angle == 270) {
+		if (direction == 0) direction = 3;
+		else if (direction == 1) direction = 2;
+	}
+	else if ((int)angle == 0) {
+		if (direction == 1) direction = 0;
+		else if (direction == 2) direction = 3;
+	}
+	else if ((int)angle == 180) {
+		if (direction == 0) direction = 1;
+		else if (direction == 3) direction = 2;
+	}
+}
\ No newline at end of file
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 23)
+++ Source/Scene.cpp	(revision 24)
@@ -6,7 +6,6 @@
 // necessary configuration should occur. (Such as including a reference to the
 // game object)
 Scene::Scene(CGame* game) {
-	printf("Scene::Scene(CGame* game)\n");
 	this->game = game;
 }
 
@@ -22,7 +21,6 @@
 
 // Method where objects, tiles, etc should be created
 void Scene::create() {
-	printf("Scene::create()\n");
 	GameObject* backgroundSprite = addObject(new GameObject(this, BACKGROUND, 640, 360, 10));
 	backgroundSprite->m_fXScale = 2;
 	backgroundSprite->m_fYScale = 2;
@@ -31,13 +29,6 @@
 // Method that runs every tick, most logic should go here. You may also call
 // the update method of game objects.
 void Scene::update() {
-	//printf("Scene::update()\n");
-	//vector<GameObject*> objects = objectList;
-	// Update every game object managed by this scene
-	//printf("objlist size %d", objectList.size());
-	//for (GameObject*& obj : objects) {
-	//	obj->update();
-	//}
 	int sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
 		objectList[i]->update();
@@ -47,7 +38,6 @@
 // Method to render the scene. Typically you'll just want to render all
 // objects in the list.
 void Scene::render() {
-	//printf("Scene::render()\n");
 	// Render list so that all the objects are depth sorted
 	vector<CSpriteDesc3D*> renders;
 
@@ -77,11 +67,10 @@
 // in the scene's list, all in one line.
 GameObject* Scene::addObject(GameObject* obj) {
 	objectList.push_back(obj);
-	//printf("added object %d", obj->getSpriteType());
 	return obj;
 }
 
-// param object is the object to be deleted. REmoves object from objectlist and frees memory
+// param object is the object to be deleted. Removes object from objectlist and frees memory
 void Scene::deleteObject(GameObject* object) {
 	for (std::vector<GameObject*>::iterator it = objectList.begin(); it != objectList.end(); it++) {
 		if (*it == object) {
Index: Source/Character.h
===================================================================
--- Source/Character.h	(nonexistent)
+++ Source/Character.h	(revision 24)
@@ -0,0 +1,21 @@
+#pragma once
+#include "GameObject.h"
+class Character :
+    public GameObject
+{
+public:
+	Character::Character(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
+	virtual void animate(); // Animates the character and sets their sprite
+	void move(); // Move the character once based on their velocity
+	void unmove(); // Undo the character's last movement
+	float getAngle() { return angle; } // Get the current angle in degrees
+	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
+protected:
+	void _calcDirection();
+	Vector2 oldPos; // Stores the position from the previous frame
+	int direction = 0; // Stores the direction as a number 0-3
+	float angle = 0; // Angle of the character in degrees
+	float speed = 0; // Speed of the character regardless of direction
+	Vector2 velocity = { 0,0 }; // Velocity of the character, accounts for direction
+};
+
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(nonexistent)
+++ Source/BadCharacter.cpp	(revision 24)
@@ -0,0 +1,26 @@
+#include "BadCharacter.h"
+
+BadCharacter::BadCharacter(Scene* scene, float x, float y, float z) :
+	Character(scene, GOBLIN_IDLE, x, y, z)
+{
+	m_sAabb = BoundingBox({ x,y,z }, { 4,4,4 });
+}
+
+void BadCharacter::update() {
+	Vector2 travelVector = m_vPos - dest;
+	// Calculate angle to destination in radians
+	float angle_in_radians = atan2f(travelVector.y, travelVector.x) + MY_PI;
+	// Normalize to [0,2pi)
+	if (angle_in_radians < 0) { angle += 2 * MY_PI; }
+	// Calculate the angle in degrees
+	angle = angle_in_radians * (180 / MY_PI);
+	// Calculate the velocity
+	velocity = { 40 * cosf(angle_in_radians), 40 * sinf(angle_in_radians) };
+	// Move and animate
+	move();
+	animate();
+}
+
+void BadCharacter::setDestination(float x, float y) {
+	dest = { x, y };
+}
\ No newline at end of file
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 23)
+++ Source/Renderer.cpp	(revision 24)
@@ -28,7 +28,9 @@
 	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(HUMAN_IDLE, "human_idle");
+	Load(GOBLIN_IDLE, "goblin_idle");
 	Load(BULLET1, "bullet1");
+	Load(SPIRE, "spire");
 	Load(TOWER1, "tower1");
 
 
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(nonexistent)
+++ Source/BadCharacter.h	(revision 24)
@@ -0,0 +1,13 @@
+#pragma once
+#include "Character.h"
+class BadCharacter :
+	public Character
+{
+public:
+	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
+	virtual void update() override;
+	void setDestination(float x, float y);
+protected:
+	Vector2 dest = { 0,0 };
+};
+
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 23)
+++ Source/PlayerCharacter.cpp	(revision 24)
@@ -2,7 +2,7 @@
 #include "StepTimer.h"
 
 PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z) :
-	GameObject(scene, HUMAN_IDLE, x, y, z)
+	Character(scene, HUMAN_IDLE, x, y, z)
 {
 	m_sAabb = BoundingBox({ x,y,z }, { 4,4,4 });
 }
@@ -12,73 +12,3 @@
 	move();
 	animate();
 }
-
-void PlayerCharacter::animate() {
-	// Set the direction the player should be facing
-	_calcDirection();
-	// Set the frame the player should use
-	m_nCurrentFrame = 0 + (direction * 4);
-}
-
-void PlayerCharacter::move() {
-	// Store the current position
-	oldPos = { m_vPos.x, m_vPos.y };
-	// Get the time passed since last frame
-	const float t = m_pStepTimer->GetElapsedSeconds();
-	// Move based on velocity (in px/s) * time (in s)
-	m_vPos.x += velocity.x * t;
-	m_vPos.y += velocity.y * t;
-	// Update the bounding box location
-	m_sAabb.Center.x = m_vPos.x;
-	m_sAabb.Center.y = m_vPos.y;
-}
-
-void PlayerCharacter::unmove() {
-	// Store the current position
-	Vector2 nowPos = { m_vPos.x, m_vPos.y };
-	// Move back to the old position
-	m_vPos.x = oldPos.x;
-	m_vPos.y = oldPos.y;
-	// Set the new "old" position (which is actually where we started this frame)
-	oldPos = nowPos;
-}
-
-void PlayerCharacter::setVelocity(float speed, float angle_in_degrees) {
-	// The desired speed
-	this->speed = speed;
-	// Set the player's angle (we use this elsewhere as well)
-	angle = angle_in_degrees;
-	// Convert the angle to radians for mathematics
-	float angle_in_radians = angle_in_degrees * (MY_PI / 180);
-	// Calculate and round to 4 decimals the x component of the velocity
-	float xSpeed = speed * cos(angle_in_radians);
-	xSpeed = roundf(xSpeed * 10000) / 10000;
-	// Calculate and round to 4 decimals the y component of the velocity
-	float ySpeed = speed * sin(angle_in_radians);
-	ySpeed = roundf(ySpeed * 10000) / 10000;
-	//printf("%fvx %fvy\n", xSpeed, ySpeed);
-	// Set the player's velocity
-	velocity = { xSpeed, ySpeed };
-}
-
-void PlayerCharacter::_calcDirection() {
-	if ((int)angle % 90 != 0) {
-		direction = angle / 90;
-	}
-	else if ((int)angle == 90) {
-		if (direction == 2) direction = 1;
-		else if (direction == 3) direction = 0;
-	}
-	else if ((int)angle == 270) {
-		if (direction == 0) direction = 3;
-		else if (direction == 1) direction = 2;
-	}
-	else if ((int)angle == 0) {
-		if (direction == 1) direction = 0;
-		else if (direction == 2) direction = 3;
-	}
-	else if ((int)angle == 180) {
-		if (direction == 0) direction = 1;
-		else if (direction == 3) direction = 2;
-	}
-}
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 23)
+++ Source/Source.vcxproj	(revision 24)
@@ -164,6 +164,8 @@
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClCompile Include="BadCharacter.cpp" />
+    <ClCompile Include="Character.cpp" />
     <ClCompile Include="Common.cpp" />
     <ClCompile Include="Game.cpp" />
     <ClCompile Include="GameObject.cpp" />
@@ -176,6 +178,8 @@
     <ClCompile Include="Tower.cpp" />
   </ItemGroup>
   <ItemGroup>
+    <ClInclude Include="BadCharacter.h" />
+    <ClInclude Include="Character.h" />
     <ClInclude Include="Common.h" />
     <ClInclude Include="Game.h" />
     <ClInclude Include="GameDefines.h" />
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 23)
+++ Source/GameDefines.h	(revision 24)
@@ -14,7 +14,9 @@
 	GREENLINE_SPRITE,
 	SIMPLE_TILE,
 	HUMAN_IDLE,
+	GOBLIN_IDLE,
 	BULLET1,
+	SPIRE,
 	TOWER1,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 23)
+++ Source/PlayerCharacter.h	(revision 24)
@@ -1,24 +1,12 @@
 #pragma once
 
 #include <cmath>
-#include "GameObject.h"
+#include "Character.h"
 
 class PlayerCharacter :
-	public GameObject
+	public Character
 {
 public:
 	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
 	void update() override; // Character's update loop, runs every frame
-	void animate(); // Animates the character and sets their sprite
-	void move(); // Move the character once based on their velocity
-	void unmove(); // Undo the character's last movement
-	float getAngle() { return angle; } // Get the current angle in degrees
-	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
-private:
-	Vector2 oldPos; // Stores the position from the previous frame
-	int direction = 0; // Stores the direction as a number 0-3
-	float angle = 0; // Angle of the character in degrees
-	float speed = 0; // Speed of the character regardless of direction
-	Vector2 velocity = { 0,0 }; // Velocity of the character, accounts for direction
-	void _calcDirection();
 };
Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(revision 23)
+++ Source/TiledScene.cpp	(revision 24)
@@ -6,7 +6,6 @@
 TiledScene::~TiledScene() { }
 
 void TiledScene::render() {
-	//printf("Scene::render()\n");
 	// Render list so that all the objects are depth sorted
 	vector<CSpriteDesc3D*> renders;
 
@@ -49,7 +48,6 @@
 void TiledScene::loadTileMap(std::string map_name, eSpriteType tileSpriteKey) {
 	// Add path to front of map_name
 	map_name = "Media\\Maps\\" + map_name + "\\" + map_name;
-	//printf("%s", map_name.c_str());
 	// Load data about the tilemap
 	std::ifstream inData(map_name + "_data.txt");
 	// Load the data in a predetermined order
@@ -58,38 +56,16 @@
 	inData.close();
 
 	// Load each of the main 3 display layers
-	loadTileLayer(map_name + "_bg.txt", tileSpriteKey);
-	loadTileLayer(map_name + "_fg.txt", tileSpriteKey);
-	loadTileLayer(map_name + "_oh.txt", tileSpriteKey);
-
-	// Points to help with positioning tiles
-	float top = tileSize * tilemapHeight;
-
-	// Create the collisions for the map
-	int numClsnBoxes = 0;
-	std::ifstream inClsn(map_name + "_collision.txt");
-	inClsn >> numClsnBoxes; // Get the number of collision boxes to read
-	for (int i = 0; i < numClsnBoxes; i++) {
-		float x, y, w, h;
-		// Read in a collision box in order of coordinates then size
-		inClsn >> x >> y >> w >> h;
-		// Collision box object
-		BoundingBox clsnBox;
-		// Determine coordinates for aabb
-		float x0 = x;
-		float x1 = x0 + w;
-		// Y coordinates from the map are top->bottom, larc axis is bottom->top
-		// So we have to convert this.
-		float y0 = top - y;
-		float y1 = y0 - h;
-		// Create the box from coordinates
-		BoundingBox::CreateFromPoints(clsnBox, { x0, y0 }, { x1, y1 });
-		// Add the collision box to the list
-		clsnBoxes.push_back(clsnBox);
-	}
+	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey);
+	_loadTileLayer(map_name + "_fg.txt", tileSpriteKey);
+	_loadTileLayer(map_name + "_oh.txt", tileSpriteKey);
+	// Load the collision layer
+	_loadClsnLayer(map_name + "_collision.txt");
+	// Load the path layer
+	_loadPathLayer(map_name + "_paths.txt");
 }
 
-void TiledScene::loadTileLayer(std::string filename, eSpriteType tileSpriteKey) {
+void TiledScene::_loadTileLayer(std::string filename, eSpriteType tileSpriteKey) {
 	// Get the index of the layers vector we will be pushing a layer to
 	int i = layers.size();
 	// Push a new layer
@@ -123,3 +99,47 @@
 	}
 	in.close();
 }
+
+void TiledScene::_loadClsnLayer(std::string filename) {
+	// Points to help with positioning tiles
+	float top = tileSize * tilemapHeight;
+	// Create the collisions for the map
+	int numClsnBoxes = 0;
+	std::ifstream inClsn(filename);
+	inClsn >> numClsnBoxes; // Get the number of collision boxes to read
+	for (int i = 0; i < numClsnBoxes; i++) {
+		float x, y, w, h;
+		// Read in a collision box in order of coordinates then size
+		inClsn >> x >> y >> w >> h;
+		// Collision box object
+		BoundingBox clsnBox;
+		// Determine coordinates for aabb
+		float x0 = x;
+		float x1 = x0 + w;
+		// Y coordinates from the map are top->bottom, larc axis is bottom->top
+		// So we have to convert this.
+		float y0 = top - y;
+		float y1 = y0 - h;
+		// Create the box from coordinates
+		BoundingBox::CreateFromPoints(clsnBox, { x0, y0 }, { x1, y1 });
+		// Add the collision box to the list
+		clsnBoxes.push_back(clsnBox);
+	}
+}
+
+void TiledScene::_loadPathLayer(std::string filename) {
+	// Points to help with positioning tiles
+	float top = tileSize * tilemapHeight;
+	// Create the collisions for the map
+	int numPathPoints = 0;
+	std::ifstream inPath(filename);
+	inPath >> numPathPoints; // Get the number of collision boxes to read
+	for (int i = 0; i < numPathPoints; i++) {
+		// Read in a collision box in order of coordinates then size
+		PathPoint p;
+		inPath >> p.name >> p.x >> p.y >> p.next;
+		p.y = top - p.y;
+		paths[p.name] = p;
+	}
+	inPath.close();
+}
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 23)
+++ Source/BaseLevelScene.cpp	(revision 24)
@@ -11,7 +11,6 @@
 BaseLevelScene::~BaseLevelScene() { }
 
 void BaseLevelScene::create() {
-	printf("SimpleMapScene::create()\n");
 	// Call parent create() method to create background
 	Scene::create();
 	// Track the original camera position for easy scaling
@@ -20,15 +19,23 @@
 	loadTileMap("simple", SIMPLE_TILE);
 	// Tilemap overhead layer is rendered at .8z, foreground at .9z
 	// So we place the human in between at .85z
-	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, 50, 50, .85));
+	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, paths["plySpawn"].x, paths["plySpawn"].y, .85));
 	// Set the camera to follow the player
 	camFollowVision(player);
-
+	// Create the spire object
+	spire = addObject(new GameObject(this, SPIRE, paths["end"].x, paths["end"].y, .849));
+	spire->m_sAabb = BoundingBox({ spire->getPos().x, spire->getPos().y - 22, spire->getPos().z }, { 16, 7, 4 });
+	// Create some stupid bad guy
+	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths["enSpawn1"].x, paths["enSpawn1"].y, .851)));
 }
 
 void BaseLevelScene::update() {
 	// Handling controls specific to the scene
 	handleKeyboard();
+	// Temporarily make baddies move towards the player
+	for (auto baddie : baddies) {
+		baddie->setDestination(player->getPos().x, player->getPos().y);
+	}
 	// Core scene update, including updating objects
 	Scene::update();
 	// Check for the player colliding with the tilemap
@@ -38,6 +45,15 @@
 		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
 }
 
+void BaseLevelScene::render() {
+	TiledScene::render();
+	// If we are set to draw collision boxes, do that now
+	if (drawMapClsn) {
+		m_pRenderer->DrawBoundingBox(spire->m_sAabb);
+		m_pRenderer->DrawBoundingBox(player->m_sAabb);
+	}
+}
+
 void BaseLevelScene::camFollowVision(GameObject* target) {
 	shouldFollow = true;
 	followTarget = target;
@@ -121,6 +137,8 @@
 	bool hit = false;
 	for (auto i = clsnBoxes.begin(); i != clsnBoxes.end() && !hit; i++)
 		hit = player->m_sAabb.Intersects(*i);
+	// Check if the play is colliding with the spire
+	if (player->m_sAabb.Intersects(spire->m_sAabb)) hit = true;
 	// If the player is colliding, move them back
 	if (hit)
 		player->unmove();
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 23)
+++ Source/Source.vcxproj.filters	(revision 24)
@@ -23,6 +23,12 @@
     <ClCompile Include="TiledScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
+    <ClCompile Include="Character.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
+    <ClCompile Include="BadCharacter.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -48,6 +54,12 @@
     <ClInclude Include="TiledScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
+    <ClInclude Include="Character.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
+    <ClInclude Include="BadCharacter.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/TiledScene.h
===================================================================
--- Source/TiledScene.h	(revision 23)
+++ Source/TiledScene.h	(revision 24)
@@ -1,6 +1,6 @@
 #pragma once
 #include <string>
-#include <unordered_map>
+#include <map>
 #include "Scene.h"
 
 // Forward declarations of classes that will exist
@@ -17,7 +17,7 @@
 public:
 	TiledScene(CGame* game);
 	virtual ~TiledScene() override;
-	void render() override;
+	virtual void render() override;
 	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
 protected:
 	// Data about the tilemap
@@ -31,16 +31,18 @@
 	// List of collision boxes for scene (tile aabbs, usually)
 	std::vector<BoundingBox> clsnBoxes;
 	// List of points on the level's path
-	unordered_map<string, PathPoint> paths;
+	map<string, PathPoint> paths;
 	// Boolean determining if we draw tilemap aabbs
 	bool drawMapClsn = false;
-	// Function to add a single layer of a map
-	void loadTileLayer(std::string filename, eSpriteType tileSpriteKey);
+	// Functions to add a single layer of a map
+	void _loadTileLayer(std::string filename, eSpriteType tileSpriteKey);
+	void _loadClsnLayer(std::string filename);
+	void _loadPathLayer(std::string filename);
 };
 
 struct PathPoint {
-	int x = 0;
-	int y = 0;
+	float x = 0;
+	float y = 0;
 	string next = "null";
 	string name = "";
 };
\ No newline at end of file
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 23)
+++ Source/BaseLevelScene.h	(revision 24)
@@ -1,6 +1,7 @@
 #pragma once
 #include "TiledScene.h"
 #include "PlayerCharacter.h"
+#include "BadCharacter.h"
 #include "Tower.h"
 
 // Forward declarations for circular dependency
@@ -12,14 +13,17 @@
 public:
 	BaseLevelScene(CGame* game);
 	virtual ~BaseLevelScene() override;
-	void create() override;
-	void update() override;
+	virtual void create() override;
+	virtual void update() override;
+	virtual void render() override;
 	void camFollowVision(GameObject* target); // Set the camera to follow a target
 	void camMapVision(); // Set the camera to center on the tilemap
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
 private:
+	GameObject* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character
+	vector<BadCharacter*> baddies;
 	Vector3 defPos; // Default "true size" camera position
 	GameObject* followTarget = nullptr; // What the camera follows
 	bool shouldFollow = false; // Whether the camera is following

------------------------------------------------------------------------
r25 | jdg0393 | 2020-11-01 17:59:47 -0600 (Sun, 01 Nov 2020) | 1 line

Title Menu and selection between multiple fonts.

Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 24)
+++ Source/Source.vcxproj.filters	(revision 25)
@@ -29,6 +29,9 @@
     <ClCompile Include="BadCharacter.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="TitleScreenScene.cpp">
+      <Filter>Scenes</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -60,6 +63,9 @@
     <ClInclude Include="BadCharacter.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="TitleScreenScene.h">
+      <Filter>Scenes</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/TitleScreenScene.h
===================================================================
--- Source/TitleScreenScene.h	(nonexistent)
+++ Source/TitleScreenScene.h	(revision 25)
@@ -0,0 +1,21 @@
+#pragma once
+#include "Scene.h"
+
+// Forward declarations of classes that will exist
+// (We can't just include it b/c of circular dependency
+class CGame;
+
+class TitleScreenScene :
+    public Scene
+{
+public:
+    TitleScreenScene(CGame* game);
+	virtual ~TitleScreenScene() override;
+	virtual void create() override;
+	virtual void update() override;
+	virtual void render() override;
+private:
+	vector<string> menu;
+	int selection = 0;
+};
+
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 24)
+++ Source/Renderer.cpp	(revision 25)
@@ -10,6 +10,10 @@
 	CSpriteRenderer(Unbatched3D) {
 	// Initial camera position, standard "true pixel" frame
 	m_pCamera->MoveTo(Vector3(m_vWinCenter.x, m_vWinCenter.y, -1600));
+	// Keep track of the original font
+	fonts.push_back(move(m_pFont));
+	fontsRef["font"] = 0;
+	m_pFont = move(fonts[fontsRef["font"]]);
 } //constructor
 
 /// Load the specific images needed for this game.
@@ -25,6 +29,7 @@
 
 	// Loading of images goes here
 	Load(BACKGROUND, "background");
+	Load(TITLE_SCREEN, "title_screen");
 	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(HUMAN_IDLE, "human_idle");
@@ -33,8 +38,12 @@
 	Load(SPIRE, "spire");
 	Load(TOWER1, "tower1");
 
+	// Load any additional fonts
+	loadNewFont("title_font");
+	loadNewFont("selection_font");
 
 	EndResourceUpload();
+
 } //LoadImages
 
 /// Draw an axially aligned bounding box using the green line sprite.
@@ -49,6 +58,50 @@
 	clsnSprite.m_vPos = { center.x, center.y, -5 };
 	clsnSprite.m_fXScale = extent.x;
 	clsnSprite.m_fYScale = extent.y;
-
 	Draw(clsnSprite);
 } //DrawBoundingBox
+
+Vector2 CRenderer::getCenter() {
+	return Vector2(m_vWinCenter.x, m_vWinCenter.y);
+}
+
+
+// For some reason this function is only run for the first fonts, and we wanted more fonts
+// So I've borrowed it from the LARC engine.
+// I DID NOT WRITE THIS FUNCTION, ONLY MODIFIED IT FOR MULTIPLE FONTS
+/// Load the font for the screen text from a font file specified in gamesettings.xml.
+void CRenderer::loadNewFont(string fontTag) {
+	XMLElement* tag = m_pXmlSettings->FirstChildElement(fontTag.c_str());
+
+	if (tag == nullptr)return; //no tag, so bail
+
+	const char* filename = tag->Attribute("file");
+	const size_t newsize = strlen(filename) + 1;
+	wchar_t* wfilename = new wchar_t[newsize]; //wide file name
+	size_t n;
+	mbstowcs_s(&n, wfilename, newsize, filename, _TRUNCATE); //convert file name to wide characters
+
+	unique_ptr<SpriteFont> theFont;
+
+	theFont = make_unique<SpriteFont>(m_pD3DDevice, *m_pResourceUpload,
+		wfilename,
+		m_pDescriptorHeap->GetCpuHandle(m_nNumResourceDesc),
+		m_pDescriptorHeap->GetGpuHandle(m_nNumResourceDesc));
+
+	++m_nNumResourceDesc;
+
+	delete[] wfilename;
+
+	fontsRef[fontTag] = fonts.size();
+	fonts.push_back(move(theFont));
+} //LoadScreenFont
+
+void CRenderer::setFont(string fontTag) {
+	int id = fontsRef[fontTag];
+	// Return the current font
+	fonts[font_id] = move(m_pFont);
+	// Move the new font to be used
+	m_pFont = move(fonts[id]);
+	// Change the font id
+	font_id = id;
+}
\ No newline at end of file
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 24)
+++ Source/Game.cpp	(revision 25)
@@ -25,7 +25,7 @@
 	// Start the initial scene, maybe this should be a main menu?
 	// (We pass a pointer to this object because the scene has a circular
 	// reference for things such as swapping itself with another scene)
-	startScene(new BaseLevelScene(this));
+	startScene(new TitleScreenScene(this));
 } //Initialize
 
 /// Release all of the DirectX12 objects by deleting the renderer.
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(nonexistent)
+++ Source/TitleScreenScene.cpp	(revision 25)
@@ -0,0 +1,51 @@
+#include "TitleScreenScene.h"
+#include "BaseLevelScene.h"
+#include "Game.h"
+
+TitleScreenScene::TitleScreenScene(CGame* game) : Scene(game) {
+	menu.push_back("Play Game");
+	menu.push_back("Exit");
+}
+
+TitleScreenScene::~TitleScreenScene() {}
+
+void TitleScreenScene::create() {
+	printf("TitleScreenScene::create()\n");
+	float x = m_pRenderer->getCenter().x;
+	float y = m_pRenderer->getCenter().y;
+	addObject(new GameObject(this, TITLE_SCREEN, x, y, 0));
+}
+
+void TitleScreenScene::update() {
+	if (m_pKeyboard->TriggerDown(VK_UP))
+		if (selection > 0) selection--;
+	if (m_pKeyboard->TriggerDown(VK_DOWN))
+		if (selection < menu.size() - 1) selection++;
+
+	// Making a selection
+	if (m_pKeyboard->TriggerDown(VK_RETURN)) {
+		if (menu[selection] == "Play Game") {
+			game->startScene(new BaseLevelScene(game));
+		}
+		else if (menu[selection] == "Exit") {
+			exit(0);
+		}
+	}
+}
+
+void TitleScreenScene::render() {
+	Scene::render();
+	m_pRenderer->setFont("title_font");
+	m_pRenderer->DrawScreenText("Spire Panic!", Vector2(710, 80), Colors::OrangeRed);
+	m_pRenderer->setFont("font");
+	for (int i = 0; i < menu.size(); i++) {
+		if (i == selection) {
+			m_pRenderer->setFont("selection_font");
+			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780, 180 + (40 * i)), Colors::DarkOrange);
+			m_pRenderer->setFont("font");
+		}
+		else {
+			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780, 180 + (40 * i)), Colors::Orange);
+		}
+	}
+}
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 24)
+++ Source/Source.vcxproj	(revision 25)
@@ -175,6 +175,7 @@
     <ClCompile Include="Scene.cpp" />
     <ClCompile Include="BaseLevelScene.cpp" />
     <ClCompile Include="TiledScene.cpp" />
+    <ClCompile Include="TitleScreenScene.cpp" />
     <ClCompile Include="Tower.cpp" />
   </ItemGroup>
   <ItemGroup>
@@ -190,6 +191,7 @@
     <ClInclude Include="BaseLevelScene.h" />
     <ClInclude Include="Sndlist.h" />
     <ClInclude Include="TiledScene.h" />
+    <ClInclude Include="TitleScreenScene.h" />
     <ClInclude Include="Tower.h" />
   </ItemGroup>
   <ItemGroup>
Index: Source/Renderer.h
===================================================================
--- Source/Renderer.h	(revision 24)
+++ Source/Renderer.h	(revision 25)
@@ -3,6 +3,7 @@
 
 #pragma once
 
+#include <map>
 #include "GameDefines.h"
 #include "SpriteRenderer.h"
 
@@ -17,4 +18,12 @@
 
 	void DrawBoundingBox(const BoundingBox& aabb);
 	void LoadImages(); ///< Load images.
+	Vector2 getCenter();
+
+	void loadNewFont(string fontTag);
+	void setFont(string fontTag);
+private:
+	vector<unique_ptr<SpriteFont>> fonts;
+	map<string, int> fontsRef;
+	int font_id = 0;
 }; //CRenderer
\ No newline at end of file
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 24)
+++ Source/GameDefines.h	(revision 25)
@@ -11,6 +11,7 @@
 /// Note: NUM_SPRITES must be last.
 enum eSpriteType {
 	BACKGROUND,
+	TITLE_SCREEN,
 	GREENLINE_SPRITE,
 	SIMPLE_TILE,
 	HUMAN_IDLE,
Index: Source/Game.h
===================================================================
--- Source/Game.h	(revision 24)
+++ Source/Game.h	(revision 25)
@@ -6,7 +6,7 @@
 #include "Component.h"
 #include "Common.h"
 #include "Settings.h"
-#include "BaseLevelScene.h"
+#include "TitleScreenScene.h"
 
 /// \brief The game class.
 class CGame :

------------------------------------------------------------------------
r26 | amm0837 | 2020-11-01 20:32:40 -0600 (Sun, 01 Nov 2020) | 1 line

Towers track enemy objects now instead of the PC

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 25)
+++ Source/BaseLevelScene.cpp	(revision 26)
@@ -149,6 +149,10 @@
 	return player;
 }
 
+vector<BadCharacter*> BaseLevelScene::getBaddies() {
+	return baddies;
+}
+
 //returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
 GameObject* BaseLevelScene::getClosestTower() {
 	Vector3 playerPos = player->getPos();
Index: Source/Main.cpp
===================================================================
--- Source/Main.cpp	(revision 25)
+++ Source/Main.cpp	(revision 26)
@@ -6,7 +6,7 @@
 
 #ifdef _DEBUG
 #define USE_DEBUG_CONSOLE ///< Define to use a console window for debug messages.
-#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
+//#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
 #endif
 
 static CWindow g_cWindow; ///< The window class.
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 25)
+++ Source/BaseLevelScene.h	(revision 26)
@@ -20,6 +20,7 @@
 	void camMapVision(); // Set the camera to center on the tilemap
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
+	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
 private:
 	GameObject* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 25)
+++ Source/Tower.cpp	(revision 26)
@@ -16,7 +16,24 @@
 }
 
 GameObject* Tower::calcTarget() {
-	return ((BaseLevelScene*)scene)->getPlayer();
+	//return ((BaseLevelScene*)scene)->getPlayer();
+	Vector3 towerPos;
+	Vector3 enemyPos;
+	GameObject* enemy = NULL;
+	float difX = 1000, difY = 1000, dif = 1000;
+	for (GameObject* obj : ((BaseLevelScene*)scene)->getBaddies()) {
+			enemyPos = obj-> getPos();		//enemy position
+			towerPos = this->getPos();		//tower position
+
+			difX = abs(enemyPos.x - towerPos.x);		//pythagorean to find nearest enemy object
+			difY = abs(enemyPos.y - towerPos.y);
+			if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif) {
+				dif = sqrt(pow(difX, 2) + pow(difY, 2));
+				enemy = obj;
+			}
+		
+	}
+	return enemy;
 }
 
 void Tower::fire(GameObject* p, eSpriteType t) {
@@ -33,7 +50,7 @@
 	b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
 	const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
 													//the direction of bullet velocity
-	b->setVel(p->getVel() + 300.0f * view);
+	b->setVel(p->getVel() + 500.0f * view);
 	b->setRoll(b->m_fRoll);
 
 }

------------------------------------------------------------------------
r27 | jdg0393 | 2020-11-01 21:33:41 -0600 (Sun, 01 Nov 2020) | 1 line

Enemies approach tower and run attack animation.

Index: Source/TiledScene.h
===================================================================
--- Source/TiledScene.h	(revision 26)
+++ Source/TiledScene.h	(revision 27)
@@ -19,6 +19,7 @@
 	virtual ~TiledScene() override;
 	virtual void render() override;
 	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
+	map<string, PathPoint> getPaths() { return paths; }
 protected:
 	// Data about the tilemap
 	int tilemapWidth = 0; // Width of tilemap in tiles
@@ -39,10 +40,3 @@
 	void _loadClsnLayer(std::string filename);
 	void _loadPathLayer(std::string filename);
 };
-
-struct PathPoint {
-	float x = 0;
-	float y = 0;
-	string next = "null";
-	string name = "";
-};
\ No newline at end of file
Index: Source/Character.cpp
===================================================================
--- Source/Character.cpp	(revision 26)
+++ Source/Character.cpp	(revision 27)
@@ -3,12 +3,17 @@
 Character::Character(Scene* scene, eSpriteType spriteKey, float x, float y, float z) :
 	GameObject(scene, spriteKey, x, y, z)
 {}
+Character::~Character() {}
 
 void Character::animate() {
 	// Set the direction the player should be facing
 	_calcDirection();
 	// Set the frame the player should use
-	m_nCurrentFrame = 0 + (direction * 4);
+	if (m_pStepTimer->GetTotalSeconds() > subframe_time) {
+		subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
+		subframe = (subframe + 1) % subframe_count;
+	}
+	m_nCurrentFrame = subframe + (direction * subframe_count);
 }
 
 void Character::move() {
Index: Source/Common.h
===================================================================
--- Source/Common.h	(revision 26)
+++ Source/Common.h	(revision 27)
@@ -22,3 +22,11 @@
 protected:
 	static CRenderer* m_pRenderer; ///< Pointer to the renderer.
 }; //CCommon
+
+// Common structures
+struct PathPoint {
+	float x = 0;
+	float y = 0;
+	string next = "null";
+	string name = "";
+};
\ No newline at end of file
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 26)
+++ Source/GameObject.h	(revision 27)
@@ -15,6 +15,7 @@
 public:
 	// Constructor with default position
 	GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
+	virtual ~GameObject();
 	virtual void update(); // Method runs every tick/update
 
 	void setRoll(float angle);
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 26)
+++ Source/Renderer.cpp	(revision 27)
@@ -34,6 +34,7 @@
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(HUMAN_IDLE, "human_idle");
 	Load(GOBLIN_IDLE, "goblin_idle");
+	Load(GOBLIN_ATTACK, "goblin_attack");
 	Load(BULLET1, "bullet1");
 	Load(SPIRE, "spire");
 	Load(TOWER1, "tower1");
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 26)
+++ Source/BadCharacter.h	(revision 27)
@@ -1,13 +1,27 @@
 #pragma once
+#include <map>
 #include "Character.h"
+
 class BadCharacter :
 	public Character
 {
 public:
+	bool stopped = false;
+	bool attacking = false;
 	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
+	virtual ~BadCharacter() override;
 	virtual void update() override;
+	virtual void animate() override;
 	void setDestination(float x, float y);
+	void setDestinationID(string id);
 protected:
+	float cooldown = .6;
+	float cooldown_time = 0;
+	map<string, PathPoint> paths;
 	Vector2 dest = { 0,0 };
+	string destID = "";
+	float dist = 0; // Distance from the destination
+	void _updateDestination();
+	void _updateVelocity();
 };
 
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 26)
+++ Source/BaseLevelScene.h	(revision 27)
@@ -21,6 +21,7 @@
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
+	GameObject* getSpire() { return spire; }
 private:
 	GameObject* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 26)
+++ Source/GameObject.cpp	(revision 27)
@@ -6,6 +6,7 @@
 	this->m_vPos = Vector3(x, y, z);
 	m_nSpriteIndex = spriteKey;
 }
+GameObject::~GameObject() {}
 
 void GameObject::update() {
 	//printf("GameObject::update()\n");
Index: Source/Character.h
===================================================================
--- Source/Character.h	(revision 26)
+++ Source/Character.h	(revision 27)
@@ -4,7 +4,8 @@
     public GameObject
 {
 public:
-	Character::Character(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
+	Character(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
+	virtual ~Character() override;
 	virtual void animate(); // Animates the character and sets their sprite
 	void move(); // Move the character once based on their velocity
 	void unmove(); // Undo the character's last movement
@@ -14,6 +15,10 @@
 	void _calcDirection();
 	Vector2 oldPos; // Stores the position from the previous frame
 	int direction = 0; // Stores the direction as a number 0-3
+	int subframe = 0; // Stores the frame, relative to the start of the direction
+	float subframe_time = 0.25; // Time when the subframe will next change
+	float subframe_interval = .5; // Time between subframes
+	int subframe_count = 4; // Number of subframes per animation
 	float angle = 0; // Angle of the character in degrees
 	float speed = 0; // Speed of the character regardless of direction
 	Vector2 velocity = { 0,0 }; // Velocity of the character, accounts for direction
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 26)
+++ Source/BadCharacter.cpp	(revision 27)
@@ -1,12 +1,82 @@
 #include "BadCharacter.h"
+#include "BaseLevelScene.h"
 
 BadCharacter::BadCharacter(Scene* scene, float x, float y, float z) :
 	Character(scene, GOBLIN_IDLE, x, y, z)
 {
 	m_sAabb = BoundingBox({ x,y,z }, { 4,4,4 });
+	paths = ((BaseLevelScene*)scene)->getPaths();
 }
+BadCharacter::~BadCharacter() {}
 
 void BadCharacter::update() {
+	// Set the bad guy's destination
+	_updateDestination();
+	// Attack the tower, under the right conditions
+	if (destID == "end" && dist < 15) {
+		Vector2 spire = ((BaseLevelScene*)scene)->getSpire()->getPos();
+		stopped = true;
+		attacking = true;
+		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
+			printf("Enemy attacking tower!\n");
+			cooldown_time = m_pStepTimer->GetTotalSeconds() + cooldown;
+		}
+	}
+	else {
+		stopped = false;
+		attacking = false;
+	}
+	// Move and animate
+	_updateVelocity();
+	if (!stopped) move();
+	animate();
+}
+
+void BadCharacter::animate() {
+	// Determine which sprite to use
+	if (attacking && m_nSpriteIndex != GOBLIN_ATTACK) {
+		m_nSpriteIndex = GOBLIN_ATTACK;
+		subframe = 0;
+		subframe_interval = .15;
+		subframe_time = m_pStepTimer->GetTotalSeconds() + .15;
+	}
+	else if (!attacking) {
+		m_nSpriteIndex = GOBLIN_IDLE;
+		subframe = 0;
+		subframe_interval = .5;
+		subframe_time = m_pStepTimer->GetTotalSeconds() + .5;
+	}
+	// Run the normal animate behavior
+	Character::animate();
+}
+
+void BadCharacter::setDestination(float x, float y) {
+	dest = { x, y };
+}
+
+void BadCharacter::setDestinationID(string id) {
+	destID = id;
+	dest = { paths[id].x, paths[id].y };
+}
+
+void BadCharacter::_updateDestination() {
+	// The the bad guy is within range of his destination
+	if (destID == "end") {
+		GameObject* spire = ((BaseLevelScene*)scene)->getSpire();
+		dest = { spire->getPos().x, spire->getPos().y - 22 };
+	}
+	else if (dist < 3 && paths[destID].next != "null") {
+		destID = paths[destID].next;
+		dest = { paths[destID].x, paths[destID].y };
+	}
+	float dx = m_vPos.x - dest.x;
+	float dy = m_vPos.y - dest.y;
+	float dx2 = dx * dx;
+	float dy2 = dy * dy;
+	dist = sqrt(dx2 + dy2);
+}
+
+void BadCharacter::_updateVelocity() {
 	Vector2 travelVector = m_vPos - dest;
 	// Calculate angle to destination in radians
 	float angle_in_radians = atan2f(travelVector.y, travelVector.x) + MY_PI;
@@ -16,11 +86,4 @@
 	angle = angle_in_radians * (180 / MY_PI);
 	// Calculate the velocity
 	velocity = { 40 * cosf(angle_in_radians), 40 * sinf(angle_in_radians) };
-	// Move and animate
-	move();
-	animate();
-}
-
-void BadCharacter::setDestination(float x, float y) {
-	dest = { x, y };
 }
\ No newline at end of file
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 26)
+++ Source/GameDefines.h	(revision 27)
@@ -16,6 +16,7 @@
 	SIMPLE_TILE,
 	HUMAN_IDLE,
 	GOBLIN_IDLE,
+	GOBLIN_ATTACK,
 	BULLET1,
 	SPIRE,
 	TOWER1,
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 26)
+++ Source/BaseLevelScene.cpp	(revision 27)
@@ -27,15 +27,12 @@
 	spire->m_sAabb = BoundingBox({ spire->getPos().x, spire->getPos().y - 22, spire->getPos().z }, { 16, 7, 4 });
 	// Create some stupid bad guy
 	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths["enSpawn1"].x, paths["enSpawn1"].y, .851)));
+	baddies[0]->setDestinationID("enSpawn1");
 }
 
 void BaseLevelScene::update() {
 	// Handling controls specific to the scene
 	handleKeyboard();
-	// Temporarily make baddies move towards the player
-	for (auto baddie : baddies) {
-		baddie->setDestination(player->getPos().x, player->getPos().y);
-	}
 	// Core scene update, including updating objects
 	Scene::update();
 	// Check for the player colliding with the tilemap

------------------------------------------------------------------------
r28 | jdg0393 | 2020-11-01 22:00:13 -0600 (Sun, 01 Nov 2020) | 1 line

Added a spiffy song to the title screen.

Index: Source/Sndlist.h
===================================================================
--- Source/Sndlist.h	(revision 27)
+++ Source/Sndlist.h	(revision 28)
@@ -11,5 +11,7 @@
 /// The sounds must be listed here in the same order that
 /// they are in the sound settings XML file.
 enum eSoundType {
-	GUN_SOUND, CLANG_SOUND,
+	MENU_SONG,
+	GUN_SOUND,
+	CLANG_SOUND
 }; //eSoundType
\ No newline at end of file
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 27)
+++ Source/TitleScreenScene.cpp	(revision 28)
@@ -7,10 +7,15 @@
 	menu.push_back("Exit");
 }
 
-TitleScreenScene::~TitleScreenScene() {}
+TitleScreenScene::~TitleScreenScene() {
+	m_pAudio->stop();
+}
 
 void TitleScreenScene::create() {
 	printf("TitleScreenScene::create()\n");
+	// Play a song
+	m_pAudio->play(MENU_SONG, .1);
+	// Create the title screen image
 	float x = m_pRenderer->getCenter().x;
 	float y = m_pRenderer->getCenter().y;
 	addObject(new GameObject(this, TITLE_SCREEN, x, y, 0));
@@ -28,7 +33,7 @@
 			game->startScene(new BaseLevelScene(game));
 		}
 		else if (menu[selection] == "Exit") {
-			exit(0);
+			ExitProcess(0);
 		}
 	}
 }

------------------------------------------------------------------------
r29 | jdg0393 | 2020-11-01 22:41:27 -0600 (Sun, 01 Nov 2020) | 1 line

Updating to current changes. Trying to synchronize.

Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(nonexistent)
+++ Source/Spire.cpp	(revision 29)
@@ -0,0 +1,12 @@
+#include "Spire.h"
+#include "Scene.h";
+
+Spire::Spire(Scene* scene, float x, float y, float z) :
+	GameObject(scene, SPIRE, x, y, z) {}
+
+void Spire::update()
+{
+	if (hp <= 0) {
+		scene->deleteObject(this);
+	}
+}
\ No newline at end of file
Index: Source/Main.cpp
===================================================================
--- Source/Main.cpp	(revision 28)
+++ Source/Main.cpp	(revision 29)
@@ -6,7 +6,7 @@
 
 #ifdef _DEBUG
 #define USE_DEBUG_CONSOLE ///< Define to use a console window for debug messages.
-//#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
+#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
 #endif
 
 static CWindow g_cWindow; ///< The window class.
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 28)
+++ Source/BaseLevelScene.h	(revision 29)
@@ -2,6 +2,7 @@
 #include "TiledScene.h"
 #include "PlayerCharacter.h"
 #include "BadCharacter.h"
+#include "Spire.h"
 #include "Tower.h"
 
 // Forward declarations for circular dependency
@@ -21,9 +22,9 @@
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
-	GameObject* getSpire() { return spire; }
+	Spire* getSpire() { return spire; }
 private:
-	GameObject* spire = nullptr; // Reference to spire which must be defended
+	Spire* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character
 	vector<BadCharacter*> baddies;
 	Vector3 defPos; // Default "true size" camera position
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 28)
+++ Source/TitleScreenScene.cpp	(revision 29)
@@ -14,7 +14,7 @@
 void TitleScreenScene::create() {
 	printf("TitleScreenScene::create()\n");
 	// Play a song
-	m_pAudio->play(MENU_SONG, .1);
+	CSoundDesc song = m_pAudio->loop(MENU_SONG);
 	// Create the title screen image
 	float x = m_pRenderer->getCenter().x;
 	float y = m_pRenderer->getCenter().y;
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 28)
+++ Source/BadCharacter.cpp	(revision 29)
@@ -18,7 +18,7 @@
 		stopped = true;
 		attacking = true;
 		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
-			printf("Enemy attacking tower!\n");
+			((BaseLevelScene*)scene)->getSpire()->hp -= 1;
 			cooldown_time = m_pStepTimer->GetTotalSeconds() + cooldown;
 		}
 	}
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 28)
+++ Source/Source.vcxproj	(revision 29)
@@ -174,6 +174,7 @@
     <ClCompile Include="Renderer.cpp" />
     <ClCompile Include="Scene.cpp" />
     <ClCompile Include="BaseLevelScene.cpp" />
+    <ClCompile Include="Spire.cpp" />
     <ClCompile Include="TiledScene.cpp" />
     <ClCompile Include="TitleScreenScene.cpp" />
     <ClCompile Include="Tower.cpp" />
@@ -190,6 +191,7 @@
     <ClInclude Include="Scene.h" />
     <ClInclude Include="BaseLevelScene.h" />
     <ClInclude Include="Sndlist.h" />
+    <ClInclude Include="Spire.h" />
     <ClInclude Include="TiledScene.h" />
     <ClInclude Include="TitleScreenScene.h" />
     <ClInclude Include="Tower.h" />
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 28)
+++ Source/BaseLevelScene.cpp	(revision 29)
@@ -8,9 +8,13 @@
 	Vector3 pos = m_pRenderer->GetCameraPos();
 }
 
-BaseLevelScene::~BaseLevelScene() { }
+BaseLevelScene::~BaseLevelScene() {
+	m_pAudio->stop();
+}
 
 void BaseLevelScene::create() {
+	// Play some music
+	m_pAudio->loop(MAP_SONG);
 	// Call parent create() method to create background
 	Scene::create();
 	// Track the original camera position for easy scaling
@@ -23,7 +27,7 @@
 	// Set the camera to follow the player
 	camFollowVision(player);
 	// Create the spire object
-	spire = addObject(new GameObject(this, SPIRE, paths["end"].x, paths["end"].y, .849));
+	spire = (Spire*)addObject(new Spire(this, paths["end"].x, paths["end"].y, .849));
 	spire->m_sAabb = BoundingBox({ spire->getPos().x, spire->getPos().y - 22, spire->getPos().z }, { 16, 7, 4 });
 	// Create some stupid bad guy
 	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths["enSpawn1"].x, paths["enSpawn1"].y, .851)));
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 28)
+++ Source/Source.vcxproj.filters	(revision 29)
@@ -32,6 +32,9 @@
     <ClCompile Include="TitleScreenScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
+    <ClCompile Include="Spire.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -66,6 +69,9 @@
     <ClInclude Include="TitleScreenScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
+    <ClInclude Include="Spire.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Sndlist.h
===================================================================
--- Source/Sndlist.h	(revision 28)
+++ Source/Sndlist.h	(revision 29)
@@ -12,6 +12,7 @@
 /// they are in the sound settings XML file.
 enum eSoundType {
 	MENU_SONG,
+	MAP_SONG,
 	GUN_SOUND,
 	CLANG_SOUND
 }; //eSoundType
\ No newline at end of file
Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(nonexistent)
+++ Source/Spire.h	(revision 29)
@@ -0,0 +1,12 @@
+#pragma once
+#include "GameObject.h"
+
+class Spire :
+    public GameObject
+{
+public:
+    int hp = 1000;
+    Spire(Scene* scene, float x, float y, float z);
+    void update() override;
+};
+

------------------------------------------------------------------------
r30 | amm0837 | 2020-11-01 22:58:12 -0600 (Sun, 01 Nov 2020) | 1 line

hi

Index: Source/Main.cpp
===================================================================
--- Source/Main.cpp	(revision 29)
+++ Source/Main.cpp	(revision 30)
@@ -6,7 +6,7 @@
 
 #ifdef _DEBUG
 #define USE_DEBUG_CONSOLE ///< Define to use a console window for debug messages.
-#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
+//#include <vld.h> //Visual Leak Detector from http://vld.codeplex.com/
 #endif
 
 static CWindow g_cWindow; ///< The window class.
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 29)
+++ Source/GameObject.cpp	(revision 30)
@@ -6,7 +6,6 @@
 	this->m_vPos = Vector3(x, y, z);
 	m_nSpriteIndex = spriteKey;
 }
-GameObject::~GameObject() {}
 
 void GameObject::update() {
 	//printf("GameObject::update()\n");
@@ -15,7 +14,14 @@
 	m_vPos.y += m_vVelocity.y * t;
 }
 
+void GameObject::kill() {
+	isDead = true;
+}
+bool GameObject::dead() {
+	return isDead;
+}
 
+
 void GameObject::setRoll(float angle) {
 	m_fRoll = angle;
 }
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 29)
+++ Source/Tower.cpp	(revision 30)
@@ -6,6 +6,9 @@
 {
 	objScene = scene;
 	setRoll(XM_2PI);
+	m_sAabb = BoundingBox({ x,y-17,z }, { 12,8,4 });
+	
+	
 }
 void Tower::update() {
 	//printf("update function for tower \n");
@@ -13,6 +16,8 @@
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
 		fire(this, BULLET1);
 	}
+	
+
 }
 
 GameObject* Tower::calcTarget() {
@@ -41,6 +46,7 @@
 	Vector3 pos = p->getPos();
 
 	GameObject* b = objScene->addObject(new GameObject(objScene, t, pos.x, pos.y, pos.z));
+	b->m_sAabb = BoundingBox({ pos.x,pos.y,pos.z }, { 3,3,3 });
 
 	//find target for tower
 	target = calcTarget();
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 29)
+++ Source/BaseLevelScene.cpp	(revision 30)
@@ -31,12 +31,15 @@
 	spire->m_sAabb = BoundingBox({ spire->getPos().x, spire->getPos().y - 22, spire->getPos().z }, { 16, 7, 4 });
 	// Create some stupid bad guy
 	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths["enSpawn1"].x, paths["enSpawn1"].y, .851)));
-	baddies[0]->setDestinationID("enSpawn1");
 }
 
 void BaseLevelScene::update() {
 	// Handling controls specific to the scene
 	handleKeyboard();
+	// Temporarily make baddies move towards the player
+	for (auto baddie : baddies) {
+		baddie->setDestination(player->getPos().x, player->getPos().y);
+	}
 	// Core scene update, including updating objects
 	Scene::update();
 	// Check for the player colliding with the tilemap
@@ -52,6 +55,11 @@
 	if (drawMapClsn) {
 		m_pRenderer->DrawBoundingBox(spire->m_sAabb);
 		m_pRenderer->DrawBoundingBox(player->m_sAabb);
+		for (auto obj : objectList) {
+			if (obj->getSpriteType() == TOWER1) {
+				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
+			}
+		}
 	}
 }
 
@@ -141,10 +149,47 @@
 	// Check if the play is colliding with the spire
 	if (player->m_sAabb.Intersects(spire->m_sAabb)) hit = true;
 	// If the player is colliding, move them back
+	//check if player collides with a tower
+	for (auto obj : objectList) {
+		if (obj->getSpriteType() == TOWER1) {
+			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
+		}
+	}
+	//check if 
+	for (auto obj : objectList) {
+		if (obj->getSpriteType() == TOWER1) {
+			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
+		}
+	}
 	if (hit)
 		player->unmove();
 }
+	//creates all possible pairs of objects to pass to narrow phase
+void BaseLevelScene::BroadPhaseClsn() {
+	for (auto i : objectList) {
+		for (auto j : objectList) {
+			NarrowPhaseClsn(i, j);
+		}
+	}
+}
+	//checks if 2 objects collide given their sprite type, we can add many more
+	//possibilities of 2 objects colliding
+void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
+	if (obj1->m_sAabb.Intersects(obj2->m_sAabb)) {
+		if (obj1->getSpriteType() == BULLET1 && obj2->getSpriteType() == GOBLIN_IDLE) {
+			obj2->kill();
+		}
+	}
+}
 
+void BaseLevelScene::CullDead() {
+	for (auto i : objectList) {
+		if (i->dead()) {
+			deleteObject(i);
+		}
+	}
+}
+
 // Provides the player character pointer
 PlayerCharacter* BaseLevelScene::getPlayer() {
 	return player;
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 29)
+++ Source/GameObject.h	(revision 30)
@@ -15,7 +15,7 @@
 public:
 	// Constructor with default position
 	GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
-	virtual ~GameObject();
+	virtual ~GameObject() {}
 	virtual void update(); // Method runs every tick/update
 
 	void setRoll(float angle);
@@ -26,11 +26,14 @@
 	const Vector3& getPos();
 
 	Vector2 getViewVect();
+	bool dead(); //true if dead, false otherwise
+	void kill(); // set isdead flag to true;
 
 
 protected:
 	Scene* scene; // Scene which manages this object
 	Vector2 m_vVelocity = Vector2::Zero;
+	bool isDead = false;
 
 };
 

------------------------------------------------------------------------
r31 | amm0837 | 2020-11-01 22:59:02 -0600 (Sun, 01 Nov 2020) | 1 line



Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 30)
+++ Source/BaseLevelScene.h	(revision 31)
@@ -22,7 +22,13 @@
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
+
+	void BroadPhaseClsn();
+	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
+	void CullDead(); //finds objects with isDead = true, remove from objlist and deallocate pointer
+
 	Spire* getSpire() { return spire; }
+
 private:
 	Spire* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character

------------------------------------------------------------------------
r32 | jdg0393 | 2020-11-01 23:27:15 -0600 (Sun, 01 Nov 2020) | 1 line

Everything re-synced and working.

Index: Source/Spire.cpp (deleted)
===================================================================
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(nonexistent)
+++ Source/Spire.cpp	(revision 32)
@@ -0,0 +1,12 @@
+#include "Spire.h"
+#include "Scene.h";
+
+Spire::Spire(Scene* scene, float x, float y, float z) :
+	GameObject(scene, SPIRE, x, y, z) {}
+
+void Spire::update()
+{
+	if (hp <= 0) {
+		scene->deleteObject(this);
+	}
+}
\ No newline at end of file
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 31)
+++ Source/TitleScreenScene.cpp	(revision 32)
@@ -14,7 +14,7 @@
 void TitleScreenScene::create() {
 	printf("TitleScreenScene::create()\n");
 	// Play a song
-	CSoundDesc song = m_pAudio->loop(MENU_SONG);
+	m_pAudio->play(MENU_SONG, .1);
 	// Create the title screen image
 	float x = m_pRenderer->getCenter().x;
 	float y = m_pRenderer->getCenter().y;
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 31)
+++ Source/GameObject.cpp	(revision 32)
@@ -6,6 +6,7 @@
 	this->m_vPos = Vector3(x, y, z);
 	m_nSpriteIndex = spriteKey;
 }
+GameObject::~GameObject() {}
 
 void GameObject::update() {
 	//printf("GameObject::update()\n");
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 31)
+++ Source/Tower.cpp	(revision 32)
@@ -16,8 +16,6 @@
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
 		fire(this, BULLET1);
 	}
-	
-
 }
 
 GameObject* Tower::calcTarget() {
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 31)
+++ Source/BadCharacter.cpp	(revision 32)
@@ -18,7 +18,7 @@
 		stopped = true;
 		attacking = true;
 		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
-			((BaseLevelScene*)scene)->getSpire()->hp -= 1;
+			printf("Enemy attacking tower!\n");
 			cooldown_time = m_pStepTimer->GetTotalSeconds() + cooldown;
 		}
 	}
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 31)
+++ Source/BaseLevelScene.cpp	(revision 32)
@@ -31,15 +31,12 @@
 	spire->m_sAabb = BoundingBox({ spire->getPos().x, spire->getPos().y - 22, spire->getPos().z }, { 16, 7, 4 });
 	// Create some stupid bad guy
 	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths["enSpawn1"].x, paths["enSpawn1"].y, .851)));
+	baddies[0]->setDestinationID("enSpawn1");
 }
 
 void BaseLevelScene::update() {
 	// Handling controls specific to the scene
 	handleKeyboard();
-	// Temporarily make baddies move towards the player
-	for (auto baddie : baddies) {
-		baddie->setDestination(player->getPos().x, player->getPos().y);
-	}
 	// Core scene update, including updating objects
 	Scene::update();
 	// Check for the player colliding with the tilemap
Index: Source/Spire.h (deleted)
===================================================================
Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(nonexistent)
+++ Source/Spire.h	(revision 32)
@@ -0,0 +1,12 @@
+#pragma once
+#include "GameObject.h"
+
+class Spire :
+    public GameObject
+{
+public:
+    int hp = 1000;
+    Spire(Scene* scene, float x, float y, float z);
+    void update() override;
+};
+
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 31)
+++ Source/GameObject.h	(revision 32)
@@ -15,7 +15,7 @@
 public:
 	// Constructor with default position
 	GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
-	virtual ~GameObject() {}
+	virtual ~GameObject();
 	virtual void update(); // Method runs every tick/update
 
 	void setRoll(float angle);

------------------------------------------------------------------------
r33 | amm0837 | 2020-11-02 01:56:27 -0600 (Mon, 02 Nov 2020) | 1 line

Bullet collisions are working. A goblin's collision with a bullet deletes the goblin

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 32)
+++ Source/BaseLevelScene.cpp	(revision 33)
@@ -41,6 +41,8 @@
 	Scene::update();
 	// Check for the player colliding with the tilemap
 	checkPlyClsn();
+	BroadPhaseClsn();
+	CullDead();
 	// Update the camera position if we're following the player
 	if (followTarget)
 		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
@@ -56,6 +58,9 @@
 			if (obj->getSpriteType() == TOWER1) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
 			}
+			if (obj->getSpriteType() == BULLET1) {
+				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
+			}
 		}
 	}
 }
@@ -152,12 +157,6 @@
 			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
 		}
 	}
-	//check if 
-	for (auto obj : objectList) {
-		if (obj->getSpriteType() == TOWER1) {
-			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
-		}
-	}
 	if (hit)
 		player->unmove();
 }
@@ -175,14 +174,20 @@
 	if (obj1->m_sAabb.Intersects(obj2->m_sAabb)) {
 		if (obj1->getSpriteType() == BULLET1 && obj2->getSpriteType() == GOBLIN_IDLE) {
 			obj2->kill();
+			obj1->kill();
 		}
 	}
 }
 
 void BaseLevelScene::CullDead() {
-	for (auto i : objectList) {
-		if (i->dead()) {
-			deleteObject(i);
+	int sz = objectList.size();
+	for (int i = 0; i < sz; i++) {
+		if (objectList[i]->dead()) {
+			printf("deleting object: %d", objectList[i]->getSpriteType());
+
+			deleteObject(objectList[i]);
+
+			sz = objectList.size();
 		}
 	}
 }
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 32)
+++ Source/GameObject.cpp	(revision 33)
@@ -12,7 +12,10 @@
 	//printf("GameObject::update()\n");
 	const float t = m_pStepTimer->GetElapsedSeconds();
 	m_vPos.x += m_vVelocity.x * t;
-	m_vPos.y += m_vVelocity.y * t;
+	m_vPos.y += m_vVelocity.y * t;	//update object position
+
+	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
+	m_sAabb.Center.y = m_vPos.y;
 }
 
 void GameObject::kill() {
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 32)
+++ Source/Tower.cpp	(revision 33)
@@ -40,22 +40,24 @@
 }
 
 void Tower::fire(GameObject* p, eSpriteType t) {
-	m_pAudio->play(GUN_SOUND);
+	
 	Vector3 pos = p->getPos();
-
-	GameObject* b = objScene->addObject(new GameObject(objScene, t, pos.x, pos.y, pos.z));
-	b->m_sAabb = BoundingBox({ pos.x,pos.y,pos.z }, { 3,3,3 });
-
 	//find target for tower
 	target = calcTarget();
+	if (target != NULL) {
+		m_pAudio->play(GUN_SOUND);
+		//creating bullet and setting its bounding box
+		GameObject* b = objScene->addObject(new GameObject(objScene, t, pos.x, pos.y, pos.z));
+		b->m_sAabb = BoundingBox({ pos.x,pos.y,pos.z }, { 5,5,5 });
 
-	//set bullet direction to enemy direction
-	const Vector3 dir = b->getPos() - target->getPos();
-	b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
-	const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
-													//the direction of bullet velocity
-	b->setVel(p->getVel() + 500.0f * view);
-	b->setRoll(b->m_fRoll);
+		//set bullet direction to enemy direction
+		const Vector3 dir = b->getPos() - target->getPos();
+		b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
+		const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
+														//the direction of bullet velocity
+		b->setVel(p->getVel() + 500.0f * view);
+		b->setRoll(b->m_fRoll);
+	}
 
 }
 void Tower::setRoll(float angle) {

------------------------------------------------------------------------
r34 | jdg0393 | 2020-11-02 05:03:34 -0600 (Mon, 02 Nov 2020) | 1 line

Goblins come out at increasing fast intervals and can break the spire.

Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 33)
+++ Source/TitleScreenScene.cpp	(revision 34)
@@ -1,6 +1,7 @@
 #include "TitleScreenScene.h"
 #include "BaseLevelScene.h"
 #include "Game.h"
+#include "Abort.h"
 
 TitleScreenScene::TitleScreenScene(CGame* game) : Scene(game) {
 	menu.push_back("Play Game");
@@ -7,14 +8,12 @@
 	menu.push_back("Exit");
 }
 
-TitleScreenScene::~TitleScreenScene() {
-	m_pAudio->stop();
-}
+TitleScreenScene::~TitleScreenScene() {}
 
 void TitleScreenScene::create() {
 	printf("TitleScreenScene::create()\n");
 	// Play a song
-	m_pAudio->play(MENU_SONG, .1);
+	m_pAudio->loop(MENU_SONG);
 	// Create the title screen image
 	float x = m_pRenderer->getCenter().x;
 	float y = m_pRenderer->getCenter().y;
@@ -30,10 +29,14 @@
 	// Making a selection
 	if (m_pKeyboard->TriggerDown(VK_RETURN)) {
 		if (menu[selection] == "Play Game") {
+			m_pAudio->stop();
 			game->startScene(new BaseLevelScene(game));
 		}
 		else if (menu[selection] == "Exit") {
-			ExitProcess(0);
+			// If the player exits using this button it WILL show memory leaks
+			// It does not run all destructors when doing using exit, abort, etc
+			game->Release();
+			exit(0);
 		}
 	}
 }
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 33)
+++ Source/BadCharacter.cpp	(revision 34)
@@ -18,7 +18,7 @@
 		stopped = true;
 		attacking = true;
 		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
-			printf("Enemy attacking tower!\n");
+			((BaseLevelScene*)scene)->getSpire()->hp -= 200;
 			cooldown_time = m_pStepTimer->GetTotalSeconds() + cooldown;
 		}
 	}
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 33)
+++ Source/BaseLevelScene.cpp	(revision 34)
@@ -1,16 +1,11 @@
 #include "BaseLevelScene.h"
 #include "Game.h"
+#include "Random.h"
 
 BaseLevelScene::BaseLevelScene(CGame* game) :
-	TiledScene(game)
-{
-	// Get the default camera position
-	Vector3 pos = m_pRenderer->GetCameraPos();
-}
+	TiledScene(game) {}
 
-BaseLevelScene::~BaseLevelScene() {
-	m_pAudio->stop();
-}
+BaseLevelScene::~BaseLevelScene() {}
 
 void BaseLevelScene::create() {
 	// Play some music
@@ -29,9 +24,6 @@
 	// Create the spire object
 	spire = (Spire*)addObject(new Spire(this, paths["end"].x, paths["end"].y, .849));
 	spire->m_sAabb = BoundingBox({ spire->getPos().x, spire->getPos().y - 22, spire->getPos().z }, { 16, 7, 4 });
-	// Create some stupid bad guy
-	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths["enSpawn1"].x, paths["enSpawn1"].y, .851)));
-	baddies[0]->setDestinationID("enSpawn1");
 }
 
 void BaseLevelScene::update() {
@@ -46,6 +38,18 @@
 	// Update the camera position if we're following the player
 	if (followTarget)
 		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
+	// Check end of game conditions
+	if (gameOver && m_pStepTimer->GetTotalSeconds() > endTime) {
+		m_pAudio->stop();
+		m_pRenderer->SetCameraPos(defPos);
+		game->startScene(new TitleScreenScene(game));
+	}
+	// Maybe spawn some new enemies?
+	if (!gameOver && m_pStepTimer->GetTotalSeconds() > spawnTime) {
+		spawnBaddie();
+		spawnTime = m_pStepTimer->GetTotalSeconds() + spawnRate;
+		spawnRate *= .9;
+	}
 }
 
 void BaseLevelScene::render() {
@@ -63,6 +67,18 @@
 			}
 		}
 	}
+	if (!gameOver) {
+		string hpString = "Spire Hit Points: " + to_string(spire->hp) + "/1000";
+		m_pRenderer->DrawScreenText(hpString.c_str(), { 920, 10 }, Colors::White);
+	}
+	else {
+		m_pRenderer->setFont("title_font");
+		m_pRenderer->DrawCenteredText("Game Over", Colors::IndianRed);
+		m_pRenderer->setFont("font");
+		string timeLeft = to_string(int(endTime - m_pStepTimer->GetTotalSeconds()));
+		float x = 640.0 - timeLeft.size() * 8.0;
+		m_pRenderer->DrawScreenText(timeLeft.c_str(), { x, 420 }, Colors::IndianRed);
+	}
 }
 
 void BaseLevelScene::camFollowVision(GameObject* target) {
@@ -160,7 +176,7 @@
 	if (hit)
 		player->unmove();
 }
-	//creates all possible pairs of objects to pass to narrow phase
+//creates all possible pairs of objects to pass to narrow phase
 void BaseLevelScene::BroadPhaseClsn() {
 	for (auto i : objectList) {
 		for (auto j : objectList) {
@@ -168,8 +184,8 @@
 		}
 	}
 }
-	//checks if 2 objects collide given their sprite type, we can add many more
-	//possibilities of 2 objects colliding
+//checks if 2 objects collide given their sprite type, we can add many more
+//possibilities of 2 objects colliding
 void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
 	if (obj1->m_sAabb.Intersects(obj2->m_sAabb)) {
 		if (obj1->getSpriteType() == BULLET1 && obj2->getSpriteType() == GOBLIN_IDLE) {
@@ -220,4 +236,18 @@
 	}
 	return tow;
 
+}
+
+void BaseLevelScene::endGame() {
+	if (!gameOver) {
+		gameOver = true;
+		endTime = m_pStepTimer->GetTotalSeconds() + 15;
+	}
+}
+
+void BaseLevelScene::spawnBaddie() {
+	// Create some stupid bad guy
+	string sp = m_pRandom->randn(0, 1) ? "enSpawn1" : "enSpawn2";
+	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, .851)));
+	baddies[baddies.size() - 1]->setDestinationID(sp);
 }
\ No newline at end of file
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 33)
+++ Source/Spire.cpp	(revision 34)
@@ -1,5 +1,6 @@
 #include "Spire.h"
 #include "Scene.h";
+#include "BaseLevelScene.h"
 
 Spire::Spire(Scene* scene, float x, float y, float z) :
 	GameObject(scene, SPIRE, x, y, z) {}
@@ -7,6 +8,7 @@
 void Spire::update()
 {
 	if (hp <= 0) {
-		scene->deleteObject(this);
+		m_fAlpha = 0;
+		((BaseLevelScene*)scene)->endGame();
 	}
 }
\ No newline at end of file
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 33)
+++ Source/Game.cpp	(revision 34)
@@ -9,7 +9,6 @@
 
 CGame::~CGame() {
 	if (activeScene) {
-		printf("Deleting active scene!\n");
 		delete activeScene;
 	}
 } //destructor
@@ -64,6 +63,7 @@
 	m_pRenderer->BeginFrame();
 
 	if (activeScene) activeScene->render();
+	else printf("No scene :(\n");
 
 	if (displayFramerate) {
 		string s = to_string(m_pStepTimer->GetFramesPerSecond()) + " fps";
Index: Source/Main.cpp
===================================================================
--- Source/Main.cpp	(revision 33)
+++ Source/Main.cpp	(revision 34)
@@ -12,6 +12,7 @@
 static CWindow g_cWindow; ///< The window class.
 static CGame g_cGame; ///< The game class.
 
+
 /// \brief The main entry point for this application.  
 ///
 /// The main entry point for this application. 
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 33)
+++ Source/BaseLevelScene.h	(revision 34)
@@ -19,17 +19,26 @@
 	virtual void render() override;
 	void camFollowVision(GameObject* target); // Set the camera to follow a target
 	void camMapVision(); // Set the camera to center on the tilemap
+
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
+	Spire* getSpire() { return spire; }
 
+	void setSpire(Spire* sp) { spire = sp; }
+
 	void BroadPhaseClsn();
 	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
 	void CullDead(); //finds objects with isDead = true, remove from objlist and deallocate pointer
 
-	Spire* getSpire() { return spire; }
+	void endGame();
+	void spawnBaddie();
 
 private:
+	bool gameOver = false;
+	float endTime = 0;
+	float spawnTime = 10;
+	float spawnRate = 10;
 	Spire* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character
 	vector<BadCharacter*> baddies;

------------------------------------------------------------------------
r35 | jdg0393 | 2020-11-02 14:14:53 -0600 (Mon, 02 Nov 2020) | 1 line

Fixed tower continuous shooting bug in Release mode.

Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 34)
+++ Source/Tower.cpp	(revision 35)
@@ -22,7 +22,7 @@
 	//return ((BaseLevelScene*)scene)->getPlayer();
 	Vector3 towerPos;
 	Vector3 enemyPos;
-	GameObject* enemy = NULL;
+	GameObject* enemy = nullptr;
 	float difX = 1000, difY = 1000, dif = 1000;
 	for (GameObject* obj : ((BaseLevelScene*)scene)->getBaddies()) {
 			enemyPos = obj-> getPos();		//enemy position
@@ -44,7 +44,7 @@
 	Vector3 pos = p->getPos();
 	//find target for tower
 	target = calcTarget();
-	if (target != NULL) {
+	if (target != nullptr) {
 		m_pAudio->play(GUN_SOUND);
 		//creating bullet and setting its bounding box
 		GameObject* b = objScene->addObject(new GameObject(objScene, t, pos.x, pos.y, pos.z));
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 34)
+++ Source/GameObject.cpp	(revision 35)
@@ -48,4 +48,8 @@
 }
 int GameObject::getSpriteType() {
 	return m_nSpriteIndex;
+}
+
+bool GameObject::is(string tag) {
+	return tags.find(tag) != tags.end();
 }
\ No newline at end of file
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 34)
+++ Source/BadCharacter.cpp	(revision 35)
@@ -6,6 +6,8 @@
 {
 	m_sAabb = BoundingBox({ x,y,z }, { 4,4,4 });
 	paths = ((BaseLevelScene*)scene)->getPaths();
+	// Descriptor tags
+	tags.insert("baddie");
 }
 BadCharacter::~BadCharacter() {}
 
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 34)
+++ Source/BaseLevelScene.cpp	(revision 35)
@@ -199,10 +199,18 @@
 	int sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
 		if (objectList[i]->dead()) {
-			printf("deleting object: %d", objectList[i]->getSpriteType());
-
+			printf("deleting object: %d\n", objectList[i]->getSpriteType());
+			// If object is a baddie, remove it from the baddies list
+			if (objectList[i]->is("baddie")) {
+				for(int j = 0; j < baddies.size(); j++)
+					if (objectList[i] == baddies[j]) {
+						baddies.erase(baddies.begin() + j);
+						break;
+					}
+			}
+			// This deletes the object and removes it's reference from objectList
 			deleteObject(objectList[i]);
-
+			// Adjust size since vector resized during processing
 			sz = objectList.size();
 		}
 	}
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 34)
+++ Source/GameObject.h	(revision 35)
@@ -1,10 +1,10 @@
 #pragma once
+#include <unordered_set>
 #include "Component.h"
 #include "GameDefines.h"
 #include "SpriteDesc.h"
 #include "Common.h"
 #include "StepTimer.h"
-//#include "SimpleMapScene.h"
 
 // Forward declarations of classes that will exist
 // (We can't just include it b/c of circular dependency
@@ -29,11 +29,11 @@
 	bool dead(); //true if dead, false otherwise
 	void kill(); // set isdead flag to true;
 
-
+	bool is(string tag); // Checks if the game object has a certain descriptor tag
 protected:
 	Scene* scene; // Scene which manages this object
 	Vector2 m_vVelocity = Vector2::Zero;
 	bool isDead = false;
-
+	unordered_set<string> tags;
 };
 

------------------------------------------------------------------------
r36 | amm0837 | 2020-11-02 14:40:42 -0600 (Mon, 02 Nov 2020) | 1 line

collision detection between bullets and walls

Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 35)
+++ Source/Tower.cpp	(revision 36)
@@ -6,9 +6,9 @@
 {
 	objScene = scene;
 	setRoll(XM_2PI);
-	m_sAabb = BoundingBox({ x,y-17,z }, { 12,8,4 });
-	
-	
+	m_sAabb = BoundingBox({ x,y - 17,z }, { 12,8,4 });
+
+
 }
 void Tower::update() {
 	//printf("update function for tower \n");
@@ -22,20 +22,26 @@
 	//return ((BaseLevelScene*)scene)->getPlayer();
 	Vector3 towerPos;
 	Vector3 enemyPos;
+
 	GameObject* enemy = nullptr;
+
 	float difX = 1000, difY = 1000, dif = 1000;
 	for (GameObject* obj : ((BaseLevelScene*)scene)->getBaddies()) {
-			enemyPos = obj-> getPos();		//enemy position
-			towerPos = this->getPos();		//tower position
+		enemyPos = obj->getPos();		//enemy position
+		towerPos = this->getPos();		//tower position
 
-			difX = abs(enemyPos.x - towerPos.x);		//pythagorean to find nearest enemy object
-			difY = abs(enemyPos.y - towerPos.y);
-			if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif) {
-				dif = sqrt(pow(difX, 2) + pow(difY, 2));
-				enemy = obj;
-			}
-		
+		difX = abs(enemyPos.x - towerPos.x);		//pythagorean to find nearest enemy object
+		difY = abs(enemyPos.y - towerPos.y);
+		if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif) {
+			dif = sqrt(pow(difX, 2) + pow(difY, 2));
+			enemy = obj;
+		}
+
 	}
+	if (((BaseLevelScene*)scene)->getBaddies().size() == 0){
+		return nullptr;
+	}
+	else
 	return enemy;
 }
 
@@ -55,7 +61,7 @@
 		b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
 		const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
 														//the direction of bullet velocity
-		b->setVel(p->getVel() + 500.0f * view);
+		b->setVel(p->getVel() + 100.0f * view);
 		b->setRoll(b->m_fRoll);
 	}
 
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 35)
+++ Source/BaseLevelScene.h	(revision 36)
@@ -29,6 +29,7 @@
 
 	void BroadPhaseClsn();
 	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
+	void WallCollision();
 	void CullDead(); //finds objects with isDead = true, remove from objlist and deallocate pointer
 
 	void endGame();
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 35)
+++ Source/BaseLevelScene.cpp	(revision 36)
@@ -183,6 +183,14 @@
 			NarrowPhaseClsn(i, j);
 		}
 	}
+	for (auto i : clsnBoxes) {
+		for (auto j : objectList) {
+			if (j->getSpriteType() == BULLET1) {
+				if (j->m_sAabb.Intersects(i))
+					j->kill();
+			}
+		}
+	}
 }
 //checks if 2 objects collide given their sprite type, we can add many more
 //possibilities of 2 objects colliding

------------------------------------------------------------------------
r37 | jdg0393 | 2020-11-02 15:27:01 -0600 (Mon, 02 Nov 2020) | 1 line

First sort of playable version.

Index: Source/Bullet.h
===================================================================
--- Source/Bullet.h	(nonexistent)
+++ Source/Bullet.h	(revision 37)
@@ -0,0 +1,9 @@
+#pragma once
+#include "GameObject.h"
+class Bullet :
+    public GameObject
+{
+public:
+    Bullet(Scene* scene, float x = 0, float y = 0, float z = 0);
+};
+
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 36)
+++ Source/Tower.cpp	(revision 37)
@@ -1,4 +1,5 @@
 #include "Tower.h"
+#include "Bullet.h"
 
 
 Tower::Tower(Scene* scene, float x = 0, float y = 0, float z = 0) :
@@ -14,12 +15,11 @@
 	//printf("update function for tower \n");
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
-		fire(this, BULLET1);
+		fire(this);
 	}
 }
 
 GameObject* Tower::calcTarget() {
-	//return ((BaseLevelScene*)scene)->getPlayer();
 	Vector3 towerPos;
 	Vector3 enemyPos;
 
@@ -45,7 +45,7 @@
 	return enemy;
 }
 
-void Tower::fire(GameObject* p, eSpriteType t) {
+void Tower::fire(GameObject* p) {
 	
 	Vector3 pos = p->getPos();
 	//find target for tower
@@ -53,8 +53,7 @@
 	if (target != nullptr) {
 		m_pAudio->play(GUN_SOUND);
 		//creating bullet and setting its bounding box
-		GameObject* b = objScene->addObject(new GameObject(objScene, t, pos.x, pos.y, pos.z));
-		b->m_sAabb = BoundingBox({ pos.x,pos.y,pos.z }, { 5,5,5 });
+		GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z));
 
 		//set bullet direction to enemy direction
 		const Vector3 dir = b->getPos() - target->getPos();
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 36)
+++ Source/PlayerCharacter.cpp	(revision 37)
@@ -1,5 +1,7 @@
 #include "PlayerCharacter.h"
 #include "StepTimer.h"
+#include "Bullet.h"
+#include "Scene.h"
 
 PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z) :
 	Character(scene, HUMAN_IDLE, x, y, z)
@@ -12,3 +14,21 @@
 	move();
 	animate();
 }
+
+void PlayerCharacter::shoot(float speed, float angle_in_degrees) {
+	if (m_pStepTimer->GetTotalSeconds() > shootTime) {
+		// Convert the angle to radians for mathematics
+		float angle_in_radians = angle_in_degrees * (MY_PI / 180);
+		// Calculate the x component of the velocity
+		float xSpeed = speed * cos(angle_in_radians);
+		// Calculate the y component of the velocity
+		float ySpeed = speed * sin(angle_in_radians);
+		// Set the player's velocity
+		Vector2 bulletVel = { xSpeed, ySpeed };
+		// Create the bullet object
+		Bullet* b = (Bullet*)scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .00001));
+		b->setVel(bulletVel);
+		// Update the next time I can shoot
+		shootTime = m_pStepTimer->GetTotalSeconds() + shootCooldown;
+	}
+}
\ No newline at end of file
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 36)
+++ Source/BaseLevelScene.h	(revision 37)
@@ -48,6 +48,7 @@
 	bool shouldFollow = false; // Whether the camera is following
 	void handleKeyboard(); // Handler for the keyboard
 	void _handleMoveKeys(); // Internal function used by keyboard handler
+	void _handleShootKeys(); // Internal function used by keyboard handler
 	void checkPlyClsn();
 };
 
Index: Source/Bullet.cpp
===================================================================
--- Source/Bullet.cpp	(nonexistent)
+++ Source/Bullet.cpp	(revision 37)
@@ -0,0 +1,8 @@
+#include "Bullet.h"
+
+Bullet::Bullet(Scene* scene, float x, float y, float z) :
+	GameObject(scene, BULLET1, x, y, z)
+{
+	tags.insert("projectile");
+	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
+}
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 36)
+++ Source/BadCharacter.cpp	(revision 37)
@@ -20,7 +20,7 @@
 		stopped = true;
 		attacking = true;
 		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
-			((BaseLevelScene*)scene)->getSpire()->hp -= 200;
+			((BaseLevelScene*)scene)->getSpire()->hp -= 20;
 			cooldown_time = m_pStepTimer->GetTotalSeconds() + cooldown;
 		}
 	}
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 36)
+++ Source/Tower.h	(revision 37)
@@ -9,7 +9,7 @@
 	Tower(Scene* scene, float x, float y, float z);
 	void update() override;
 	GameObject* calcTarget();
-	void fire(GameObject* p, eSpriteType t);
+	void fire(GameObject* p);
 	void setRoll(float angle);
 
 private:
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 36)
+++ Source/Source.vcxproj	(revision 37)
@@ -165,6 +165,7 @@
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="BadCharacter.cpp" />
+    <ClCompile Include="Bullet.cpp" />
     <ClCompile Include="Character.cpp" />
     <ClCompile Include="Common.cpp" />
     <ClCompile Include="Game.cpp" />
@@ -181,6 +182,7 @@
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="BadCharacter.h" />
+    <ClInclude Include="Bullet.h" />
     <ClInclude Include="Character.h" />
     <ClInclude Include="Common.h" />
     <ClInclude Include="Game.h" />
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 36)
+++ Source/PlayerCharacter.h	(revision 37)
@@ -9,4 +9,8 @@
 public:
 	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
 	void update() override; // Character's update loop, runs every frame
+	void shoot(float speed, float angle_in_degrees);
+private:
+	float shootCooldown = 2;
+	float shootTime = 0;
 };
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 36)
+++ Source/Source.vcxproj.filters	(revision 37)
@@ -35,6 +35,9 @@
     <ClCompile Include="Spire.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="Bullet.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -72,6 +75,9 @@
     <ClInclude Include="Spire.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="Bullet.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 36)
+++ Source/BaseLevelScene.cpp	(revision 37)
@@ -62,7 +62,7 @@
 			if (obj->getSpriteType() == TOWER1) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
 			}
-			if (obj->getSpriteType() == BULLET1) {
+			if (obj->is("projectile")) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
 			}
 		}
@@ -101,6 +101,8 @@
 
 	// Movement controls
 	_handleMoveKeys();
+	// Shooting controls
+	_handleShootKeys();
 
 	// Toggle camera mode
 	if (m_pKeyboard->TriggerDown('Z'))
@@ -113,7 +115,7 @@
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('T')) {
 		Vector3 pos = player->getPos();
-		addObject(new Tower(this, pos.x, pos.y, 0.85));
+		addObject(new Tower(this, pos.x, pos.y, 0.849));
 	}
 
 	if (m_pKeyboard->TriggerDown('X')) {
@@ -122,43 +124,6 @@
 	}
 }
 
-void BaseLevelScene::_handleMoveKeys() {
-	// Moving of the character
-	if (m_pKeyboard->Down('A'))
-	{
-		// Left-Up
-		if (m_pKeyboard->Down('W'))
-			player->setVelocity(100, 135);
-		// Left-Down
-		else if (m_pKeyboard->Down('S'))
-			player->setVelocity(100, 225);
-		// Left
-		else
-			player->setVelocity(100, 180);
-	}
-	else if (m_pKeyboard->Down('D'))
-	{
-		// Right-Up
-		if (m_pKeyboard->Down('W'))
-			player->setVelocity(100, 45);
-		// Right-Down
-		else if (m_pKeyboard->Down('S'))
-			player->setVelocity(100, 315);
-		// Right
-		else
-			player->setVelocity(100, 0);
-	}
-	// Down
-	else if (m_pKeyboard->Down('S'))
-		player->setVelocity(100, 270);
-	// Up
-	else if (m_pKeyboard->Down('W'))
-		player->setVelocity(100, 90);
-	// No movement
-	else
-		player->setVelocity(0, player->getAngle());
-}
-
 void BaseLevelScene::checkPlyClsn() {
 	// Determine if the player is colliding with the map
 	bool hit = false;
@@ -185,7 +150,7 @@
 	}
 	for (auto i : clsnBoxes) {
 		for (auto j : objectList) {
-			if (j->getSpriteType() == BULLET1) {
+			if (j->is("projectile")) {
 				if (j->m_sAabb.Intersects(i))
 					j->kill();
 			}
@@ -196,7 +161,7 @@
 //possibilities of 2 objects colliding
 void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
 	if (obj1->m_sAabb.Intersects(obj2->m_sAabb)) {
-		if (obj1->getSpriteType() == BULLET1 && obj2->getSpriteType() == GOBLIN_IDLE) {
+		if (obj1->is("projectile") && obj2->is("baddie")) {
 			obj2->kill();
 			obj1->kill();
 		}
@@ -266,4 +231,76 @@
 	string sp = m_pRandom->randn(0, 1) ? "enSpawn1" : "enSpawn2";
 	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, .851)));
 	baddies[baddies.size() - 1]->setDestinationID(sp);
-}
\ No newline at end of file
+}
+
+
+void BaseLevelScene::_handleMoveKeys() {
+	// Moving of the character
+	if (m_pKeyboard->Down('A'))
+	{
+		// Left-Up
+		if (m_pKeyboard->Down('W'))
+			player->setVelocity(100, 135);
+		// Left-Down
+		else if (m_pKeyboard->Down('S'))
+			player->setVelocity(100, 225);
+		// Left
+		else
+			player->setVelocity(100, 180);
+	}
+	else if (m_pKeyboard->Down('D'))
+	{
+		// Right-Up
+		if (m_pKeyboard->Down('W'))
+			player->setVelocity(100, 45);
+		// Right-Down
+		else if (m_pKeyboard->Down('S'))
+			player->setVelocity(100, 315);
+		// Right
+		else
+			player->setVelocity(100, 0);
+	}
+	// Down
+	else if (m_pKeyboard->Down('S'))
+		player->setVelocity(100, 270);
+	// Up
+	else if (m_pKeyboard->Down('W'))
+		player->setVelocity(100, 90);
+	// No movement
+	else
+		player->setVelocity(0, player->getAngle());
+}
+
+void BaseLevelScene::_handleShootKeys() {
+	// Moving of the character
+	if (m_pKeyboard->Down(VK_LEFT))
+	{
+		// Left-Up
+		if (m_pKeyboard->Down(VK_UP))
+			player->shoot(300, 135);
+		// Left-Down
+		else if (m_pKeyboard->Down(VK_DOWN))
+			player->shoot(300, 225);
+		// Left
+		else
+			player->shoot(300, 180);
+	}
+	else if (m_pKeyboard->Down(VK_RIGHT))
+	{
+		// Right-Up
+		if (m_pKeyboard->Down(VK_UP))
+			player->shoot(300, 45);
+		// Right-Down
+		else if (m_pKeyboard->Down(VK_DOWN))
+			player->shoot(300, 315);
+		// Right
+		else
+			player->shoot(300, 0);
+	}
+	// Down
+	else if (m_pKeyboard->Down(VK_DOWN))
+		player->shoot(300, 270);
+	// Up
+	else if (m_pKeyboard->Down(VK_UP))
+		player->shoot(300, 90);
+}

------------------------------------------------------------------------
r40 | jdg0393 | 2020-11-09 01:05:08 -0600 (Mon, 09 Nov 2020) | 1 line

Upscaled all images in game to prevent weird blur

Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(revision 39)
+++ Source/TiledScene.cpp	(revision 40)
@@ -56,9 +56,9 @@
 	inData.close();
 
 	// Load each of the main 3 display layers
-	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey);
-	_loadTileLayer(map_name + "_fg.txt", tileSpriteKey);
-	_loadTileLayer(map_name + "_oh.txt", tileSpriteKey);
+	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey, 1.3);
+	_loadTileLayer(map_name + "_fg.txt", tileSpriteKey, 1.2);
+	_loadTileLayer(map_name + "_oh.txt", tileSpriteKey, 1.1);
 	// Load the collision layer
 	_loadClsnLayer(map_name + "_collision.txt");
 	// Load the path layer
@@ -65,7 +65,7 @@
 	_loadPathLayer(map_name + "_paths.txt");
 }
 
-void TiledScene::_loadTileLayer(std::string filename, eSpriteType tileSpriteKey) {
+void TiledScene::_loadTileLayer(std::string filename, eSpriteType tileSpriteKey, float depth) {
 	// Get the index of the layers vector we will be pushing a layer to
 	int i = layers.size();
 	// Push a new layer
@@ -87,11 +87,11 @@
 				desc.m_nCurrentFrame = tileID;
 				// Larc engine uses a mathematical axis, so +y is upwards
 				// and lower Z values render on top
-				desc.m_vPos = Vector3((c * tileSize) + 4, (r * tileSize * -1) + (tilemapHeight * tileSize) - 4, 1 - (i / 10.0));
+				desc.m_vPos = Vector3((c * tileSize) + .5f * tileSize, (r * tileSize * -1) + (tilemapHeight * tileSize) - .5f * tileSize, depth);
 				BoundingBox b;
 				Vector3 p = desc.m_vPos;
 				b.Center = { p.x, p.y, p.z };
-				b.Extents = { 4, 4, 4 };
+				b.Extents = { .5f * tileSize, .5f * tileSize, depth / 2 };
 				desc.m_sAabb = b;
 				layers[i][r].push_back(desc);
 			}
Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(revision 39)
+++ Source/Spire.h	(revision 40)
@@ -6,7 +6,7 @@
 {
 public:
     int hp = 1000;
-    Spire(Scene* scene, float x, float y, float z);
+    Spire(Scene* scene, float x, float y, float z = 1.19);
     void update() override;
 };
 
Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 39)
+++ Source/Scene.h	(revision 40)
@@ -26,5 +26,6 @@
 protected:
 	CGame* game; // Reference to game which created this scene
 	std::vector<GameObject*> objectList; // Game objects managed by this scene
+	GameObject* backgroundSprite = nullptr;
 };
 
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 39)
+++ Source/BadCharacter.cpp	(revision 40)
@@ -2,9 +2,18 @@
 #include "BaseLevelScene.h"
 
 BadCharacter::BadCharacter(Scene* scene, float x, float y, float z) :
-	Character(scene, GOBLIN_IDLE, x, y, z)
+	Character(scene, GOBLIN_WALK, x, y, z)
 {
-	m_sAabb = BoundingBox({ x,y,z }, { 4,4,4 });
+	// Track the scene as a level scene
+	level = (BaseLevelScene*)scene;
+	// Animations starting data
+	subframe = 0;
+	subframe_count = 4;
+	subframe_interval = .15;
+	subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
+	// Bounding box configuration
+	m_sAabb = BoundingBox({ x,y,z }, { 16,12,16 });
+	// Paths configuration
 	paths = ((BaseLevelScene*)scene)->getPaths();
 	// Descriptor tags
 	tags.insert("baddie");
@@ -15,8 +24,8 @@
 	// Set the bad guy's destination
 	_updateDestination();
 	// Attack the tower, under the right conditions
-	if (destID == "end" && dist < 15) {
-		Vector2 spire = ((BaseLevelScene*)scene)->getSpire()->getPos();
+	if (destID == "end" && m_sAabb.Intersects(level->getSpire()->m_sAabb)) {
+		Vector2 spire = level->getSpire()->getPos();
 		stopped = true;
 		attacking = true;
 		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
@@ -39,14 +48,16 @@
 	if (attacking && m_nSpriteIndex != GOBLIN_ATTACK) {
 		m_nSpriteIndex = GOBLIN_ATTACK;
 		subframe = 0;
+		subframe_count = 4;
 		subframe_interval = .15;
-		subframe_time = m_pStepTimer->GetTotalSeconds() + .15;
+		subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
 	}
-	else if (!attacking) {
-		m_nSpriteIndex = GOBLIN_IDLE;
+	else if (!attacking && m_nSpriteIndex != GOBLIN_WALK) {
+		m_nSpriteIndex = GOBLIN_WALK;
 		subframe = 0;
-		subframe_interval = .5;
-		subframe_time = m_pStepTimer->GetTotalSeconds() + .5;
+		subframe_count = 4;
+		subframe_interval = .15;
+		subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
 	}
 	// Run the normal animate behavior
 	Character::animate();
Index: Source/Renderer.h
===================================================================
--- Source/Renderer.h	(revision 39)
+++ Source/Renderer.h	(revision 40)
@@ -1,6 +1,26 @@
 /// \file Renderer.h 
 /// \brief Interface for the renderer class CRenderer.
 
+/*
+	Object Depth Reference
+	
+	When you're setting depth for objects in other classes, it is important to keep
+	in mind what our game standardly expects for depths, as well as the general scale
+	and everything of depths between objects. Here is an ordered list.
+
+	1
+		1.0
+			1.09 -> Spire Peak
+		1.1 -> Overhead Tile Layer
+			1.15 -> Player Object
+			1.19 -> Spire Base
+		1.2 -> Foreground Tile Layer
+	    1.3 -> Background Tiles Layer
+	10
+		10.0 -> Black Background
+	(Lower depth means closer to the camera)
+*/
+
 #pragma once
 
 #include <map>
@@ -11,7 +31,6 @@
 ///
 /// CRenderer handles the game-specific rendering tasks, relying on
 /// the base class to do all of the actual API-specific rendering.
-
 class CRenderer : public CSpriteRenderer {
 public:
 	CRenderer(); ///< Constructor.
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 39)
+++ Source/GameDefines.h	(revision 40)
@@ -10,15 +10,16 @@
 ///
 /// Note: NUM_SPRITES must be last.
 enum eSpriteType {
-	BACKGROUND,
+	BLACK_SQUARE,
 	TITLE_SCREEN,
 	GREENLINE_SPRITE,
 	SIMPLE_TILE,
 	HUMAN_IDLE,
-	GOBLIN_IDLE,
+	GOBLIN_WALK,
 	GOBLIN_ATTACK,
 	BULLET1,
-	SPIRE,
+	SPIRE_BASE,
+	SPIRE_PEAK,
 	TOWER1,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 39)
+++ Source/PlayerCharacter.h	(revision 40)
@@ -7,10 +7,10 @@
 	public Character
 {
 public:
-	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
+	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15);
 	void update() override; // Character's update loop, runs every frame
 	void shoot(float speed, float angle_in_degrees);
 private:
-	float shootCooldown = 2;
+	float shootCooldown = .25;
 	float shootTime = 0;
 };
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 39)
+++ Source/BaseLevelScene.cpp	(revision 40)
@@ -16,14 +16,13 @@
 	defPos = m_pRenderer->GetCameraPos();
 	// Create the simple tilemap
 	loadTileMap("simple", SIMPLE_TILE);
-	// Tilemap overhead layer is rendered at .8z, foreground at .9z
-	// So we place the human in between at .85z
-	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, paths["plySpawn"].x, paths["plySpawn"].y, .85));
+	backgroundSprite->m_vPos = { (tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, 10 };
+	// Place the player on the map
+	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, paths["plySpawn"].x, paths["plySpawn"].y));
 	// Set the camera to follow the player
 	camFollowVision(player);
 	// Create the spire object
-	spire = (Spire*)addObject(new Spire(this, paths["end"].x, paths["end"].y, .849));
-	spire->m_sAabb = BoundingBox({ spire->getPos().x, spire->getPos().y - 22, spire->getPos().z }, { 16, 7, 4 });
+	spire = (Spire*)addObject(new Spire(this, paths["end"].x, paths["end"].y));
 }
 
 void BaseLevelScene::update() {
@@ -37,7 +36,7 @@
 	CullDead();
 	// Update the camera position if we're following the player
 	if (followTarget)
-		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
+		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 1.5));
 	// Check end of game conditions
 	if (gameOver && m_pStepTimer->GetTotalSeconds() > endTime) {
 		m_pAudio->stop();
@@ -65,6 +64,9 @@
 			if (obj->is("projectile")) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
 			}
+			if (obj->is("baddie")) {
+				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
+			}
 		}
 	}
 	if (!gameOver) {
@@ -84,7 +86,6 @@
 void BaseLevelScene::camFollowVision(GameObject* target) {
 	shouldFollow = true;
 	followTarget = target;
-	m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 8));
 }
 
 void BaseLevelScene::camMapVision() {
@@ -91,7 +92,7 @@
 	if (tileSize > 0) {
 		shouldFollow = false;
 		followTarget = nullptr;
-		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2) * tileSize, (tilemapHeight / 2) * tileSize, defPos.z / 2));
+		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2) * tileSize, (tilemapHeight / 2) * tileSize, defPos.z * 2));
 	}
 }
 
@@ -115,7 +116,7 @@
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('T')) {
 		Vector3 pos = player->getPos();
-		addObject(new Tower(this, pos.x, pos.y, 0.849));
+		addObject(new Tower(this, pos.x, pos.y-32, 1.14));
 	}
 
 	if (m_pKeyboard->TriggerDown('X')) {
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 39)
+++ Source/Spire.cpp	(revision 40)
@@ -3,7 +3,10 @@
 #include "BaseLevelScene.h"
 
 Spire::Spire(Scene* scene, float x, float y, float z) :
-	GameObject(scene, SPIRE, x, y, z) {}
+	GameObject(scene, SPIRE_BASE, x, y, z) {
+	m_sAabb = BoundingBox({ x, y + 6, z }, { 64, 26, 32 });
+	scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z-.1));
+}
 
 void Spire::update()
 {
Index: Source/TiledScene.h
===================================================================
--- Source/TiledScene.h	(revision 39)
+++ Source/TiledScene.h	(revision 40)
@@ -36,7 +36,7 @@
 	// Boolean determining if we draw tilemap aabbs
 	bool drawMapClsn = false;
 	// Functions to add a single layer of a map
-	void _loadTileLayer(std::string filename, eSpriteType tileSpriteKey);
+	void _loadTileLayer(std::string filename, eSpriteType tileSpriteKey, float depth);
 	void _loadClsnLayer(std::string filename);
 	void _loadPathLayer(std::string filename);
 };
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 39)
+++ Source/Scene.cpp	(revision 40)
@@ -21,9 +21,9 @@
 
 // Method where objects, tiles, etc should be created
 void Scene::create() {
-	GameObject* backgroundSprite = addObject(new GameObject(this, BACKGROUND, 640, 360, 10));
-	backgroundSprite->m_fXScale = 2;
-	backgroundSprite->m_fYScale = 2;
+	backgroundSprite = addObject(new GameObject(this, BLACK_SQUARE, 640, 360, 10));
+	backgroundSprite->m_fXScale = 1280;
+	backgroundSprite->m_fYScale = 720;
 }
 
 // Method that runs every tick, most logic should go here. You may also call
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 39)
+++ Source/Renderer.cpp	(revision 40)
@@ -28,15 +28,16 @@
 	BeginResourceUpload();
 
 	// Loading of images goes here
-	Load(BACKGROUND, "background");
+	Load(BLACK_SQUARE, "black_square");
 	Load(TITLE_SCREEN, "title_screen");
 	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(HUMAN_IDLE, "human_idle");
-	Load(GOBLIN_IDLE, "goblin_idle");
+	Load(GOBLIN_WALK, "goblin_walk");
 	Load(GOBLIN_ATTACK, "goblin_attack");
 	Load(BULLET1, "bullet1");
-	Load(SPIRE, "spire");
+	Load(SPIRE_BASE, "spire_base");
+	Load(SPIRE_PEAK, "spire_peak");
 	Load(TOWER1, "tower1");
 
 	// Load any additional fonts
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 39)
+++ Source/BadCharacter.h	(revision 40)
@@ -2,6 +2,9 @@
 #include <map>
 #include "Character.h"
 
+// Forward declarations
+class BaseLevelScene;
+
 class BadCharacter :
 	public Character
 {
@@ -15,6 +18,7 @@
 	void setDestination(float x, float y);
 	void setDestinationID(string id);
 protected:
+	BaseLevelScene* level = nullptr;
 	float cooldown = .6;
 	float cooldown_time = 0;
 	map<string, PathPoint> paths;
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 39)
+++ Source/PlayerCharacter.cpp	(revision 40)
@@ -6,7 +6,7 @@
 PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z) :
 	Character(scene, HUMAN_IDLE, x, y, z)
 {
-	m_sAabb = BoundingBox({ x,y,z }, { 4,4,4 });
+	m_sAabb = BoundingBox({ x,y,z }, { 16,12,16 });
 }
 
 void PlayerCharacter::update() {

------------------------------------------------------------------------
r42 | amm0837 | 2020-11-09 17:04:53 -0600 (Mon, 09 Nov 2020) | 1 line

added fireball class and update function. TODO: fireballs will deal splash damage when intersects a enemy

Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 41)
+++ Source/Tower.cpp	(revision 42)
@@ -1,5 +1,6 @@
 #include "Tower.h"
 #include "Bullet.h"
+#include "Fireball.h"
 
 
 Tower::Tower(Scene* scene, float x = 0, float y = 0, float z = 0) :
@@ -8,6 +9,7 @@
 	objScene = scene;
 	setRoll(XM_2PI);
 	m_sAabb = BoundingBox({ x,y - 17,z }, { 12,8,4 });
+	tags.insert("tower");
 
 
 }
@@ -17,6 +19,8 @@
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
 		fire(this);
 	}
+
+	
 }
 
 GameObject* Tower::calcTarget() {
@@ -53,7 +57,7 @@
 	if (target != nullptr) {
 		m_pAudio->play(GUN_SOUND);
 		//creating bullet and setting its bounding box
-		GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z));
+		GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z));
 
 		//set bullet direction to enemy direction
 		const Vector3 dir = b->getPos() - target->getPos();
@@ -60,7 +64,7 @@
 		b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
 		const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
 														//the direction of bullet velocity
-		b->setVel(p->getVel() + 100.0f * view);
+		b->setVel(p->getVel() + 500.0f * view);
 		b->setRoll(b->m_fRoll);
 	}
 
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 41)
+++ Source/Source.vcxproj	(revision 42)
@@ -168,6 +168,7 @@
     <ClCompile Include="Bullet.cpp" />
     <ClCompile Include="Character.cpp" />
     <ClCompile Include="Common.cpp" />
+    <ClCompile Include="Fireball.cpp" />
     <ClCompile Include="Game.cpp" />
     <ClCompile Include="GameObject.cpp" />
     <ClCompile Include="Main.cpp" />
@@ -185,6 +186,7 @@
     <ClInclude Include="Bullet.h" />
     <ClInclude Include="Character.h" />
     <ClInclude Include="Common.h" />
+    <ClInclude Include="Fireball.h" />
     <ClInclude Include="Game.h" />
     <ClInclude Include="GameDefines.h" />
     <ClInclude Include="GameObject.h" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 41)
+++ Source/Source.vcxproj.filters	(revision 42)
@@ -38,6 +38,9 @@
     <ClCompile Include="Bullet.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="Fireball.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -78,6 +81,9 @@
     <ClInclude Include="Bullet.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="Fireball.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 41)
+++ Source/BaseLevelScene.cpp	(revision 42)
@@ -31,6 +31,7 @@
 	// Core scene update, including updating objects
 	Scene::update();
 	// Check for the player colliding with the tilemap
+	
 	checkPlyClsn();
 	BroadPhaseClsn();
 	CullDead();
@@ -58,7 +59,7 @@
 		m_pRenderer->DrawBoundingBox(spire->m_sAabb);
 		m_pRenderer->DrawBoundingBox(player->m_sAabb);
 		for (auto obj : objectList) {
-			if (obj->getSpriteType() == TOWER1) {
+			if (obj->is("tower")) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
 			}
 			if (obj->is("projectile")) {
@@ -135,7 +136,7 @@
 	// If the player is colliding, move them back
 	//check if player collides with a tower
 	for (auto obj : objectList) {
-		if (obj->getSpriteType() == TOWER1) {
+		if (obj->is("tower")) {
 			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
 		}
 	}
@@ -151,7 +152,7 @@
 	}
 	for (auto i : clsnBoxes) {
 		for (auto j : objectList) {
-			if (j->is("projectile")) {
+			if (j->is("projectile") || j->is("fireball")) {
 				if (j->m_sAabb.Intersects(i))
 					j->kill();
 			}
@@ -166,7 +167,16 @@
 			obj2->kill();
 			obj1->kill();
 		}
+		if (obj1->is("fireball") && obj2->is("baddie")) {
+			//TODO
+			//when fireball intersects baddie, kill baddies within certain radius of fireball
+			//then kill fireball
+
+			obj2->kill();	//this is temporary
+			obj1->kill();	//this is temporary
+		}
 	}
+	
 }
 
 void BaseLevelScene::CullDead() {
Index: Source/Bullet.h
===================================================================
--- Source/Bullet.h	(revision 41)
+++ Source/Bullet.h	(revision 42)
@@ -5,5 +5,6 @@
 {
 public:
     Bullet(Scene* scene, float x = 0, float y = 0, float z = 0);
+    void update() override;
 };
 
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 41)
+++ Source/Tower.h	(revision 42)
@@ -11,6 +11,7 @@
 	GameObject* calcTarget();
 	void fire(GameObject* p);
 	void setRoll(float angle);
+	//void splashDmg();
 
 private:
 	GameObject* target = nullptr;
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 41)
+++ Source/Renderer.cpp	(revision 42)
@@ -39,6 +39,7 @@
 	Load(SPIRE_BASE, "spire_base");
 	Load(SPIRE_PEAK, "spire_peak");
 	Load(TOWER1, "tower1");
+	Load(FIREBALL, "fireball");
 
 	// Load any additional fonts
 	loadNewFont("title_font");
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 41)
+++ Source/GameDefines.h	(revision 42)
@@ -21,5 +21,6 @@
 	SPIRE_BASE,
 	SPIRE_PEAK,
 	TOWER1,
+	FIREBALL,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/Bullet.cpp
===================================================================
--- Source/Bullet.cpp	(revision 41)
+++ Source/Bullet.cpp	(revision 42)
@@ -6,3 +6,12 @@
 	tags.insert("projectile");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
 }
+
+void Bullet::update() {
+	const float t = m_pStepTimer->GetElapsedSeconds();
+	m_vPos.x += m_vVelocity.x * t;
+	m_vPos.y += m_vVelocity.y * t;	//update object position
+
+	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
+	m_sAabb.Center.y = m_vPos.y;
+}

------------------------------------------------------------------------
r43 | amm0837 | 2020-11-11 11:13:52 -0600 (Wed, 11 Nov 2020) | 1 line

added fireball

Index: Source/Fireball.h
===================================================================
--- Source/Fireball.h	(nonexistent)
+++ Source/Fireball.h	(revision 43)
@@ -0,0 +1,10 @@
+#pragma once
+#include "GameObject.h"
+class Fireball :
+    public GameObject
+{
+public:
+    Fireball(Scene* scene, float x = 0, float y = 0, float z = 0);
+    void update() override;
+    void splash();
+};
\ No newline at end of file
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(nonexistent)
+++ Source/Fireball.cpp	(revision 43)
@@ -0,0 +1,21 @@
+#include "Fireball.h"
+
+Fireball::Fireball(Scene* scene, float x, float y, float z) :
+	GameObject(scene, FIREBALL, x, y, z)
+{
+	tags.insert("fireball");
+	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
+}
+
+void Fireball::update() {
+	const float t = m_pStepTimer->GetElapsedSeconds();
+	m_vPos.x += m_vVelocity.x * t;
+	m_vPos.y += m_vVelocity.y * t;	//update object position
+
+	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
+	m_sAabb.Center.y = m_vPos.y;
+	
+}
+void Fireball::splash() {
+
+}
\ No newline at end of file

------------------------------------------------------------------------
r44 | amm0837 | 2020-11-11 18:00:05 -0600 (Wed, 11 Nov 2020) | 1 line

added splash damage mechanic

Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 43)
+++ Source/GameObject.cpp	(revision 44)
@@ -5,9 +5,13 @@
 	this->scene = scene;
 	this->m_vPos = Vector3(x, y, z);
 	m_nSpriteIndex = spriteKey;
+	m_pParticleEngine = new CParticleEngine3D(); // each object has its own particle engine
 }
-GameObject::~GameObject() {}
+GameObject::~GameObject() {
+	delete m_pParticleEngine;
 
+}
+
 void GameObject::update() {
 	//printf("GameObject::update()\n");
 	const float t = m_pStepTimer->GetElapsedSeconds();
@@ -18,6 +22,26 @@
 	m_sAabb.Center.y = m_vPos.y;
 }
 
+bool GameObject::inRadius(Vector3 pos, float dist) {		//returns true if object is within dist of pos
+	if (abs(sqrt(pow(pos.x, 2) + pow(pos.y, 2)) - sqrt(pow(this->getPos().x, 2) + pow(this->getPos().y, 2))) <= dist)
+		return true;
+	else
+		return false;
+}
+void GameObject::explode() {
+	//TODO: smoke effect is not appearing for some reason
+	const Vector3 pos = this->getPos();
+	printf("smoke effect\n");
+	CParticleDesc3D dExplosion;
+	dExplosion.m_nSpriteIndex = SMOKE;
+	dExplosion.m_vPos = pos;
+	dExplosion.m_fFadeOutFrac = 0.4f;
+	dExplosion.m_fScaleOutFrac = 0.5f;
+	dExplosion.m_fLifeSpan = 2.0f;
+	dExplosion.m_fMaxScale = 0.5f;
+	m_pParticleEngine->create(dExplosion);
+}
+
 void GameObject::kill() {
 	isDead = true;
 }
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 43)
+++ Source/GameDefines.h	(revision 44)
@@ -22,5 +22,6 @@
 	SPIRE_PEAK,
 	TOWER1,
 	FIREBALL,
+	SMOKE,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 43)
+++ Source/BaseLevelScene.cpp	(revision 44)
@@ -167,18 +167,21 @@
 			obj2->kill();
 			obj1->kill();
 		}
-		if (obj1->is("fireball") && obj2->is("baddie")) {
-			//TODO
-			//when fireball intersects baddie, kill baddies within certain radius of fireball
-			//then kill fireball
-
-			obj2->kill();	//this is temporary
-			obj1->kill();	//this is temporary
+		if (obj1->is("fireball") && obj2->is("baddie")) {	//when fireball intersects baddie, kill baddies within certain radius of fireball
+			obj1->kill();										//then kill fireball
+			obj1->explode();
+			for (GameObject* obj : this->getBaddies()) {
+				if (obj->inRadius(obj1->getPos(), 50.0f)) {
+					obj->kill();
+				}
+			}
+				
 		}
 	}
 	
 }
 
+
 void BaseLevelScene::CullDead() {
 	int sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
@@ -216,7 +219,7 @@
 	GameObject* tow = NULL;
 	float difX = 1000, difY = 1000, dif = 1000;
 	for (GameObject*& obj : objectList) {
-		if (obj->getSpriteType() == TOWER1) {
+		if (obj->is("tower")) {
 			towerPos = obj->getPos();
 			difX = abs(playerPos.x - towerPos.x);
 			difY = abs(playerPos.y - towerPos.y);
@@ -245,6 +248,7 @@
 }
 
 
+
 void BaseLevelScene::_handleMoveKeys() {
 	// Moving of the character
 	if (m_pKeyboard->Down('A'))
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 43)
+++ Source/Fireball.cpp	(revision 44)
@@ -16,6 +16,5 @@
 	m_sAabb.Center.y = m_vPos.y;
 	
 }
-void Fireball::splash() {
 
-}
\ No newline at end of file
+
Index: Source/Common.h
===================================================================
--- Source/Common.h	(revision 43)
+++ Source/Common.h	(revision 44)
@@ -4,6 +4,7 @@
 #pragma once
 
 #include "SndList.h"
+#include "ParticleEngine.h"
 
 //forward declarations to make the compiler less stroppy
 class CRenderer;
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 43)
+++ Source/GameObject.h	(revision 44)
@@ -29,11 +29,15 @@
 	bool dead(); //true if dead, false otherwise
 	void kill(); // set isdead flag to true;
 
+	bool inRadius(Vector3 pos, float dist);
 	bool is(string tag); // Checks if the game object has a certain descriptor tag
+
+	void explode(); // particle effect for fireball explosion
 protected:
 	Scene* scene; // Scene which manages this object
 	Vector2 m_vVelocity = Vector2::Zero;
 	bool isDead = false;
 	unordered_set<string> tags;
+	CParticleEngine3D* m_pParticleEngine = nullptr; ///< Pointer to a particle engine.
 };
 
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 43)
+++ Source/Renderer.cpp	(revision 44)
@@ -40,7 +40,7 @@
 	Load(SPIRE_PEAK, "spire_peak");
 	Load(TOWER1, "tower1");
 	Load(FIREBALL, "fireball");
-
+	Load(SMOKE, "smoke");
 	// Load any additional fonts
 	loadNewFont("title_font");
 	loadNewFont("selection_font");
Index: Source/Fireball.h
===================================================================
--- Source/Fireball.h	(revision 43)
+++ Source/Fireball.h	(revision 44)
@@ -1,5 +1,6 @@
 #pragma once
 #include "GameObject.h"
+#include "Tower.h"
 class Fireball :
     public GameObject
 {
@@ -6,5 +7,5 @@
 public:
     Fireball(Scene* scene, float x = 0, float y = 0, float z = 0);
     void update() override;
-    void splash();
+    
 };
\ No newline at end of file
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 43)
+++ Source/BaseLevelScene.h	(revision 44)
@@ -4,6 +4,7 @@
 #include "BadCharacter.h"
 #include "Spire.h"
 #include "Tower.h"
+#include "Fireball.h"
 
 // Forward declarations for circular dependency
 class CGame;
@@ -31,7 +32,6 @@
 	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
 	void WallCollision();
 	void CullDead(); //finds objects with isDead = true, remove from objlist and deallocate pointer
-
 	void endGame();
 	void spawnBaddie();
 

------------------------------------------------------------------------
r45 | jdg0393 | 2020-11-12 17:52:17 -0600 (Thu, 12 Nov 2020) | 1 line

GameObject animation system.

Index: Source/Character.cpp
===================================================================
--- Source/Character.cpp	(revision 44)
+++ Source/Character.cpp	(revision 45)
@@ -5,20 +5,9 @@
 {}
 Character::~Character() {}
 
-void Character::animate() {
-	// Set the direction the player should be facing
-	_calcDirection();
-	// Set the frame the player should use
-	if (m_pStepTimer->GetTotalSeconds() > subframe_time) {
-		subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
-		subframe = (subframe + 1) % subframe_count;
-	}
-	m_nCurrentFrame = subframe + (direction * subframe_count);
-}
-
 void Character::move() {
 	// Store the current position
-	oldPos = { m_vPos.x, m_vPos.y };
+	oldPosition = { m_vPos.x, m_vPos.y };
 	// Get the time passed since last frame
 	const float t = m_pStepTimer->GetElapsedSeconds();
 	// Move based on velocity (in px/s) * time (in s)
@@ -33,10 +22,10 @@
 	// Store the current position
 	Vector2 nowPos = { m_vPos.x, m_vPos.y };
 	// Move back to the old position
-	m_vPos.x = oldPos.x;
-	m_vPos.y = oldPos.y;
+	m_vPos.x = oldPosition.x;
+	m_vPos.y = oldPosition.y;
 	// Set the new "old" position (which is actually where we started this frame)
-	oldPos = nowPos;
+	oldPosition = nowPos;
 	// Update the bounding box location
 	m_sAabb.Center.x = m_vPos.x;
 	m_sAabb.Center.y = m_vPos.y;
@@ -60,24 +49,40 @@
 	velocity = { xSpeed, ySpeed };
 }
 
-void Character::_calcDirection() {
-	if ((int)angle % 90 != 0) {
-		direction = angle / 90;
+void Character::calculateAnimationDirection() {
+	string oldDirection = animationDirection;
+	int n = (int)angle;
+	// If not one of the four cardinal directions
+	if (n % 90 != 0) {
+		if (n < 90) animationDirection = "NE";
+		else if (n < 180) animationDirection = "NW";
+		else if (n < 270) animationDirection = "SW";
+		else animationDirection = "SE";
 	}
-	else if ((int)angle == 90) {
-		if (direction == 2) direction = 1;
-		else if (direction == 3) direction = 0;
+	// Handle each of the cardinal directions
+	else if (n == 90) {
+		// If going up and not facing up, face up
+		if (animationDirection == "SW") animationDirection = "NW";
+		else if (animationDirection == "SE") animationDirection = "NE";
 	}
-	else if ((int)angle == 270) {
-		if (direction == 0) direction = 3;
-		else if (direction == 1) direction = 2;
+	else if (n == 270) {
+		// If going down and not facing down, face down
+		if (animationDirection == "NE") animationDirection = "SE";
+		else if (animationDirection == "NW") animationDirection = "SW";
 	}
-	else if ((int)angle == 0) {
-		if (direction == 1) direction = 0;
-		else if (direction == 2) direction = 3;
+	else if (n == 0) {
+		// If going right and not facing right, face right
+		if (animationDirection == "NW") animationDirection = "NE";
+		else if (animationDirection == "SW") animationDirection = "SE";
 	}
-	else if ((int)angle == 180) {
-		if (direction == 0) direction = 1;
-		else if (direction == 3) direction = 2;
+	else if (n == 180) {
+		// If going left and not facing left, face left
+		if (animationDirection == "NE") animationDirection = "NW";
+		else if (animationDirection == "SE") animationDirection = "SW";
 	}
-}
\ No newline at end of file
+
+	// Maybe call a callback function
+	if (animationDirection != oldDirection) onChangedAnimationDirection();
+}
+
+void Character::onChangedAnimationDirection() {}
\ No newline at end of file
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 44)
+++ Source/GameObject.cpp	(revision 45)
@@ -5,6 +5,7 @@
 	this->scene = scene;
 	this->m_vPos = Vector3(x, y, z);
 	m_nSpriteIndex = spriteKey;
+	activeAnimation = AnimationDesc(spriteKey, 0, 0, 0.5);
 	m_pParticleEngine = new CParticleEngine3D(); // each object has its own particle engine
 }
 GameObject::~GameObject() {
@@ -14,6 +15,8 @@
 
 void GameObject::update() {
 	//printf("GameObject::update()\n");
+	stepAnimation();
+
 	const float t = m_pStepTimer->GetElapsedSeconds();
 	m_vPos.x += m_vVelocity.x * t;
 	m_vPos.y += m_vVelocity.y * t;	//update object position
@@ -49,7 +52,6 @@
 	return isDead;
 }
 
-
 void GameObject::setRoll(float angle) {
 	m_fRoll = angle;
 }
@@ -76,4 +78,57 @@
 
 bool GameObject::is(string tag) {
 	return tags.find(tag) != tags.end();
+}
+
+void GameObject::startAnimation(const AnimationDesc& anim, bool loop) {
+	activeAnimation = anim;
+	isAnimating = true;
+	loopAnimation = loop;
+	m_nSpriteIndex = activeAnimation.sprite;
+	m_nCurrentFrame = activeAnimation.startFrame;
+	animationTimer = m_pStepTimer->GetTotalSeconds() + activeAnimation.frameTime;
+}
+
+void GameObject::stepAnimation() {
+	if (isAnimating) {
+		const float t = m_pStepTimer->GetTotalSeconds();
+		if (t > animationTimer) {
+			m_nCurrentFrame++;
+			// If we've reached the end of the animation
+			if (m_nCurrentFrame > activeAnimation.endFrame) {
+				// Run the completion callback
+				onAnimationComplete(activeAnimation);
+				// If we are looping, update set the frame back to the start
+				if (loopAnimation) {
+					m_nCurrentFrame = activeAnimation.startFrame;
+				}
+				// If we are not looping, set frame to the end and stop animating
+				else {
+					m_nCurrentFrame = activeAnimation.endFrame;
+					stopAnimation();
+				}
+			}
+			// Update when the next frame change should occur
+			animationTimer = t + activeAnimation.frameTime;
+		}
+	}
+}
+
+void GameObject::stopAnimation() {
+	isAnimating = false;
+	loopAnimation = false;
+}
+
+void GameObject::onAnimationComplete(const AnimationDesc& anim) {
+	//printf("Terminating Animation: %d\n", anim.sprite);
+	return;
+}
+
+bool GameObject::isPlayingAnimation(const AnimationDesc& anim) {
+	if (!isAnimating) return false;
+	if (activeAnimation.sprite != anim.sprite) return false;
+	if (activeAnimation.startFrame != anim.startFrame) return false;
+	if (activeAnimation.endFrame != anim.endFrame) return false;
+	if (activeAnimation.frameTime != anim.frameTime) return false;
+	return true;
 }
\ No newline at end of file
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 44)
+++ Source/BadCharacter.cpp	(revision 45)
@@ -6,21 +6,29 @@
 {
 	// Track the scene as a level scene
 	level = (BaseLevelScene*)scene;
-	// Animations starting data
-	subframe = 0;
-	subframe_count = 4;
-	subframe_interval = .15;
-	subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
 	// Bounding box configuration
 	m_sAabb = BoundingBox({ x,y,z }, { 16,12,16 });
 	// Paths configuration
 	paths = ((BaseLevelScene*)scene)->getPaths();
+
 	// Descriptor tags
 	tags.insert("baddie");
+
+	// Defining animations for the bad guy
+	animations["WALK_NE"] = AnimationDesc(GOBLIN_WALK, 0, 3, 0.15);
+	animations["WALK_NW"] = AnimationDesc(GOBLIN_WALK, 4, 7, 0.15);
+	animations["WALK_SW"] = AnimationDesc(GOBLIN_WALK, 8, 11, 0.15);
+	animations["WALK_SE"] = AnimationDesc(GOBLIN_WALK, 12, 15, 0.15);
+	animations["ATTACK_NE"] = AnimationDesc(GOBLIN_ATTACK, 0, 3, 0.15);
+	animations["ATTACK_NW"] = AnimationDesc(GOBLIN_ATTACK, 4, 7, 0.15);
+	animations["ATTACK_SW"] = AnimationDesc(GOBLIN_ATTACK, 8, 11, 0.15);
+	animations["ATTACK_SE"] = AnimationDesc(GOBLIN_ATTACK, 12, 15, 0.15);
 }
 BadCharacter::~BadCharacter() {}
 
 void BadCharacter::update() {
+	// Animate the character
+	stepAnimation();
 	// Set the bad guy's destination
 	_updateDestination();
 	// Attack the tower, under the right conditions
@@ -37,30 +45,29 @@
 		stopped = false;
 		attacking = false;
 	}
-	// Move and animate
+	// Move the bad guy
 	_updateVelocity();
 	if (!stopped) move();
-	animate();
+	// Updates what animation is playing
+	_updateAnimation();
 }
 
-void BadCharacter::animate() {
-	// Determine which sprite to use
-	if (attacking && m_nSpriteIndex != GOBLIN_ATTACK) {
-		m_nSpriteIndex = GOBLIN_ATTACK;
-		subframe = 0;
-		subframe_count = 4;
-		subframe_interval = .15;
-		subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
+void BadCharacter::_updateAnimation() {
+	string key = "";
+
+	// Possible animation prefixes
+	if (attacking) key += "ATTACK_";
+	else key += "WALK_";
+
+	// Set the direction of the animation
+	calculateAnimationDirection();
+	key += animationDirection;
+
+	// Check if the animation is already running
+	if (!isPlayingAnimation(animations[key])) {
+		// Start the animation if it isn't already running
+		startAnimation(animations[key], true);
 	}
-	else if (!attacking && m_nSpriteIndex != GOBLIN_WALK) {
-		m_nSpriteIndex = GOBLIN_WALK;
-		subframe = 0;
-		subframe_count = 4;
-		subframe_interval = .15;
-		subframe_time = m_pStepTimer->GetTotalSeconds() + subframe_interval;
-	}
-	// Run the normal animate behavior
-	Character::animate();
 }
 
 void BadCharacter::setDestination(float x, float y) {
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 44)
+++ Source/PlayerCharacter.cpp	(revision 45)
@@ -7,12 +7,26 @@
 	Character(scene, HUMAN_IDLE, x, y, z)
 {
 	m_sAabb = BoundingBox({ x,y,z }, { 16,12,16 });
+
+	// Defining animations for the player
+	animations["IDLE_NE"] = AnimationDesc(HUMAN_IDLE, 0, 3, 0.15);
+	animations["IDLE_NW"] = AnimationDesc(HUMAN_IDLE, 4, 7, 0.15);
+	animations["IDLE_SW"] = AnimationDesc(HUMAN_IDLE, 8, 11, 0.15);
+	animations["IDLE_SE"] = AnimationDesc(HUMAN_IDLE, 12, 15, 0.15);
+	//animations["WALK_NE"] = AnimationDesc(HUMAN_WALK, 0, 3, 0.15);
+	//animations["WALK_NW"] = AnimationDesc(HUMAN_WALK, 4, 7, 0.15);
+	//animations["WALK_SW"] = AnimationDesc(HUMAN_WALK, 8, 11, 0.15);
+	//animations["WALK_SE"] = AnimationDesc(HUMAN_WALK, 12, 15, 0.15);
+	startAnimation(animations["IDLE_SE"], true);
 }
 
 void PlayerCharacter::update() {
 	//printf("PlayerCharacter::update()");
+	// Animate the character
+	stepAnimation();
 	move();
-	animate();
+	// Calculate the animation direction
+	calculateAnimationDirection();
 }
 
 void PlayerCharacter::shoot(float speed, float angle_in_degrees) {
@@ -31,4 +45,14 @@
 		// Update the next time I can shoot
 		shootTime = m_pStepTimer->GetTotalSeconds() + shootCooldown;
 	}
+}
+
+void PlayerCharacter::onChangedAnimationDirection() {
+	// When we change directions, change animation
+	_updateAnimation();
+}
+
+void PlayerCharacter::_updateAnimation() {
+	string key = "IDLE_" + animationDirection;
+	startAnimation(animations[key], true);
 }
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 44)
+++ Source/Source.vcxproj	(revision 45)
@@ -182,6 +182,7 @@
     <ClCompile Include="Tower.cpp" />
   </ItemGroup>
   <ItemGroup>
+    <ClInclude Include="AnimationDesc.h" />
     <ClInclude Include="BadCharacter.h" />
     <ClInclude Include="Bullet.h" />
     <ClInclude Include="Character.h" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 44)
+++ Source/Source.vcxproj.filters	(revision 45)
@@ -81,6 +81,7 @@
     <ClInclude Include="Bullet.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="AnimationDesc.h" />
     <ClInclude Include="Fireball.h">
       <Filter>Objects</Filter>
     </ClInclude>
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 44)
+++ Source/BaseLevelScene.cpp	(revision 45)
@@ -31,7 +31,6 @@
 	// Core scene update, including updating objects
 	Scene::update();
 	// Check for the player colliding with the tilemap
-	
 	checkPlyClsn();
 	BroadPhaseClsn();
 	CullDead();
@@ -59,7 +58,7 @@
 		m_pRenderer->DrawBoundingBox(spire->m_sAabb);
 		m_pRenderer->DrawBoundingBox(player->m_sAabb);
 		for (auto obj : objectList) {
-			if (obj->is("tower")) {
+			if (obj->getSpriteType() == TOWER1) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
 			}
 			if (obj->is("projectile")) {
@@ -136,7 +135,7 @@
 	// If the player is colliding, move them back
 	//check if player collides with a tower
 	for (auto obj : objectList) {
-		if (obj->is("tower")) {
+		if (obj->getSpriteType() == TOWER1) {
 			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
 		}
 	}
@@ -152,7 +151,7 @@
 	}
 	for (auto i : clsnBoxes) {
 		for (auto j : objectList) {
-			if (j->is("projectile") || j->is("fireball")) {
+			if (j->is("projectile")) {
 				if (j->m_sAabb.Intersects(i))
 					j->kill();
 			}
@@ -178,7 +177,6 @@
 				
 		}
 	}
-	
 }
 
 
Index: Source/AnimationDesc.h
===================================================================
--- Source/AnimationDesc.h	(nonexistent)
+++ Source/AnimationDesc.h	(revision 45)
@@ -0,0 +1,18 @@
+#include "GameDefines.h"
+
+#pragma once
+class AnimationDesc
+{
+public:
+	AnimationDesc(){}
+	AnimationDesc(eSpriteType sprite, int startFrame, int endFrame, float frameTime) :
+		sprite(sprite),
+		startFrame(startFrame),
+		endFrame(endFrame),
+		frameTime(frameTime) {}
+	eSpriteType sprite = BLACK_SQUARE;
+	int startFrame = 0;
+	int endFrame = 0;
+	float frameTime = 0.5;
+};
+
Index: Source/Bullet.h
===================================================================
--- Source/Bullet.h	(revision 44)
+++ Source/Bullet.h	(revision 45)
@@ -5,6 +5,5 @@
 {
 public:
     Bullet(Scene* scene, float x = 0, float y = 0, float z = 0);
-    void update() override;
 };
 
Index: Source/Character.h
===================================================================
--- Source/Character.h	(revision 44)
+++ Source/Character.h	(revision 45)
@@ -1,26 +1,30 @@
 #pragma once
+#include <map>
+#include <string>
 #include "GameObject.h"
+#include "AnimationDesc.h"
+
 class Character :
-    public GameObject
+	public GameObject
 {
 public:
 	Character(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
 	virtual ~Character() override;
-	virtual void animate(); // Animates the character and sets their sprite
 	void move(); // Move the character once based on their velocity
 	void unmove(); // Undo the character's last movement
 	float getAngle() { return angle; } // Get the current angle in degrees
 	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
 protected:
-	void _calcDirection();
-	Vector2 oldPos; // Stores the position from the previous frame
-	int direction = 0; // Stores the direction as a number 0-3
-	int subframe = 0; // Stores the frame, relative to the start of the direction
-	float subframe_time = 0.25; // Time when the subframe will next change
-	float subframe_interval = .5; // Time between subframes
-	int subframe_count = 4; // Number of subframes per animation
+	// Position & motion
+	Vector2 oldPosition; // Stores the position from the previous frame
 	float angle = 0; // Angle of the character in degrees
 	float speed = 0; // Speed of the character regardless of direction
 	Vector2 velocity = { 0,0 }; // Velocity of the character, accounts for direction
+
+	// Animations
+	map<string, AnimationDesc> animations;
+	string animationDirection = "SE"; // Characters only have 4 animation directions, NE, NW, SW, SE
+	void calculateAnimationDirection();
+	virtual void onChangedAnimationDirection();
 };
 
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 44)
+++ Source/GameObject.h	(revision 45)
@@ -5,6 +5,7 @@
 #include "SpriteDesc.h"
 #include "Common.h"
 #include "StepTimer.h"
+#include "AnimationDesc.h"
 
 // Forward declarations of classes that will exist
 // (We can't just include it b/c of circular dependency
@@ -18,20 +19,30 @@
 	virtual ~GameObject();
 	virtual void update(); // Method runs every tick/update
 
+	// Motion related methods
 	void setRoll(float angle);
 	float getRoll();
 	void setVel(const Vector2& v);
-	int getSpriteType();
 	const Vector2& getVel();
 	const Vector3& getPos();
+	bool inRadius(Vector3 pos, float dist);
 
+	// Description methods
+	int getSpriteType();
+	bool is(string tag); // Checks if the game object has a certain descriptor tag
+
+	// Animation methods
+	void startAnimation(const AnimationDesc& anim, bool loop = false);
+	void stepAnimation();
+	void stopAnimation();
+	bool isPlayingAnimation(const AnimationDesc& anim);
+	virtual void onAnimationComplete(const AnimationDesc& anim);
+
+	// Other methods
 	Vector2 getViewVect();
 	bool dead(); //true if dead, false otherwise
 	void kill(); // set isdead flag to true;
 
-	bool inRadius(Vector3 pos, float dist);
-	bool is(string tag); // Checks if the game object has a certain descriptor tag
-
 	void explode(); // particle effect for fireball explosion
 protected:
 	Scene* scene; // Scene which manages this object
@@ -38,6 +49,11 @@
 	Vector2 m_vVelocity = Vector2::Zero;
 	bool isDead = false;
 	unordered_set<string> tags;
+	// Animation related variables
+	AnimationDesc activeAnimation;
+	float animationTimer = 0;
+	bool isAnimating = false;
+	bool loopAnimation = false;
 	CParticleEngine3D* m_pParticleEngine = nullptr; ///< Pointer to a particle engine.
 };
 
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 44)
+++ Source/BadCharacter.h	(revision 45)
@@ -14,7 +14,6 @@
 	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
 	virtual ~BadCharacter() override;
 	virtual void update() override;
-	virtual void animate() override;
 	void setDestination(float x, float y);
 	void setDestinationID(string id);
 protected:
@@ -25,6 +24,7 @@
 	Vector2 dest = { 0,0 };
 	string destID = "";
 	float dist = 0; // Distance from the destination
+	void _updateAnimation();
 	void _updateDestination();
 	void _updateVelocity();
 };
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 44)
+++ Source/PlayerCharacter.h	(revision 45)
@@ -13,4 +13,6 @@
 private:
 	float shootCooldown = .25;
 	float shootTime = 0;
+	void onChangedAnimationDirection() override;
+	void _updateAnimation();
 };
Index: Source/Bullet.cpp
===================================================================
--- Source/Bullet.cpp	(revision 44)
+++ Source/Bullet.cpp	(revision 45)
@@ -6,12 +6,3 @@
 	tags.insert("projectile");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
 }
-
-void Bullet::update() {
-	const float t = m_pStepTimer->GetElapsedSeconds();
-	m_vPos.x += m_vVelocity.x * t;
-	m_vPos.y += m_vVelocity.y * t;	//update object position
-
-	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
-	m_sAabb.Center.y = m_vPos.y;
-}

------------------------------------------------------------------------
r46 | amm0837 | 2020-11-12 17:56:18 -0600 (Thu, 12 Nov 2020) | 1 line

changed tower's update and fire function to support multiple different tower types and bullet types.

Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 45)
+++ Source/Tower.h	(revision 46)
@@ -9,7 +9,7 @@
 	Tower(Scene* scene, float x, float y, float z);
 	void update() override;
 	GameObject* calcTarget();
-	void fire(GameObject* p);
+	void fire(GameObject* b);
 	void setRoll(float angle);
 	//void splashDmg();
 
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 45)
+++ Source/Tower.cpp	(revision 46)
@@ -17,7 +17,12 @@
 	//printf("update function for tower \n");
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
-		fire(this);
+		if (this->is("tower")) {		//add conditions for other towers here, set bullet type
+			Vector3 pos = this->getPos();
+			//creating bullet and setting its bounding box
+			GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z));
+			fire(b);
+		}
 	}
 
 	
@@ -49,15 +54,14 @@
 	return enemy;
 }
 
-void Tower::fire(GameObject* p) {
+void Tower::fire(GameObject* b) {
 	
-	Vector3 pos = p->getPos();
+	
 	//find target for tower
 	target = calcTarget();
 	if (target != nullptr) {
 		m_pAudio->play(GUN_SOUND);
-		//creating bullet and setting its bounding box
-		GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z));
+		
 
 		//set bullet direction to enemy direction
 		const Vector3 dir = b->getPos() - target->getPos();
@@ -64,7 +68,7 @@
 		b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
 		const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
 														//the direction of bullet velocity
-		b->setVel(p->getVel() + 500.0f * view);
+		b->setVel(500.0f * view);
 		b->setRoll(b->m_fRoll);
 	}
 

------------------------------------------------------------------------
r47 | jdg0393 | 2020-11-12 18:13:11 -0600 (Thu, 12 Nov 2020) | 1 line

Explosion animation for fireballs.

Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 46)
+++ Source/GameObject.h	(revision 47)
@@ -32,16 +32,16 @@
 	bool is(string tag); // Checks if the game object has a certain descriptor tag
 
 	// Animation methods
-	void startAnimation(const AnimationDesc& anim, bool loop = false);
+	void startAnimation(AnimationDesc& anim, bool loop = false);
 	void stepAnimation();
 	void stopAnimation();
-	bool isPlayingAnimation(const AnimationDesc& anim);
-	virtual void onAnimationComplete(const AnimationDesc& anim);
+	bool isPlayingAnimation(AnimationDesc& anim);
+	virtual void onAnimationComplete(AnimationDesc& anim);
 
 	// Other methods
 	Vector2 getViewVect();
 	bool dead(); //true if dead, false otherwise
-	void kill(); // set isdead flag to true;
+	virtual void kill(); // set isdead flag to true;
 
 	void explode(); // particle effect for fireball explosion
 protected:
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 46)
+++ Source/Renderer.cpp	(revision 47)
@@ -40,6 +40,7 @@
 	Load(SPIRE_PEAK, "spire_peak");
 	Load(TOWER1, "tower1");
 	Load(FIREBALL, "fireball");
+	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
 	// Load any additional fonts
 	loadNewFont("title_font");
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 46)
+++ Source/GameDefines.h	(revision 47)
@@ -22,6 +22,7 @@
 	SPIRE_PEAK,
 	TOWER1,
 	FIREBALL,
+	EXPLOSION,
 	SMOKE,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/Fireball.h
===================================================================
--- Source/Fireball.h	(revision 46)
+++ Source/Fireball.h	(revision 47)
@@ -1,6 +1,8 @@
 #pragma once
+#include "AnimationDesc.h"
 #include "GameObject.h"
 #include "Tower.h"
+
 class Fireball :
     public GameObject
 {
@@ -7,5 +9,8 @@
 public:
     Fireball(Scene* scene, float x = 0, float y = 0, float z = 0);
     void update() override;
-    
+    void kill() override;
+    void onAnimationComplete(AnimationDesc& anim) override;
+protected:
+    AnimationDesc explodeAnimation;
 };
\ No newline at end of file
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 46)
+++ Source/GameObject.cpp	(revision 47)
@@ -48,6 +48,7 @@
 void GameObject::kill() {
 	isDead = true;
 }
+
 bool GameObject::dead() {
 	return isDead;
 }
@@ -80,7 +81,7 @@
 	return tags.find(tag) != tags.end();
 }
 
-void GameObject::startAnimation(const AnimationDesc& anim, bool loop) {
+void GameObject::startAnimation(AnimationDesc& anim, bool loop) {
 	activeAnimation = anim;
 	isAnimating = true;
 	loopAnimation = loop;
@@ -119,16 +120,11 @@
 	loopAnimation = false;
 }
 
-void GameObject::onAnimationComplete(const AnimationDesc& anim) {
+void GameObject::onAnimationComplete(AnimationDesc& anim) {
 	//printf("Terminating Animation: %d\n", anim.sprite);
 	return;
 }
 
-bool GameObject::isPlayingAnimation(const AnimationDesc& anim) {
-	if (!isAnimating) return false;
-	if (activeAnimation.sprite != anim.sprite) return false;
-	if (activeAnimation.startFrame != anim.startFrame) return false;
-	if (activeAnimation.endFrame != anim.endFrame) return false;
-	if (activeAnimation.frameTime != anim.frameTime) return false;
-	return true;
+bool GameObject::isPlayingAnimation(AnimationDesc& anim) {
+	return isAnimating && activeAnimation == anim;
 }
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 46)
+++ Source/BaseLevelScene.cpp	(revision 47)
@@ -184,7 +184,7 @@
 	int sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
 		if (objectList[i]->dead()) {
-			printf("deleting object: %d\n", objectList[i]->getSpriteType());
+			//printf("deleting object: %d\n", objectList[i]->getSpriteType());
 			// If object is a baddie, remove it from the baddies list
 			if (objectList[i]->is("baddie")) {
 				for(int j = 0; j < baddies.size(); j++)
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 46)
+++ Source/Fireball.cpp	(revision 47)
@@ -5,9 +5,11 @@
 {
 	tags.insert("fireball");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
+	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15);
 }
 
 void Fireball::update() {
+	stepAnimation();
 	const float t = m_pStepTimer->GetElapsedSeconds();
 	m_vPos.x += m_vVelocity.x * t;
 	m_vPos.y += m_vVelocity.y * t;	//update object position
@@ -14,7 +16,16 @@
 
 	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
 	m_sAabb.Center.y = m_vPos.y;
-	
+
 }
 
+void Fireball::kill() {
+	startAnimation(explodeAnimation);
+	m_vVelocity = { 0,0,0 };
+	m_fXScale = 2.0;
+	m_fYScale = 2.0;
+}
 
+void Fireball::onAnimationComplete(AnimationDesc& anim) {
+	if (anim == explodeAnimation) isDead = true;
+}
\ No newline at end of file
Index: Source/AnimationDesc.h
===================================================================
--- Source/AnimationDesc.h	(revision 46)
+++ Source/AnimationDesc.h	(revision 47)
@@ -10,6 +10,13 @@
 		startFrame(startFrame),
 		endFrame(endFrame),
 		frameTime(frameTime) {}
+	bool operator==(AnimationDesc& other) {
+		if (sprite != other.sprite) return false;
+		if (startFrame != other.startFrame) return false;
+		if (endFrame != other.endFrame) return false;
+		if (frameTime != other.frameTime) return false;
+		return true;
+	}
 	eSpriteType sprite = BLACK_SQUARE;
 	int startFrame = 0;
 	int endFrame = 0;

------------------------------------------------------------------------
r48 | jdg0393 | 2020-11-12 18:57:46 -0600 (Thu, 12 Nov 2020) | 1 line

Fireballs die on map edge.

Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(revision 47)
+++ Source/Spire.h	(revision 48)
@@ -8,5 +8,9 @@
     int hp = 1000;
     Spire(Scene* scene, float x, float y, float z = 1.19);
     void update() override;
+    void onAnimationComplete(AnimationDesc& anim) override;
+protected:
+    AnimationDesc explodeAnimation;
+    GameObject* peak;
 };
 
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 47)
+++ Source/BaseLevelScene.cpp	(revision 48)
@@ -166,8 +166,7 @@
 			obj2->kill();
 			obj1->kill();
 		}
-		if (obj1->is("fireball") && obj2->is("baddie")) {	//when fireball intersects baddie, kill baddies within certain radius of fireball
-			obj1->kill();										//then kill fireball
+		if (obj1->is("explosive") && obj2->is("baddie")) {	//when fireball intersects baddie, kill baddies within certain radius of fireball
 			obj1->explode();
 			for (GameObject* obj : this->getBaddies()) {
 				if (obj->inRadius(obj1->getPos(), 50.0f)) {
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 47)
+++ Source/Fireball.cpp	(revision 48)
@@ -3,7 +3,8 @@
 Fireball::Fireball(Scene* scene, float x, float y, float z) :
 	GameObject(scene, FIREBALL, x, y, z)
 {
-	tags.insert("fireball");
+	tags.insert("projectile");
+	tags.insert("explosive");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
 	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15);
 }
@@ -20,7 +21,8 @@
 }
 
 void Fireball::kill() {
-	startAnimation(explodeAnimation);
+	if (!isPlayingAnimation(explodeAnimation))
+		startAnimation(explodeAnimation);
 	m_vVelocity = { 0,0,0 };
 	m_fXScale = 2.0;
 	m_fYScale = 2.0;
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 47)
+++ Source/Spire.cpp	(revision 48)
@@ -5,13 +5,24 @@
 Spire::Spire(Scene* scene, float x, float y, float z) :
 	GameObject(scene, SPIRE_BASE, x, y, z) {
 	m_sAabb = BoundingBox({ x, y + 6, z }, { 64, 26, 32 });
-	scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z-.1));
+	peak = scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z-.1));
+	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15);
 }
 
 void Spire::update()
 {
+	stepAnimation();
 	if (hp <= 0) {
-		m_fAlpha = 0;
+		startAnimation(explodeAnimation);
+		m_fXScale = 12.0;
+		m_fYScale = 12.0;
+		peak->m_fAlpha = 0;
 		((BaseLevelScene*)scene)->endGame();
 	}
+}
+
+void Spire::onAnimationComplete(AnimationDesc& anim) {
+	if (anim == explodeAnimation) {
+		m_fAlpha = 0;
+	}
 }
\ No newline at end of file

------------------------------------------------------------------------
r49 | jdg0393 | 2020-11-13 02:07:52 -0600 (Fri, 13 Nov 2020) | 1 line

Created a HUD system, health bar for Spire.

Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 48)
+++ Source/Fireball.cpp	(revision 49)
@@ -21,8 +21,7 @@
 }
 
 void Fireball::kill() {
-	if (!isPlayingAnimation(explodeAnimation))
-		startAnimation(explodeAnimation);
+	startAnimation(explodeAnimation);
 	m_vVelocity = { 0,0,0 };
 	m_fXScale = 2.0;
 	m_fYScale = 2.0;
@@ -29,5 +28,5 @@
 }
 
 void Fireball::onAnimationComplete(AnimationDesc& anim) {
-	if (anim == explodeAnimation) isDead = true;
+	if (anim == explodeAnimation) willCull = true;
 }
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 48)
+++ Source/BaseLevelScene.cpp	(revision 49)
@@ -1,6 +1,7 @@
 #include "BaseLevelScene.h"
 #include "Game.h"
 #include "Random.h"
+#include "HUDObject.h"
 
 BaseLevelScene::BaseLevelScene(CGame* game) :
 	TiledScene(game) {}
@@ -17,6 +18,8 @@
 	// Create the simple tilemap
 	loadTileMap("simple", SIMPLE_TILE);
 	backgroundSprite->m_vPos = { (tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, 10 };
+	backgroundSprite->m_fYScale = backgroundSprite->m_fYScale * 1.5;
+	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5;
 	// Place the player on the map
 	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, paths["plySpawn"].x, paths["plySpawn"].y));
 	// Set the camera to follow the player
@@ -33,10 +36,13 @@
 	// Check for the player colliding with the tilemap
 	checkPlyClsn();
 	BroadPhaseClsn();
-	CullDead();
 	// Update the camera position if we're following the player
 	if (followTarget)
 		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 1.5));
+	// After changing camera position, make sure to adjust any HUD elements
+	adjustHUD();
+	// Delete objects that need to be culled
+	cullObjects();
 	// Check end of game conditions
 	if (gameOver && m_pStepTimer->GetTotalSeconds() > endTime) {
 		m_pAudio->stop();
@@ -70,8 +76,10 @@
 		}
 	}
 	if (!gameOver) {
-		string hpString = "Spire Hit Points: " + to_string(spire->hp) + "/1000";
-		m_pRenderer->DrawScreenText(hpString.c_str(), { 920, 10 }, Colors::White);
+		//string hpString = "Spire Hit Points: " + to_string(spire->hp) + "/1000";
+		string hpString = "Spire";
+		float offset = hpString.size() * 7.5f;
+		m_pRenderer->DrawScreenText(hpString.c_str(), { 640 - offset, 26 }, Colors::White);
 	}
 	else {
 		m_pRenderer->setFont("title_font");
@@ -116,7 +124,7 @@
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('T')) {
 		Vector3 pos = player->getPos();
-		addObject(new Tower(this, pos.x, pos.y-32, 1.14));
+		addObject(new Tower(this, pos.x, pos.y - 32, 1.14));
 	}
 
 	if (m_pKeyboard->TriggerDown('X')) {
@@ -173,31 +181,26 @@
 					obj->kill();
 				}
 			}
-				
+
 		}
 	}
 }
 
-
-void BaseLevelScene::CullDead() {
+void BaseLevelScene::cullObjects() {
 	int sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
-		if (objectList[i]->dead()) {
-			//printf("deleting object: %d\n", objectList[i]->getSpriteType());
+		if (objectList[i]->getWillCull()) {
 			// If object is a baddie, remove it from the baddies list
 			if (objectList[i]->is("baddie")) {
-				for(int j = 0; j < baddies.size(); j++)
+				for (int j = 0; j < baddies.size(); j++)
 					if (objectList[i] == baddies[j]) {
 						baddies.erase(baddies.begin() + j);
 						break;
 					}
 			}
-			// This deletes the object and removes it's reference from objectList
-			deleteObject(objectList[i]);
-			// Adjust size since vector resized during processing
-			sz = objectList.size();
 		}
 	}
+	Scene::cullObjects();
 }
 
 // Provides the player character pointer
@@ -252,32 +255,32 @@
 	{
 		// Left-Up
 		if (m_pKeyboard->Down('W'))
-			player->setVelocity(100, 135);
+			player->setVelocity(player->getMaxSpeed(), 135);
 		// Left-Down
 		else if (m_pKeyboard->Down('S'))
-			player->setVelocity(100, 225);
+			player->setVelocity(player->getMaxSpeed(), 225);
 		// Left
 		else
-			player->setVelocity(100, 180);
+			player->setVelocity(player->getMaxSpeed(), 180);
 	}
 	else if (m_pKeyboard->Down('D'))
 	{
 		// Right-Up
 		if (m_pKeyboard->Down('W'))
-			player->setVelocity(100, 45);
+			player->setVelocity(player->getMaxSpeed(), 45);
 		// Right-Down
 		else if (m_pKeyboard->Down('S'))
-			player->setVelocity(100, 315);
+			player->setVelocity(player->getMaxSpeed(), 315);
 		// Right
 		else
-			player->setVelocity(100, 0);
+			player->setVelocity(player->getMaxSpeed(), 0);
 	}
 	// Down
 	else if (m_pKeyboard->Down('S'))
-		player->setVelocity(100, 270);
+		player->setVelocity(player->getMaxSpeed(), 270);
 	// Up
 	else if (m_pKeyboard->Down('W'))
-		player->setVelocity(100, 90);
+		player->setVelocity(player->getMaxSpeed(), 90);
 	// No movement
 	else
 		player->setVelocity(0, player->getAngle());
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 48)
+++ Source/Source.vcxproj.filters	(revision 49)
@@ -41,6 +41,9 @@
     <ClCompile Include="Fireball.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="HUDObject.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -85,6 +88,9 @@
     <ClInclude Include="Fireball.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="HUDObject.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(revision 48)
+++ Source/Spire.h	(revision 49)
@@ -1,16 +1,19 @@
 #pragma once
 #include "GameObject.h"
+#include "HUDObject.h"
 
 class Spire :
     public GameObject
 {
 public:
-    int hp = 1000;
+    int hp;
     Spire(Scene* scene, float x, float y, float z = 1.19);
     void update() override;
     void onAnimationComplete(AnimationDesc& anim) override;
 protected:
+    int maxHP = 1000;
     AnimationDesc explodeAnimation;
     GameObject* peak;
+    HUDObject* healthBar;
 };
 
Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 48)
+++ Source/Scene.h	(revision 49)
@@ -6,6 +6,7 @@
 #include "GameDefines.h"
 #include "Renderer.h"
 #include "GameObject.h"
+#include "HUDObject.h"
 
 // Forward declarations of classes that will exist
 // (We can't just include it b/c of circular dependency
@@ -22,10 +23,16 @@
 	virtual void update();
 	virtual void render();
 	GameObject* addObject(GameObject* obj);// Adds an object to the list
-	void deleteObject(GameObject* object);//Remove an object from the scene, mainly to allow the user to destroy a misplaced tower
+	HUDObject* addObject(HUDObject* obj);// Adds a special hud object to the hud list
+	void deleteObject(GameObject* object);// Remove an object from the scene, mainly to allow the user to destroy a misplaced tower
+	void deleteObject(HUDObject* object);// Remove an object from the scene, mainly to allow the user to destroy a misplaced tower
+	void adjustHUD(); // Re-position and re-scale all hud elements for the camera
+	// Delete all objects flagged to be culled (often safer to do all at once at end of step, rather than delete 1 by 1)
+	virtual void cullObjects();
 protected:
 	CGame* game; // Reference to game which created this scene
 	std::vector<GameObject*> objectList; // Game objects managed by this scene
+	vector<HUDObject*> hud; // HUD objects that scale to screen
 	GameObject* backgroundSprite = nullptr;
 };
 
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 48)
+++ Source/GameObject.h	(revision 49)
@@ -40,7 +40,7 @@
 
 	// Other methods
 	Vector2 getViewVect();
-	bool dead(); //true if dead, false otherwise
+	bool getWillCull(); //true if dead, false otherwise
 	virtual void kill(); // set isdead flag to true;
 
 	void explode(); // particle effect for fireball explosion
@@ -47,7 +47,7 @@
 protected:
 	Scene* scene; // Scene which manages this object
 	Vector2 m_vVelocity = Vector2::Zero;
-	bool isDead = false;
+	bool willCull = false;
 	unordered_set<string> tags;
 	// Animation related variables
 	AnimationDesc activeAnimation;
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 48)
+++ Source/Renderer.cpp	(revision 49)
@@ -33,6 +33,7 @@
 	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(HUMAN_IDLE, "human_idle");
+	Load(HUMAN_WALK, "human_walk");
 	Load(GOBLIN_WALK, "goblin_walk");
 	Load(GOBLIN_ATTACK, "goblin_attack");
 	Load(BULLET1, "bullet1");
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 48)
+++ Source/GameDefines.h	(revision 49)
@@ -15,6 +15,7 @@
 	GREENLINE_SPRITE,
 	SIMPLE_TILE,
 	HUMAN_IDLE,
+	HUMAN_WALK,
 	GOBLIN_WALK,
 	GOBLIN_ATTACK,
 	BULLET1,
Index: Source/HUDObject.h
===================================================================
--- Source/HUDObject.h	(nonexistent)
+++ Source/HUDObject.h	(revision 49)
@@ -0,0 +1,28 @@
+#pragma once
+#include "SpriteDesc.h"
+#include "GameObject.h"
+
+class HUDObject :
+    public CSpriteDesc3D, CCommon
+{
+public:
+    HUDObject(Scene* scene, eSpriteType spriteKey, float xPercentage, float yPercentage, float relativeZ);
+    // Correct the position of HUD object based on camera
+    // May be called separately from update() in case camera adjusts after update()
+    void adjust(); 
+    // X coordinate as a percentage of the HUD width, relative to the center of camera
+    float xPercentage;
+    // Y coordinate as a percentage of the HUD height, relative to the center of camera
+    float yPercentage;
+    // Relative Z coordinate from the base HUD Z value
+    float relativeZ;
+    // Scale relative to the position of the camera
+    float relativeXScale;
+    float relativeYScale;
+protected:
+    Scene* scene = nullptr;
+    const float xMaxScale = .39;
+    const float yMaxScale = .22;
+    const float zBaseScale = .00095;
+};
+
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 48)
+++ Source/PlayerCharacter.h	(revision 49)
@@ -10,9 +10,10 @@
 	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15);
 	void update() override; // Character's update loop, runs every frame
 	void shoot(float speed, float angle_in_degrees);
+	float getMaxSpeed() { return maxSpeed; }
 private:
 	float shootCooldown = .25;
 	float shootTime = 0;
-	void onChangedAnimationDirection() override;
+	float maxSpeed = 250;
 	void _updateAnimation();
 };
Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(revision 48)
+++ Source/TiledScene.cpp	(revision 49)
@@ -17,6 +17,14 @@
 		renders.push_back(objAsSprite);
 	}
 
+	// Add every hud object to render list
+	for (auto obj : hud) {
+		// Object needs to be treated as a sprite descriptor
+		CSpriteDesc3D* objAsSprite = obj;
+		// Draw the object
+		renders.push_back(objAsSprite);
+	}
+
 	// Add each layer of the tilemap to render list
 	for (TileLayer& layer : layers) {
 		for (vector<CSpriteDesc3D>& row : layer) {
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 48)
+++ Source/Spire.cpp	(revision 49)
@@ -4,9 +4,12 @@
 
 Spire::Spire(Scene* scene, float x, float y, float z) :
 	GameObject(scene, SPIRE_BASE, x, y, z) {
+	hp = maxHP;
 	m_sAabb = BoundingBox({ x, y + 6, z }, { 64, 26, 32 });
-	peak = scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z-.1));
+	peak = scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z - .1));
 	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15);
+	healthBar = scene->addObject(new HUDObject(scene, GREENLINE_SPRITE, 0, 0.9, 0));
+	healthBar->relativeYScale = 10.0f;
 }
 
 void Spire::update()
@@ -14,11 +17,13 @@
 	stepAnimation();
 	if (hp <= 0) {
 		startAnimation(explodeAnimation);
+		m_vPos = { m_vPos.x, m_vPos.y , -5 };
 		m_fXScale = 12.0;
 		m_fYScale = 12.0;
 		peak->m_fAlpha = 0;
 		((BaseLevelScene*)scene)->endGame();
 	}
+	healthBar->relativeXScale = (hp / (float)maxHP) * 350.0f;
 }
 
 void Spire::onAnimationComplete(AnimationDesc& anim) {
@@ -25,4 +30,4 @@
 	if (anim == explodeAnimation) {
 		m_fAlpha = 0;
 	}
-}
\ No newline at end of file
+}
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 48)
+++ Source/BaseLevelScene.h	(revision 49)
@@ -30,11 +30,12 @@
 
 	void BroadPhaseClsn();
 	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
-	void WallCollision();
-	void CullDead(); //finds objects with isDead = true, remove from objlist and deallocate pointer
+	void cullObjects() override; //finds objects with isDead = true, remove from objlist and deallocate pointer
 	void endGame();
 	void spawnBaddie();
 
+	bool getGameOver() { return gameOver; }
+
 private:
 	bool gameOver = false;
 	float endTime = 0;
@@ -43,8 +44,8 @@
 	Spire* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character
 	vector<BadCharacter*> baddies;
+	GameObject* followTarget = nullptr; // What the camera follows
 	Vector3 defPos; // Default "true size" camera position
-	GameObject* followTarget = nullptr; // What the camera follows
 	bool shouldFollow = false; // Whether the camera is following
 	void handleKeyboard(); // Handler for the keyboard
 	void _handleMoveKeys(); // Internal function used by keyboard handler
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 48)
+++ Source/Scene.cpp	(revision 49)
@@ -17,6 +17,12 @@
 	}
 	// Clear out all items in the object list
 	objectList.clear();
+	// Delete every element of the hud list
+	for (auto obj : hud) {
+		delete obj;
+	}
+	// Clear out all items in the hud list
+	hud.clear();
 }
 
 // Method where objects, tiles, etc should be created
@@ -49,6 +55,14 @@
 		renders.push_back(objAsSprite);
 	}
 
+	// Add every hud object to render list
+	for (auto obj : hud) {
+		// Object needs to be treated as a sprite descriptor
+		CSpriteDesc3D* objAsSprite = obj;
+		// Draw the object
+		renders.push_back(objAsSprite);
+	}
+
 	// Depth sort the render list
 	stable_sort(renders.begin(), renders.end(), [](CSpriteDesc3D* a, CSpriteDesc3D* b) {
 		return a->m_vPos.z > b->m_vPos.z;
@@ -70,6 +84,11 @@
 	return obj;
 }
 
+HUDObject* Scene::addObject(HUDObject* obj) {
+	hud.push_back(obj);
+	return obj;
+}
+
 // param object is the object to be deleted. Removes object from objectlist and frees memory
 void Scene::deleteObject(GameObject* object) {
 	for (std::vector<GameObject*>::iterator it = objectList.begin(); it != objectList.end(); it++) {
@@ -80,3 +99,31 @@
 	}
 	delete object;
 }
+
+void Scene::deleteObject(HUDObject* object) {
+	for (std::vector<HUDObject*>::iterator it = hud.begin(); it != hud.end(); it++) {
+		if (*it == object) {
+			hud.erase(it);
+			break;
+		}
+	}
+	delete object;
+}
+
+void Scene::adjustHUD() {
+	for (auto obj : hud) {
+		obj->adjust();
+	}
+}
+
+void Scene::cullObjects() {
+	int sz = objectList.size();
+	for (int i = 0; i < sz; i++) {
+		if (objectList[i]->getWillCull()) {
+			// This deletes the object and removes it's reference from objectList
+			deleteObject(objectList[i]);
+			// Adjust size since vector resized during processing
+			sz = objectList.size();
+		}
+	}
+}
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 48)
+++ Source/GameObject.cpp	(revision 49)
@@ -14,7 +14,6 @@
 }
 
 void GameObject::update() {
-	//printf("GameObject::update()\n");
 	stepAnimation();
 
 	const float t = m_pStepTimer->GetElapsedSeconds();
@@ -34,7 +33,7 @@
 void GameObject::explode() {
 	//TODO: smoke effect is not appearing for some reason
 	const Vector3 pos = this->getPos();
-	printf("smoke effect\n");
+	printf("Smoke effect should play?\n");
 	CParticleDesc3D dExplosion;
 	dExplosion.m_nSpriteIndex = SMOKE;
 	dExplosion.m_vPos = pos;
@@ -46,11 +45,11 @@
 }
 
 void GameObject::kill() {
-	isDead = true;
+	willCull = true;
 }
 
-bool GameObject::dead() {
-	return isDead;
+bool GameObject::getWillCull() {
+	return willCull;
 }
 
 void GameObject::setRoll(float angle) {
@@ -82,12 +81,14 @@
 }
 
 void GameObject::startAnimation(AnimationDesc& anim, bool loop) {
-	activeAnimation = anim;
-	isAnimating = true;
-	loopAnimation = loop;
-	m_nSpriteIndex = activeAnimation.sprite;
-	m_nCurrentFrame = activeAnimation.startFrame;
-	animationTimer = m_pStepTimer->GetTotalSeconds() + activeAnimation.frameTime;
+	if (!isPlayingAnimation(anim)) {
+		activeAnimation = anim;
+		isAnimating = true;
+		loopAnimation = loop;
+		m_nSpriteIndex = activeAnimation.sprite;
+		m_nCurrentFrame = activeAnimation.startFrame;
+		animationTimer = m_pStepTimer->GetTotalSeconds() + activeAnimation.frameTime;
+	}
 }
 
 void GameObject::stepAnimation() {
@@ -121,7 +122,6 @@
 }
 
 void GameObject::onAnimationComplete(AnimationDesc& anim) {
-	//printf("Terminating Animation: %d\n", anim.sprite);
 	return;
 }
 
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 48)
+++ Source/Tower.cpp	(revision 49)
@@ -14,7 +14,6 @@
 
 }
 void Tower::update() {
-	//printf("update function for tower \n");
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
 		if (this->is("tower")) {		//add conditions for other towers here, set bullet type
@@ -47,6 +46,7 @@
 		}
 
 	}
+
 	if (((BaseLevelScene*)scene)->getBaddies().size() == 0){
 		return nullptr;
 	}
@@ -59,7 +59,9 @@
 	
 	//find target for tower
 	target = calcTarget();
+
 	if (target != nullptr) {
+
 		m_pAudio->play(GUN_SOUND);
 		
 
@@ -71,6 +73,9 @@
 		b->setVel(500.0f * view);
 		b->setRoll(b->m_fRoll);
 	}
+	else {
+		scene->deleteObject(b);
+	}
 
 }
 void Tower::setRoll(float angle) {
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 48)
+++ Source/BadCharacter.cpp	(revision 49)
@@ -31,13 +31,26 @@
 	stepAnimation();
 	// Set the bad guy's destination
 	_updateDestination();
-	// Attack the tower, under the right conditions
-	if (destID == "end" && m_sAabb.Intersects(level->getSpire()->m_sAabb)) {
+	// Check if the game is over
+	if (level->getGameOver()) {
+		stopped = true;
+		attacking = false;
+		if (m_fAlpha > 0) {
+			// Fade the bad guy out on game over
+			m_fAlpha -= .01;
+		}
+		else {
+			// Destroy this creature once it's faded out
+			kill();
+		}
+	}
+	// If targeting the tower and within range, attack it!
+	else if (destID == "end" && m_sAabb.Intersects(level->getSpire()->m_sAabb)) {
 		Vector2 spire = level->getSpire()->getPos();
 		stopped = true;
 		attacking = true;
 		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
-			((BaseLevelScene*)scene)->getSpire()->hp -= 20;
+			level->getSpire()->hp -= 20;
 			cooldown_time = m_pStepTimer->GetTotalSeconds() + cooldown;
 		}
 	}
Index: Source/HUDObject.cpp
===================================================================
--- Source/HUDObject.cpp	(nonexistent)
+++ Source/HUDObject.cpp	(revision 49)
@@ -0,0 +1,27 @@
+#include "HUDObject.h"
+#include "Renderer.h"
+
+HUDObject::HUDObject(Scene* scene, eSpriteType spriteKey, float xPercentage, float yPercentage, float relativeZ)
+{
+	this->scene = scene;
+	this->m_nSpriteIndex = spriteKey;
+	this->xPercentage = xPercentage;
+	this->yPercentage = yPercentage;
+	this->relativeZ = relativeZ;
+	relativeXScale = 1.0f;
+	relativeYScale = 1.0f;
+	adjust();
+}
+
+void HUDObject::adjust() {
+	Vector3 cameraPos = m_pRenderer->GetCameraPos();
+	float cameraZ = abs(cameraPos.z);
+
+	m_vPos = {
+		cameraPos.x + xPercentage * xMaxScale * cameraZ,
+		cameraPos.y + yPercentage * yMaxScale * cameraZ,
+		-5 + relativeZ
+	};
+	m_fXScale = relativeXScale * zBaseScale * cameraZ;
+	m_fYScale = relativeYScale * zBaseScale * cameraZ;
+}
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 48)
+++ Source/Source.vcxproj	(revision 49)
@@ -171,6 +171,7 @@
     <ClCompile Include="Fireball.cpp" />
     <ClCompile Include="Game.cpp" />
     <ClCompile Include="GameObject.cpp" />
+    <ClCompile Include="HUDObject.cpp" />
     <ClCompile Include="Main.cpp" />
     <ClCompile Include="PlayerCharacter.cpp" />
     <ClCompile Include="Renderer.cpp" />
@@ -191,6 +192,7 @@
     <ClInclude Include="Game.h" />
     <ClInclude Include="GameDefines.h" />
     <ClInclude Include="GameObject.h" />
+    <ClInclude Include="HUDObject.h" />
     <ClInclude Include="PlayerCharacter.h" />
     <ClInclude Include="Renderer.h" />
     <ClInclude Include="Scene.h" />
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 48)
+++ Source/PlayerCharacter.cpp	(revision 49)
@@ -13,10 +13,10 @@
 	animations["IDLE_NW"] = AnimationDesc(HUMAN_IDLE, 4, 7, 0.15);
 	animations["IDLE_SW"] = AnimationDesc(HUMAN_IDLE, 8, 11, 0.15);
 	animations["IDLE_SE"] = AnimationDesc(HUMAN_IDLE, 12, 15, 0.15);
-	//animations["WALK_NE"] = AnimationDesc(HUMAN_WALK, 0, 3, 0.15);
-	//animations["WALK_NW"] = AnimationDesc(HUMAN_WALK, 4, 7, 0.15);
-	//animations["WALK_SW"] = AnimationDesc(HUMAN_WALK, 8, 11, 0.15);
-	//animations["WALK_SE"] = AnimationDesc(HUMAN_WALK, 12, 15, 0.15);
+	animations["WALK_NE"] = AnimationDesc(HUMAN_WALK, 0, 3, 0.15);
+	animations["WALK_NW"] = AnimationDesc(HUMAN_WALK, 4, 7, 0.15);
+	animations["WALK_SW"] = AnimationDesc(HUMAN_WALK, 8, 11, 0.15);
+	animations["WALK_SE"] = AnimationDesc(HUMAN_WALK, 12, 15, 0.15);
 	startAnimation(animations["IDLE_SE"], true);
 }
 
@@ -24,9 +24,10 @@
 	//printf("PlayerCharacter::update()");
 	// Animate the character
 	stepAnimation();
+	// Move the character
 	move();
-	// Calculate the animation direction
-	calculateAnimationDirection();
+	// Update which animation is currently playing
+	_updateAnimation();
 }
 
 void PlayerCharacter::shoot(float speed, float angle_in_degrees) {
@@ -47,12 +48,15 @@
 	}
 }
 
-void PlayerCharacter::onChangedAnimationDirection() {
-	// When we change directions, change animation
-	_updateAnimation();
-}
+void PlayerCharacter::_updateAnimation() {
+	string key = "";
 
-void PlayerCharacter::_updateAnimation() {
-	string key = "IDLE_" + animationDirection;
-	startAnimation(animations[key], true);
+	if (speed > 0) key += "WALK_";
+	else key += "IDLE_";
+
+	calculateAnimationDirection();
+	key += animationDirection;
+
+	if(!isPlayingAnimation(animations[key]))
+		startAnimation(animations[key], true);
 }
\ No newline at end of file
Index: Source/Renderer.h
===================================================================
--- Source/Renderer.h	(revision 48)
+++ Source/Renderer.h	(revision 49)
@@ -8,6 +8,8 @@
 	in mind what our game standardly expects for depths, as well as the general scale
 	and everything of depths between objects. Here is an ordered list.
 
+	-5
+		-5.0 -> HUD Objects
 	1
 		1.0
 			1.09 -> Spire Peak

------------------------------------------------------------------------
r50 | jdg0393 | 2020-11-13 21:57:58 -0600 (Fri, 13 Nov 2020) | 1 line

Decorative hats and multiple types of player characters.

Index: Source/Character.h
===================================================================
--- Source/Character.h	(revision 49)
+++ Source/Character.h	(revision 50)
@@ -10,8 +10,8 @@
 public:
 	Character(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
 	virtual ~Character() override;
-	void move(); // Move the character once based on their velocity
-	void unmove(); // Undo the character's last movement
+	virtual void move(); // Move the character once based on their velocity
+	virtual void unmove(); // Undo the character's last movement
 	float getAngle() { return angle; } // Get the current angle in degrees
 	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
 protected:
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 49)
+++ Source/Tower.h	(revision 50)
@@ -6,7 +6,7 @@
 
 class Tower : public GameObject {
 public:
-	Tower(Scene* scene, float x, float y, float z);
+	Tower(Scene* scene, float x, float y, float z=1.14);
 	void update() override;
 	GameObject* calcTarget();
 	void fire(GameObject* b);
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 49)
+++ Source/Source.vcxproj	(revision 50)
@@ -181,6 +181,8 @@
     <ClCompile Include="TiledScene.cpp" />
     <ClCompile Include="TitleScreenScene.cpp" />
     <ClCompile Include="Tower.cpp" />
+    <ClCompile Include="VikingPlayer.cpp" />
+    <ClCompile Include="WizardPlayer.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="AnimationDesc.h" />
@@ -202,6 +204,8 @@
     <ClInclude Include="TiledScene.h" />
     <ClInclude Include="TitleScreenScene.h" />
     <ClInclude Include="Tower.h" />
+    <ClInclude Include="VikingPlayer.h" />
+    <ClInclude Include="WizardPlayer.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/VikingPlayer.h
===================================================================
--- Source/VikingPlayer.h	(nonexistent)
+++ Source/VikingPlayer.h	(revision 50)
@@ -0,0 +1,11 @@
+#pragma once
+#include "PlayerCharacter.h"
+class VikingPlayer :
+    public PlayerCharacter
+{
+public:
+    VikingPlayer(Scene* scene, float x, float y, float z = 1.15);
+protected:
+    GameObject* _createProjectile() override;
+};
+
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 49)
+++ Source/GameDefines.h	(revision 50)
@@ -14,6 +14,8 @@
 	TITLE_SCREEN,
 	GREENLINE_SPRITE,
 	SIMPLE_TILE,
+	VIKING_HAT,
+	WIZARD_HAT,
 	HUMAN_IDLE,
 	HUMAN_WALK,
 	GOBLIN_WALK,
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 49)
+++ Source/PlayerCharacter.h	(revision 50)
@@ -9,11 +9,15 @@
 public:
 	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15);
 	void update() override; // Character's update loop, runs every frame
-	void shoot(float speed, float angle_in_degrees);
+	void shoot(float angle_in_degrees);
 	float getMaxSpeed() { return maxSpeed; }
-private:
-	float shootCooldown = .25;
-	float shootTime = 0;
-	float maxSpeed = 250;
+protected:
+	float shootCooldown;
+	float shootTime;
+	float projectileSpeed;
+	float maxSpeed;
+	GameObject* hat = nullptr;
+	virtual GameObject* _createProjectile();
 	void _updateAnimation();
+	void _updateHat();
 };
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 49)
+++ Source/Source.vcxproj.filters	(revision 50)
@@ -11,9 +11,6 @@
     <ClCompile Include="GameObject.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
-    <ClCompile Include="PlayerCharacter.cpp">
-      <Filter>Objects</Filter>
-    </ClCompile>
     <ClCompile Include="Tower.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
@@ -44,6 +41,15 @@
     <ClCompile Include="HUDObject.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="PlayerCharacter.cpp">
+      <Filter>Objects\Players</Filter>
+    </ClCompile>
+    <ClCompile Include="WizardPlayer.cpp">
+      <Filter>Objects\Players</Filter>
+    </ClCompile>
+    <ClCompile Include="VikingPlayer.cpp">
+      <Filter>Objects\Players</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -57,9 +63,6 @@
     <ClInclude Include="GameObject.h">
       <Filter>Objects</Filter>
     </ClInclude>
-    <ClInclude Include="PlayerCharacter.h">
-      <Filter>Objects</Filter>
-    </ClInclude>
     <ClInclude Include="Tower.h">
       <Filter>Objects</Filter>
     </ClInclude>
@@ -91,6 +94,15 @@
     <ClInclude Include="HUDObject.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="PlayerCharacter.h">
+      <Filter>Objects\Players</Filter>
+    </ClInclude>
+    <ClInclude Include="WizardPlayer.h">
+      <Filter>Objects\Players</Filter>
+    </ClInclude>
+    <ClInclude Include="VikingPlayer.h">
+      <Filter>Objects\Players</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
@@ -102,5 +114,8 @@
     <Filter Include="Objects">
       <UniqueIdentifier>{fcfe40d0-0668-4e21-8f93-1a01eff0808a}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Objects\Players">
+      <UniqueIdentifier>{b5c7cfe7-d5cc-4799-b634-54a321244af7}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 49)
+++ Source/BaseLevelScene.cpp	(revision 50)
@@ -2,6 +2,8 @@
 #include "Game.h"
 #include "Random.h"
 #include "HUDObject.h"
+#include "VikingPlayer.h"
+#include "WizardPlayer.h"
 
 BaseLevelScene::BaseLevelScene(CGame* game) :
 	TiledScene(game) {}
@@ -21,7 +23,7 @@
 	backgroundSprite->m_fYScale = backgroundSprite->m_fYScale * 1.5;
 	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5;
 	// Place the player on the map
-	player = (PlayerCharacter*)addObject(new PlayerCharacter(this, paths["plySpawn"].x, paths["plySpawn"].y));
+	player = (PlayerCharacter*)addObject(new WizardPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
 	// Set the camera to follow the player
 	camFollowVision(player);
 	// Create the spire object
@@ -124,7 +126,7 @@
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('T')) {
 		Vector3 pos = player->getPos();
-		addObject(new Tower(this, pos.x, pos.y - 32, 1.14));
+		addObject(new Tower(this, pos.x, pos.y - 32));
 	}
 
 	if (m_pKeyboard->TriggerDown('X')) {
@@ -247,8 +249,6 @@
 	baddies[baddies.size() - 1]->setDestinationID(sp);
 }
 
-
-
 void BaseLevelScene::_handleMoveKeys() {
 	// Moving of the character
 	if (m_pKeyboard->Down('A'))
@@ -292,30 +292,30 @@
 	{
 		// Left-Up
 		if (m_pKeyboard->Down(VK_UP))
-			player->shoot(300, 135);
+			player->shoot(135);
 		// Left-Down
 		else if (m_pKeyboard->Down(VK_DOWN))
-			player->shoot(300, 225);
+			player->shoot(225);
 		// Left
 		else
-			player->shoot(300, 180);
+			player->shoot(180);
 	}
 	else if (m_pKeyboard->Down(VK_RIGHT))
 	{
 		// Right-Up
 		if (m_pKeyboard->Down(VK_UP))
-			player->shoot(300, 45);
+			player->shoot(45);
 		// Right-Down
 		else if (m_pKeyboard->Down(VK_DOWN))
-			player->shoot(300, 315);
+			player->shoot(315);
 		// Right
 		else
-			player->shoot(300, 0);
+			player->shoot(0);
 	}
 	// Down
 	else if (m_pKeyboard->Down(VK_DOWN))
-		player->shoot(300, 270);
+		player->shoot(270);
 	// Up
 	else if (m_pKeyboard->Down(VK_UP))
-		player->shoot(300, 90);
+		player->shoot(90);
 }
Index: Source/WizardPlayer.h
===================================================================
--- Source/WizardPlayer.h	(nonexistent)
+++ Source/WizardPlayer.h	(revision 50)
@@ -0,0 +1,11 @@
+#pragma once
+#include "PlayerCharacter.h"
+class WizardPlayer :
+    public PlayerCharacter
+{
+public:
+    WizardPlayer(Scene* scene, float x, float y, float z = 1.15);
+protected:
+    GameObject* _createProjectile() override;
+};
+
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 49)
+++ Source/Tower.cpp	(revision 50)
@@ -3,7 +3,7 @@
 #include "Fireball.h"
 
 
-Tower::Tower(Scene* scene, float x = 0, float y = 0, float z = 0) :
+Tower::Tower(Scene* scene, float x, float y, float z) :
 	GameObject(scene, TOWER1, x, y, z)
 {
 	objScene = scene;
@@ -23,8 +23,6 @@
 			fire(b);
 		}
 	}
-
-	
 }
 
 GameObject* Tower::calcTarget() {
Index: Source/VikingPlayer.cpp
===================================================================
--- Source/VikingPlayer.cpp	(nonexistent)
+++ Source/VikingPlayer.cpp	(revision 50)
@@ -0,0 +1,19 @@
+#include "VikingPlayer.h"
+#include "Scene.h"
+#include "Bullet.h"
+
+VikingPlayer::VikingPlayer(Scene* scene, float x, float y, float z) :
+	PlayerCharacter(scene, x, y, z)
+{
+	hat = scene->addObject(new GameObject(scene, VIKING_HAT, m_vPos.x, m_vPos.y, m_vPos.z));
+	maxSpeed = 250;
+	// Projectile usage qualities
+	shootCooldown = .25;
+	shootTime = 0;
+	projectileSpeed = 400;
+}
+
+// Creates the fireball as the projectile
+GameObject* VikingPlayer::_createProjectile() {
+	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005));
+}
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 49)
+++ Source/Renderer.cpp	(revision 50)
@@ -32,6 +32,8 @@
 	Load(TITLE_SCREEN, "title_screen");
 	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
+	Load(VIKING_HAT, "viking_hat");
+	Load(WIZARD_HAT, "wizard_hat");
 	Load(HUMAN_IDLE, "human_idle");
 	Load(HUMAN_WALK, "human_walk");
 	Load(GOBLIN_WALK, "goblin_walk");
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 49)
+++ Source/BadCharacter.h	(revision 50)
@@ -11,7 +11,7 @@
 public:
 	bool stopped = false;
 	bool attacking = false;
-	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 0);
+	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.16);
 	virtual ~BadCharacter() override;
 	virtual void update() override;
 	void setDestination(float x, float y);
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 49)
+++ Source/PlayerCharacter.cpp	(revision 50)
@@ -6,8 +6,8 @@
 PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z) :
 	Character(scene, HUMAN_IDLE, x, y, z)
 {
-	m_sAabb = BoundingBox({ x,y,z }, { 16,12,16 });
-
+	// Create collision box for the player
+	m_sAabb = BoundingBox({ x,y+4,z }, { 16,16,16 });
 	// Defining animations for the player
 	animations["IDLE_NE"] = AnimationDesc(HUMAN_IDLE, 0, 3, 0.15);
 	animations["IDLE_NW"] = AnimationDesc(HUMAN_IDLE, 4, 7, 0.15);
@@ -17,6 +17,7 @@
 	animations["WALK_NW"] = AnimationDesc(HUMAN_WALK, 4, 7, 0.15);
 	animations["WALK_SW"] = AnimationDesc(HUMAN_WALK, 8, 11, 0.15);
 	animations["WALK_SE"] = AnimationDesc(HUMAN_WALK, 12, 15, 0.15);
+	// Start default animation
 	startAnimation(animations["IDLE_SE"], true);
 }
 
@@ -26,28 +27,35 @@
 	stepAnimation();
 	// Move the character
 	move();
+	m_sAabb.Center.y += 4;
 	// Update which animation is currently playing
 	_updateAnimation();
+	// Update the player's hat
+	_updateHat();
 }
 
-void PlayerCharacter::shoot(float speed, float angle_in_degrees) {
+void PlayerCharacter::shoot(float angle_in_degrees) {
 	if (m_pStepTimer->GetTotalSeconds() > shootTime) {
 		// Convert the angle to radians for mathematics
 		float angle_in_radians = angle_in_degrees * (MY_PI / 180);
 		// Calculate the x component of the velocity
-		float xSpeed = speed * cos(angle_in_radians);
+		float xSpeed = projectileSpeed * cos(angle_in_radians);
 		// Calculate the y component of the velocity
-		float ySpeed = speed * sin(angle_in_radians);
+		float ySpeed = projectileSpeed * sin(angle_in_radians);
 		// Set the player's velocity
-		Vector2 bulletVel = { xSpeed, ySpeed };
+		Vector2 projectileVelocity = { xSpeed, ySpeed };
 		// Create the bullet object
-		Bullet* b = (Bullet*)scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .00001));
-		b->setVel(bulletVel);
+		GameObject* b = _createProjectile();
+		b->setVel(projectileVelocity);
 		// Update the next time I can shoot
 		shootTime = m_pStepTimer->GetTotalSeconds() + shootCooldown;
 	}
 }
 
+GameObject* PlayerCharacter::_createProjectile() {
+	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .00001));
+}
+
 void PlayerCharacter::_updateAnimation() {
 	string key = "";
 
@@ -57,6 +65,31 @@
 	calculateAnimationDirection();
 	key += animationDirection;
 
-	if(!isPlayingAnimation(animations[key]))
+	if (!isPlayingAnimation(animations[key]))
 		startAnimation(animations[key], true);
+}
+
+void PlayerCharacter::_updateHat() {
+	// Update the hat's position
+	hat->m_vPos = { m_vPos.x, m_vPos.y + 15, m_vPos.z - 0.01f };
+	hat->m_fRoll = 0;
+	// Check what direction the player is facing
+	if (animationDirection[0] == 'S') hat->m_nCurrentFrame = 0;
+	else if (animationDirection[0] == 'N') hat->m_nCurrentFrame = 1;
+	// And left/right direction
+	if (animationDirection[1] == 'E') {
+		hat->m_fYaw = 0;
+	}
+	else if (animationDirection[1] == 'W') {
+		hat->m_fYaw = MY_PI;
+	}
+	// Bounce the hat if we're moving
+	if (speed > 0) {
+		// Hat bounces a little with player movement
+		hat->m_vPos.y += 9 * (m_nCurrentFrame % 2);
+	}
+	if (abs(velocity.x) > 0.01) {
+		// Hat tilts back a bit against the "wind" lol
+		hat->m_fRoll = .15;
+	}
 }
\ No newline at end of file
Index: Source/WizardPlayer.cpp
===================================================================
--- Source/WizardPlayer.cpp	(nonexistent)
+++ Source/WizardPlayer.cpp	(revision 50)
@@ -0,0 +1,19 @@
+#include "WizardPlayer.h"
+#include "Scene.h"
+#include "Fireball.h"
+
+WizardPlayer::WizardPlayer(Scene* scene, float x, float y, float z) :
+	PlayerCharacter(scene, x, y, z)
+{
+	hat = scene->addObject(new GameObject(scene, WIZARD_HAT, m_vPos.x, m_vPos.y, m_vPos.z));
+	maxSpeed = 250;
+	// Projectile usage qualities
+	shootCooldown = .25;
+	shootTime = 0;
+	projectileSpeed = 400;
+}
+
+// Creates the fireball as the projectile
+GameObject* WizardPlayer::_createProjectile() {
+	return scene->addObject(new Fireball(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005));
+}
Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(revision 49)
+++ Source/TiledScene.cpp	(revision 50)
@@ -37,8 +37,11 @@
 
 	// Depth sort the render list
 	stable_sort(renders.begin(), renders.end(), [](CSpriteDesc3D* a, CSpriteDesc3D* b) {
-		return a->m_vPos.z > b->m_vPos.z;
+		return  a->m_vPos.y > b->m_vPos.y;
 	});
+	stable_sort(renders.begin(), renders.end(), [](CSpriteDesc3D* a, CSpriteDesc3D* b) {
+		return  a->m_vPos.z > b->m_vPos.z;
+	});
 
 	// Draw all the objects now that they've been depth sorted
 	for (auto spr : renders) {

------------------------------------------------------------------------
r51 | jdg0393 | 2020-11-14 22:04:46 -0600 (Sat, 14 Nov 2020) | 1 line

Fixed all build warnings about type conversions.

Index: Source/VikingPlayer.cpp
===================================================================
--- Source/VikingPlayer.cpp	(revision 50)
+++ Source/VikingPlayer.cpp	(revision 51)
@@ -15,5 +15,5 @@
 
 // Creates the fireball as the projectile
 GameObject* VikingPlayer::_createProjectile() {
-	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005));
+	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005f));
 }
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 50)
+++ Source/Renderer.cpp	(revision 51)
@@ -99,7 +99,7 @@
 
 	delete[] wfilename;
 
-	fontsRef[fontTag] = fonts.size();
+	fontsRef[fontTag] = (int)fonts.size();
 	fonts.push_back(move(theFont));
 } //LoadScreenFont
 
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 50)
+++ Source/BadCharacter.h	(revision 51)
@@ -18,7 +18,7 @@
 	void setDestinationID(string id);
 protected:
 	BaseLevelScene* level = nullptr;
-	float cooldown = .6;
+	float cooldown = .6f;
 	float cooldown_time = 0;
 	map<string, PathPoint> paths;
 	Vector2 dest = { 0,0 };
Index: Source/HUDObject.h
===================================================================
--- Source/HUDObject.h	(revision 50)
+++ Source/HUDObject.h	(revision 51)
@@ -21,8 +21,8 @@
     float relativeYScale;
 protected:
     Scene* scene = nullptr;
-    const float xMaxScale = .39;
-    const float yMaxScale = .22;
-    const float zBaseScale = .00095;
+    const float xMaxScale = .39f;
+    const float yMaxScale = .22f;
+    const float zBaseScale = .00095f;
 };
 
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 50)
+++ Source/GameDefines.h	(revision 51)
@@ -2,7 +2,7 @@
 /// \brief Game specific defines.
 
 #pragma once
-#define MY_PI 3.14159265358979323846
+#define MY_PI 3.14159265358979323846f
 
 #include "Defines.h"
 
Index: Source/WizardPlayer.cpp
===================================================================
--- Source/WizardPlayer.cpp	(revision 50)
+++ Source/WizardPlayer.cpp	(revision 51)
@@ -15,5 +15,5 @@
 
 // Creates the fireball as the projectile
 GameObject* WizardPlayer::_createProjectile() {
-	return scene->addObject(new Fireball(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005));
+	return scene->addObject(new Fireball(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005f));
 }
Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(revision 50)
+++ Source/TiledScene.cpp	(revision 51)
@@ -67,9 +67,9 @@
 	inData.close();
 
 	// Load each of the main 3 display layers
-	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey, 1.3);
-	_loadTileLayer(map_name + "_fg.txt", tileSpriteKey, 1.2);
-	_loadTileLayer(map_name + "_oh.txt", tileSpriteKey, 1.1);
+	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey, 1.3f);
+	_loadTileLayer(map_name + "_fg.txt", tileSpriteKey, 1.2f);
+	_loadTileLayer(map_name + "_oh.txt", tileSpriteKey, 1.1f);
 	// Load the collision layer
 	_loadClsnLayer(map_name + "_collision.txt");
 	// Load the path layer
@@ -78,7 +78,7 @@
 
 void TiledScene::_loadTileLayer(std::string filename, eSpriteType tileSpriteKey, float depth) {
 	// Get the index of the layers vector we will be pushing a layer to
-	int i = layers.size();
+	size_t i = layers.size();
 	// Push a new layer
 	layers.push_back(TileLayer());
 	// Open the correct file
@@ -113,7 +113,7 @@
 
 void TiledScene::_loadClsnLayer(std::string filename) {
 	// Points to help with positioning tiles
-	float top = tileSize * tilemapHeight;
+	float top = (float)tileSize * tilemapHeight;
 	// Create the collisions for the map
 	int numClsnBoxes = 0;
 	std::ifstream inClsn(filename);
@@ -140,7 +140,7 @@
 
 void TiledScene::_loadPathLayer(std::string filename) {
 	// Points to help with positioning tiles
-	float top = tileSize * tilemapHeight;
+	float top = (float)tileSize * tilemapHeight;
 	// Create the collisions for the map
 	int numPathPoints = 0;
 	std::ifstream inPath(filename);
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 50)
+++ Source/Spire.cpp	(revision 51)
@@ -1,5 +1,5 @@
 #include "Spire.h"
-#include "Scene.h";
+#include "Scene.h"
 #include "BaseLevelScene.h"
 
 Spire::Spire(Scene* scene, float x, float y, float z) :
@@ -6,9 +6,9 @@
 	GameObject(scene, SPIRE_BASE, x, y, z) {
 	hp = maxHP;
 	m_sAabb = BoundingBox({ x, y + 6, z }, { 64, 26, 32 });
-	peak = scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z - .1));
-	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15);
-	healthBar = scene->addObject(new HUDObject(scene, GREENLINE_SPRITE, 0, 0.9, 0));
+	peak = scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z - .1f));
+	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15f);
+	healthBar = scene->addObject(new HUDObject(scene, GREENLINE_SPRITE, 0, 0.9f, 0));
 	healthBar->relativeYScale = 10.0f;
 }
 
Index: Source/Scene.cpp
===================================================================
--- Source/Scene.cpp	(revision 50)
+++ Source/Scene.cpp	(revision 51)
@@ -35,7 +35,7 @@
 // Method that runs every tick, most logic should go here. You may also call
 // the update method of game objects.
 void Scene::update() {
-	int sz = objectList.size();
+	size_t sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
 		objectList[i]->update();
 	}
@@ -117,7 +117,7 @@
 }
 
 void Scene::cullObjects() {
-	int sz = objectList.size();
+	size_t sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
 		if (objectList[i]->getWillCull()) {
 			// This deletes the object and removes it's reference from objectList
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 50)
+++ Source/TitleScreenScene.cpp	(revision 51)
@@ -49,11 +49,11 @@
 	for (int i = 0; i < menu.size(); i++) {
 		if (i == selection) {
 			m_pRenderer->setFont("selection_font");
-			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780, 180 + (40 * i)), Colors::DarkOrange);
+			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780.0f, 180.0f + (40.0f * i)), Colors::DarkOrange);
 			m_pRenderer->setFont("font");
 		}
 		else {
-			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780, 180 + (40 * i)), Colors::Orange);
+			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780.0f, 180.0f + (40.0f * i)), Colors::Orange);
 		}
 	}
 }
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 50)
+++ Source/BadCharacter.cpp	(revision 51)
@@ -15,14 +15,14 @@
 	tags.insert("baddie");
 
 	// Defining animations for the bad guy
-	animations["WALK_NE"] = AnimationDesc(GOBLIN_WALK, 0, 3, 0.15);
-	animations["WALK_NW"] = AnimationDesc(GOBLIN_WALK, 4, 7, 0.15);
-	animations["WALK_SW"] = AnimationDesc(GOBLIN_WALK, 8, 11, 0.15);
-	animations["WALK_SE"] = AnimationDesc(GOBLIN_WALK, 12, 15, 0.15);
-	animations["ATTACK_NE"] = AnimationDesc(GOBLIN_ATTACK, 0, 3, 0.15);
-	animations["ATTACK_NW"] = AnimationDesc(GOBLIN_ATTACK, 4, 7, 0.15);
-	animations["ATTACK_SW"] = AnimationDesc(GOBLIN_ATTACK, 8, 11, 0.15);
-	animations["ATTACK_SE"] = AnimationDesc(GOBLIN_ATTACK, 12, 15, 0.15);
+	animations["WALK_NE"] = AnimationDesc(GOBLIN_WALK, 0, 3, 0.15f);
+	animations["WALK_NW"] = AnimationDesc(GOBLIN_WALK, 4, 7, 0.15f);
+	animations["WALK_SW"] = AnimationDesc(GOBLIN_WALK, 8, 11, 0.15f);
+	animations["WALK_SE"] = AnimationDesc(GOBLIN_WALK, 12, 15, 0.15f);
+	animations["ATTACK_NE"] = AnimationDesc(GOBLIN_ATTACK, 0, 3, 0.15f);
+	animations["ATTACK_NW"] = AnimationDesc(GOBLIN_ATTACK, 4, 7, 0.15f);
+	animations["ATTACK_SW"] = AnimationDesc(GOBLIN_ATTACK, 8, 11, 0.15f);
+	animations["ATTACK_SE"] = AnimationDesc(GOBLIN_ATTACK, 12, 15, 0.15f);
 }
 BadCharacter::~BadCharacter() {}
 
@@ -37,7 +37,7 @@
 		attacking = false;
 		if (m_fAlpha > 0) {
 			// Fade the bad guy out on game over
-			m_fAlpha -= .01;
+			m_fAlpha -= .01f;
 		}
 		else {
 			// Destroy this creature once it's faded out
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 50)
+++ Source/PlayerCharacter.cpp	(revision 51)
@@ -9,14 +9,14 @@
 	// Create collision box for the player
 	m_sAabb = BoundingBox({ x,y+4,z }, { 16,16,16 });
 	// Defining animations for the player
-	animations["IDLE_NE"] = AnimationDesc(HUMAN_IDLE, 0, 3, 0.15);
-	animations["IDLE_NW"] = AnimationDesc(HUMAN_IDLE, 4, 7, 0.15);
-	animations["IDLE_SW"] = AnimationDesc(HUMAN_IDLE, 8, 11, 0.15);
-	animations["IDLE_SE"] = AnimationDesc(HUMAN_IDLE, 12, 15, 0.15);
-	animations["WALK_NE"] = AnimationDesc(HUMAN_WALK, 0, 3, 0.15);
-	animations["WALK_NW"] = AnimationDesc(HUMAN_WALK, 4, 7, 0.15);
-	animations["WALK_SW"] = AnimationDesc(HUMAN_WALK, 8, 11, 0.15);
-	animations["WALK_SE"] = AnimationDesc(HUMAN_WALK, 12, 15, 0.15);
+	animations["IDLE_NE"] = AnimationDesc(HUMAN_IDLE, 0, 3, 0.15f);
+	animations["IDLE_NW"] = AnimationDesc(HUMAN_IDLE, 4, 7, 0.15f);
+	animations["IDLE_SW"] = AnimationDesc(HUMAN_IDLE, 8, 11, 0.15f);
+	animations["IDLE_SE"] = AnimationDesc(HUMAN_IDLE, 12, 15, 0.15f);
+	animations["WALK_NE"] = AnimationDesc(HUMAN_WALK, 0, 3, 0.15f);
+	animations["WALK_NW"] = AnimationDesc(HUMAN_WALK, 4, 7, 0.15f);
+	animations["WALK_SW"] = AnimationDesc(HUMAN_WALK, 8, 11, 0.15f);
+	animations["WALK_SE"] = AnimationDesc(HUMAN_WALK, 12, 15, 0.15f);
 	// Start default animation
 	startAnimation(animations["IDLE_SE"], true);
 }
@@ -53,7 +53,7 @@
 }
 
 GameObject* PlayerCharacter::_createProjectile() {
-	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .00001));
+	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .001f));
 }
 
 void PlayerCharacter::_updateAnimation() {
@@ -88,8 +88,8 @@
 		// Hat bounces a little with player movement
 		hat->m_vPos.y += 9 * (m_nCurrentFrame % 2);
 	}
-	if (abs(velocity.x) > 0.01) {
+	if (abs(velocity.x) > 0.01f) {
 		// Hat tilts back a bit against the "wind" lol
-		hat->m_fRoll = .15;
+		hat->m_fRoll = .15f;
 	}
 }
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 50)
+++ Source/BaseLevelScene.cpp	(revision 51)
@@ -19,9 +19,9 @@
 	defPos = m_pRenderer->GetCameraPos();
 	// Create the simple tilemap
 	loadTileMap("simple", SIMPLE_TILE);
-	backgroundSprite->m_vPos = { (tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, 10 };
-	backgroundSprite->m_fYScale = backgroundSprite->m_fYScale * 1.5;
-	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5;
+	backgroundSprite->m_vPos = { (tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, 10.0f };
+	backgroundSprite->m_fYScale = backgroundSprite->m_fYScale * 1.5f;
+	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5f;
 	// Place the player on the map
 	player = (PlayerCharacter*)addObject(new WizardPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
 	// Set the camera to follow the player
@@ -40,7 +40,7 @@
 	BroadPhaseClsn();
 	// Update the camera position if we're following the player
 	if (followTarget)
-		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 1.5));
+		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 1.5f));
 	// After changing camera position, make sure to adjust any HUD elements
 	adjustHUD();
 	// Delete objects that need to be culled
@@ -55,7 +55,7 @@
 	if (!gameOver && m_pStepTimer->GetTotalSeconds() > spawnTime) {
 		spawnBaddie();
 		spawnTime = m_pStepTimer->GetTotalSeconds() + spawnRate;
-		spawnRate *= .9;
+		spawnRate *= .9f;
 	}
 }
 
@@ -81,7 +81,7 @@
 		//string hpString = "Spire Hit Points: " + to_string(spire->hp) + "/1000";
 		string hpString = "Spire";
 		float offset = hpString.size() * 7.5f;
-		m_pRenderer->DrawScreenText(hpString.c_str(), { 640 - offset, 26 }, Colors::White);
+		m_pRenderer->DrawScreenText(hpString.c_str(), { 640.0f - offset, 26.0f }, Colors::White);
 	}
 	else {
 		m_pRenderer->setFont("title_font");
@@ -88,8 +88,8 @@
 		m_pRenderer->DrawCenteredText("Game Over", Colors::IndianRed);
 		m_pRenderer->setFont("font");
 		string timeLeft = to_string(int(endTime - m_pStepTimer->GetTotalSeconds()));
-		float x = 640.0 - timeLeft.size() * 8.0;
-		m_pRenderer->DrawScreenText(timeLeft.c_str(), { x, 420 }, Colors::IndianRed);
+		float x = 640.0f - timeLeft.size() * 8.0f;
+		m_pRenderer->DrawScreenText(timeLeft.c_str(), { x, 420.0f }, Colors::IndianRed);
 	}
 }
 
@@ -102,7 +102,7 @@
 	if (tileSize > 0) {
 		shouldFollow = false;
 		followTarget = nullptr;
-		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2) * tileSize, (tilemapHeight / 2) * tileSize, defPos.z * 2));
+		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, defPos.z * 2.0f));
 	}
 }
 
@@ -126,7 +126,7 @@
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('T')) {
 		Vector3 pos = player->getPos();
-		addObject(new Tower(this, pos.x, pos.y - 32));
+		addObject(new Tower(this, pos.x, pos.y - 32.0f));
 	}
 
 	if (m_pKeyboard->TriggerDown('X')) {
@@ -189,7 +189,7 @@
 }
 
 void BaseLevelScene::cullObjects() {
-	int sz = objectList.size();
+	size_t sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
 		if (objectList[i]->getWillCull()) {
 			// If object is a baddie, remove it from the baddies list
@@ -238,7 +238,7 @@
 void BaseLevelScene::endGame() {
 	if (!gameOver) {
 		gameOver = true;
-		endTime = m_pStepTimer->GetTotalSeconds() + 15;
+		endTime = m_pStepTimer->GetTotalSeconds() + 15.0f;
 	}
 }
 
@@ -245,7 +245,7 @@
 void BaseLevelScene::spawnBaddie() {
 	// Create some stupid bad guy
 	string sp = m_pRandom->randn(0, 1) ? "enSpawn1" : "enSpawn2";
-	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, .851)));
+	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, .851f)));
 	baddies[baddies.size() - 1]->setDestinationID(sp);
 }
 
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 50)
+++ Source/Fireball.cpp	(revision 51)
@@ -6,7 +6,7 @@
 	tags.insert("projectile");
 	tags.insert("explosive");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
-	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15);
+	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15f);
 }
 
 void Fireball::update() {
Index: Source/AnimationDesc.h
===================================================================
--- Source/AnimationDesc.h	(revision 50)
+++ Source/AnimationDesc.h	(revision 51)
@@ -18,8 +18,8 @@
 		return true;
 	}
 	eSpriteType sprite = BLACK_SQUARE;
-	int startFrame = 0;
-	int endFrame = 0;
+	unsigned int startFrame = 0;
+	unsigned int endFrame = 0;
 	float frameTime = 0.5;
 };
 

------------------------------------------------------------------------
r52 | amm0837 | 2020-11-14 23:11:45 -0600 (Sat, 14 Nov 2020) | 1 line

Added second tower type and different projectiles for them

Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 51)
+++ Source/Tower.h	(revision 52)
@@ -6,8 +6,8 @@
 
 class Tower : public GameObject {
 public:
-	Tower(Scene* scene, float x, float y, float z=1.14);
-	void update() override;
+	Tower(Scene* scene, eSpriteType spriteKey, float x, float y, float z=1.14);
+	virtual void update()override;
 	GameObject* calcTarget();
 	void fire(GameObject* b);
 	void setRoll(float angle);
@@ -17,4 +17,5 @@
 	GameObject* target = nullptr;
 	float m_fGunTimer = 0.0f;
 	Scene* objScene;
+	float level = 1;
 };
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 51)
+++ Source/Source.vcxproj	(revision 52)
@@ -172,8 +172,10 @@
     <ClCompile Include="Game.cpp" />
     <ClCompile Include="GameObject.cpp" />
     <ClCompile Include="HUDObject.cpp" />
+    <ClCompile Include="MageTower.cpp" />
     <ClCompile Include="Main.cpp" />
     <ClCompile Include="PlayerCharacter.cpp" />
+    <ClCompile Include="RangeTower.cpp" />
     <ClCompile Include="Renderer.cpp" />
     <ClCompile Include="Scene.cpp" />
     <ClCompile Include="BaseLevelScene.cpp" />
@@ -195,7 +197,9 @@
     <ClInclude Include="GameDefines.h" />
     <ClInclude Include="GameObject.h" />
     <ClInclude Include="HUDObject.h" />
+    <ClInclude Include="MageTower.h" />
     <ClInclude Include="PlayerCharacter.h" />
+    <ClInclude Include="RangeTower.h" />
     <ClInclude Include="Renderer.h" />
     <ClInclude Include="Scene.h" />
     <ClInclude Include="BaseLevelScene.h" />
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 51)
+++ Source/GameDefines.h	(revision 52)
@@ -23,7 +23,12 @@
 	BULLET1,
 	SPIRE_BASE,
 	SPIRE_PEAK,
-	TOWER1,
+	RANGE1,
+	RANGE2,
+	RANGE3,
+	MAGE1,
+	MAGE2,
+	MAGE3,
 	FIREBALL,
 	EXPLOSION,
 	SMOKE,
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 51)
+++ Source/BaseLevelScene.cpp	(revision 52)
@@ -4,6 +4,8 @@
 #include "HUDObject.h"
 #include "VikingPlayer.h"
 #include "WizardPlayer.h"
+#include "MageTower.h"
+#include "RangeTower.h"
 
 BaseLevelScene::BaseLevelScene(CGame* game) :
 	TiledScene(game) {}
@@ -66,7 +68,7 @@
 		m_pRenderer->DrawBoundingBox(spire->m_sAabb);
 		m_pRenderer->DrawBoundingBox(player->m_sAabb);
 		for (auto obj : objectList) {
-			if (obj->getSpriteType() == TOWER1) {
+			if (obj->is("tower")) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
 			}
 			if (obj->is("projectile")) {
@@ -124,11 +126,16 @@
 		drawMapClsn = drawMapClsn ? false : true;
 
 	//Press T to place a tower at the PC's current location
-	if (m_pKeyboard->TriggerDown('T')) {
+	if (m_pKeyboard->TriggerDown('1')) {
 		Vector3 pos = player->getPos();
-		addObject(new Tower(this, pos.x, pos.y - 32.0f));
+		addObject(new RangeTower(this, pos.x, pos.y - 32.0f));
 	}
+	if (m_pKeyboard->TriggerDown('2')) {
+		Vector3 pos = player->getPos();
+		addObject(new MageTower(this, pos.x, pos.y - 32.0f));
+	}
 
+
 	if (m_pKeyboard->TriggerDown('X')) {
 		GameObject* tow = getClosestTower();
 		deleteObject(tow);
@@ -145,7 +152,7 @@
 	// If the player is colliding, move them back
 	//check if player collides with a tower
 	for (auto obj : objectList) {
-		if (obj->getSpriteType() == TOWER1) {
+		if (obj->is("tower")) {
 			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
 		}
 	}
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 51)
+++ Source/Source.vcxproj.filters	(revision 52)
@@ -50,6 +50,12 @@
     <ClCompile Include="VikingPlayer.cpp">
       <Filter>Objects\Players</Filter>
     </ClCompile>
+    <ClCompile Include="RangeTower.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
+    <ClCompile Include="MageTower.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -103,6 +109,12 @@
     <ClInclude Include="VikingPlayer.h">
       <Filter>Objects\Players</Filter>
     </ClInclude>
+    <ClInclude Include="RangeTower.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
+    <ClInclude Include="MageTower.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 51)
+++ Source/Tower.cpp	(revision 52)
@@ -3,8 +3,8 @@
 #include "Fireball.h"
 
 
-Tower::Tower(Scene* scene, float x, float y, float z) :
-	GameObject(scene, TOWER1, x, y, z)
+Tower::Tower(Scene* scene, eSpriteType spriteKey, float x, float y, float z) :
+	GameObject(scene, spriteKey, x, y, z)
 {
 	objScene = scene;
 	setRoll(XM_2PI);
@@ -16,12 +16,19 @@
 void Tower::update() {
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
-		if (this->is("tower")) {		//add conditions for other towers here, set bullet type
+		printf("got here");
+		if (this->is("tower")&& this->is("mage")) {		//add conditions for other towers here, set bullet type
 			Vector3 pos = this->getPos();
 			//creating bullet and setting its bounding box
 			GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z));
 			fire(b);
 		}
+		else if (this->is("tower") && this->is("range")) {
+			Vector3 pos = this->getPos();
+			//creating bullet and setting its bounding box
+			GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z));
+			fire(b);
+		}
 	}
 }
 
@@ -57,7 +64,7 @@
 	
 	//find target for tower
 	target = calcTarget();
-
+	
 	if (target != nullptr) {
 
 		m_pAudio->play(GUN_SOUND);
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 51)
+++ Source/Renderer.cpp	(revision 52)
@@ -41,7 +41,12 @@
 	Load(BULLET1, "bullet1");
 	Load(SPIRE_BASE, "spire_base");
 	Load(SPIRE_PEAK, "spire_peak");
-	Load(TOWER1, "tower1");
+	Load(MAGE1, "mage1");
+	Load(MAGE2, "mage2");
+	Load(MAGE3, "mage3");
+	Load(RANGE1, "range1");
+	Load(RANGE2, "range2");
+	Load(RANGE3, "range3");
 	Load(FIREBALL, "fireball");
 	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 51)
+++ Source/BaseLevelScene.h	(revision 52)
@@ -6,6 +6,7 @@
 #include "Tower.h"
 #include "Fireball.h"
 
+
 // Forward declarations for circular dependency
 class CGame;
 

------------------------------------------------------------------------
r53 | amm0837 | 2020-11-14 23:52:17 -0600 (Sat, 14 Nov 2020) | 1 line

addded files i forgot smh

Index: Source/RangeTower.cpp
===================================================================
--- Source/RangeTower.cpp	(nonexistent)
+++ Source/RangeTower.cpp	(revision 53)
@@ -0,0 +1,11 @@
+#include "RangeTower.h"
+
+RangeTower::RangeTower(Scene* scene, float x, float y,float z) :
+	Tower(scene, RANGE1, x, y, z) {
+	
+	tags.insert("range");
+}
+
+void RangeTower::update() {
+	Tower::update();
+}
\ No newline at end of file
Index: Source/MageTower.cpp
===================================================================
--- Source/MageTower.cpp	(nonexistent)
+++ Source/MageTower.cpp	(revision 53)
@@ -0,0 +1,12 @@
+#include "MageTower.h"
+
+MageTower::MageTower(Scene* scene, float x, float y, float z) :
+	Tower(scene, MAGE1, x, y, z) {
+
+	tags.insert("mage");
+
+}
+
+void MageTower::update() {
+	Tower::update();
+}
\ No newline at end of file
Index: Source/RangeTower.h
===================================================================
--- Source/RangeTower.h	(nonexistent)
+++ Source/RangeTower.h	(revision 53)
@@ -0,0 +1,13 @@
+#pragma once
+#include "Tower.h"
+
+
+class RangeTower : 
+	public Tower {
+
+public:
+	RangeTower(Scene* scene, float x, float y,float z = 1.14);
+	virtual void update();
+private:
+	
+};
Index: Source/MageTower.h
===================================================================
--- Source/MageTower.h	(nonexistent)
+++ Source/MageTower.h	(revision 53)
@@ -0,0 +1,14 @@
+#pragma once
+#include "Tower.h"
+
+
+class MageTower :
+	public Tower {
+
+public:
+	MageTower(Scene* scene, float x, float y, float z = 1.14);
+	virtual void update();
+private:
+	
+
+};

------------------------------------------------------------------------
r54 | jdg0393 | 2020-11-14 23:55:19 -0600 (Sat, 14 Nov 2020) | 1 line

Dynamic controls system using a map of keycodes.

Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 53)
+++ Source/TitleScreenScene.cpp	(revision 54)
@@ -21,22 +21,19 @@
 }
 
 void TitleScreenScene::update() {
-	if (m_pKeyboard->TriggerDown(VK_UP))
+	if (m_pKeyboard->TriggerDown(controlMap["UP_ONE"]))
 		if (selection > 0) selection--;
-	if (m_pKeyboard->TriggerDown(VK_DOWN))
+	if (m_pKeyboard->TriggerDown(controlMap["DOWN_ONE"]))
 		if (selection < menu.size() - 1) selection++;
 
 	// Making a selection
-	if (m_pKeyboard->TriggerDown(VK_RETURN)) {
+	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"])) {
 		if (menu[selection] == "Play Game") {
 			m_pAudio->stop();
 			game->startScene(new BaseLevelScene(game));
 		}
 		else if (menu[selection] == "Exit") {
-			// If the player exits using this button it WILL show memory leaks
-			// It does not run all destructors when doing using exit, abort, etc
-			game->Release();
-			exit(0);
+			game->Exit();
 		}
 	}
 }
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 53)
+++ Source/PlayerCharacter.h	(revision 54)
@@ -7,11 +7,14 @@
 	public Character
 {
 public:
-	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15);
+	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15, string playerID = "ONE");
 	void update() override; // Character's update loop, runs every frame
 	void shoot(float angle_in_degrees);
 	float getMaxSpeed() { return maxSpeed; }
+	// Keyboard handler just for the player, for use in the scenes keyboard handler
+	virtual void handleKeyboard();
 protected:
+	string playerID;
 	float shootCooldown;
 	float shootTime;
 	float projectileSpeed;
@@ -20,4 +23,8 @@
 	virtual GameObject* _createProjectile();
 	void _updateAnimation();
 	void _updateHat();
+	// Handles the movement keys for the player
+	void _handleMovementKeys();
+	// Handles the directional (shooting) keys for the player
+	void _handleDirectionKeys();
 };
Index: Source/Game.h
===================================================================
--- Source/Game.h	(revision 53)
+++ Source/Game.h	(revision 54)
@@ -10,6 +10,7 @@
 
 /// \brief The game class.
 class CGame :
+	public CWindowDesc,
 	public CComponent,
 	public CSettings,
 	public CCommon {
@@ -17,6 +18,7 @@
 private:
 	Scene* activeScene = nullptr;
 	bool displayFramerate = false;
+	bool willExit = false;
 	void RenderFrame();
 public:
 	~CGame(); ///< Destructor.
@@ -24,6 +26,7 @@
 	void Initialize(); ///< Initialize the game.
 	void ProcessFrame(); ///< Process an animation frame.
 	void Release(); ///< Release the renderer.
+	void Exit();
 
 	// Starts new active scene and terminates the previous
 	// Only use this if you are switching scenes entirely, not stacking!
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 53)
+++ Source/BaseLevelScene.cpp	(revision 54)
@@ -112,10 +112,8 @@
 	// No need to get the keyboard state, it's done in the Game!
 	// Just check values on the keyboard :)
 
-	// Movement controls
-	_handleMoveKeys();
-	// Shooting controls
-	_handleShootKeys();
+	// Handle the main player's controls
+	player->handleKeyboard();
 
 	// Toggle camera mode
 	if (m_pKeyboard->TriggerDown('Z'))
@@ -255,74 +253,3 @@
 	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, .851f)));
 	baddies[baddies.size() - 1]->setDestinationID(sp);
 }
-
-void BaseLevelScene::_handleMoveKeys() {
-	// Moving of the character
-	if (m_pKeyboard->Down('A'))
-	{
-		// Left-Up
-		if (m_pKeyboard->Down('W'))
-			player->setVelocity(player->getMaxSpeed(), 135);
-		// Left-Down
-		else if (m_pKeyboard->Down('S'))
-			player->setVelocity(player->getMaxSpeed(), 225);
-		// Left
-		else
-			player->setVelocity(player->getMaxSpeed(), 180);
-	}
-	else if (m_pKeyboard->Down('D'))
-	{
-		// Right-Up
-		if (m_pKeyboard->Down('W'))
-			player->setVelocity(player->getMaxSpeed(), 45);
-		// Right-Down
-		else if (m_pKeyboard->Down('S'))
-			player->setVelocity(player->getMaxSpeed(), 315);
-		// Right
-		else
-			player->setVelocity(player->getMaxSpeed(), 0);
-	}
-	// Down
-	else if (m_pKeyboard->Down('S'))
-		player->setVelocity(player->getMaxSpeed(), 270);
-	// Up
-	else if (m_pKeyboard->Down('W'))
-		player->setVelocity(player->getMaxSpeed(), 90);
-	// No movement
-	else
-		player->setVelocity(0, player->getAngle());
-}
-
-void BaseLevelScene::_handleShootKeys() {
-	// Moving of the character
-	if (m_pKeyboard->Down(VK_LEFT))
-	{
-		// Left-Up
-		if (m_pKeyboard->Down(VK_UP))
-			player->shoot(135);
-		// Left-Down
-		else if (m_pKeyboard->Down(VK_DOWN))
-			player->shoot(225);
-		// Left
-		else
-			player->shoot(180);
-	}
-	else if (m_pKeyboard->Down(VK_RIGHT))
-	{
-		// Right-Up
-		if (m_pKeyboard->Down(VK_UP))
-			player->shoot(45);
-		// Right-Down
-		else if (m_pKeyboard->Down(VK_DOWN))
-			player->shoot(315);
-		// Right
-		else
-			player->shoot(0);
-	}
-	// Down
-	else if (m_pKeyboard->Down(VK_DOWN))
-		player->shoot(270);
-	// Up
-	else if (m_pKeyboard->Down(VK_UP))
-		player->shoot(90);
-}
Index: Source/Common.h
===================================================================
--- Source/Common.h	(revision 53)
+++ Source/Common.h	(revision 54)
@@ -3,6 +3,8 @@
 
 #pragma once
 
+#include <map>
+#include <string>
 #include "SndList.h"
 #include "ParticleEngine.h"
 
@@ -22,6 +24,8 @@
 class CCommon {
 protected:
 	static CRenderer* m_pRenderer; ///< Pointer to the renderer.
+	// Game controls, name->keycode map
+	static map<string, WPARAM> controlMap;
 }; //CCommon
 
 // Common structures
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 53)
+++ Source/PlayerCharacter.cpp	(revision 54)
@@ -3,11 +3,13 @@
 #include "Bullet.h"
 #include "Scene.h"
 
-PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z) :
+PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z, string playerID) :
 	Character(scene, HUMAN_IDLE, x, y, z)
 {
+	// Set the player's ID (in case we play co op)
+	this->playerID = playerID;
 	// Create collision box for the player
-	m_sAabb = BoundingBox({ x,y+4,z }, { 16,16,16 });
+	m_sAabb = BoundingBox({ x,y + 4,z }, { 16,16,16 });
 	// Defining animations for the player
 	animations["IDLE_NE"] = AnimationDesc(HUMAN_IDLE, 0, 3, 0.15f);
 	animations["IDLE_NW"] = AnimationDesc(HUMAN_IDLE, 4, 7, 0.15f);
@@ -92,4 +94,80 @@
 		// Hat tilts back a bit against the "wind" lol
 		hat->m_fRoll = .15f;
 	}
+}
+
+void PlayerCharacter::handleKeyboard() {
+	_handleMovementKeys();
+	_handleDirectionKeys();
+}
+
+void PlayerCharacter::_handleMovementKeys() {
+	// Handles movement keys for the character
+	if (m_pKeyboard->Down(controlMap["LEFT_" + playerID]))
+	{
+		// Left-Up
+		if (m_pKeyboard->Down(controlMap["UP_" + playerID]))
+			setVelocity(maxSpeed, 135);
+		// Left-Down
+		else if (m_pKeyboard->Down(controlMap["DOWN_" + playerID]))
+			setVelocity(maxSpeed, 225);
+		// Left
+		else
+			setVelocity(maxSpeed, 180);
+	}
+	else if (m_pKeyboard->Down(controlMap["RIGHT_" + playerID]))
+	{
+		// Right-Up
+		if (m_pKeyboard->Down(controlMap["UP_" + playerID]))
+			setVelocity(maxSpeed, 45);
+		// Right-Down
+		else if (m_pKeyboard->Down(controlMap["DOWN_" + playerID]))
+			setVelocity(maxSpeed, 315);
+		// Right
+		else
+			setVelocity(maxSpeed, 0);
+	}
+	// Down
+	else if (m_pKeyboard->Down(controlMap["DOWN_" + playerID]))
+		setVelocity(maxSpeed, 270);
+	// Up
+	else if (m_pKeyboard->Down(controlMap["UP_" + playerID]))
+		setVelocity(maxSpeed, 90);
+	// No movement
+	else
+		setVelocity(0, angle);
+}
+
+void PlayerCharacter::_handleDirectionKeys() {
+	// Moving of the character
+	if (m_pKeyboard->Down(controlMap["WEST_"+playerID]))
+	{
+		// Left-Up
+		if (m_pKeyboard->Down(controlMap["NORTH_"+playerID]))
+			shoot(135);
+		// Left-Down
+		else if (m_pKeyboard->Down(controlMap["SOUTH_"+playerID]))
+			shoot(225);
+		// Left
+		else
+			shoot(180);
+	}
+	else if (m_pKeyboard->Down(controlMap["EAST_"+playerID]))
+	{
+		// Right-Up
+		if (m_pKeyboard->Down(controlMap["NORTH_"+playerID]))
+			shoot(45);
+		// Right-Down
+		else if (m_pKeyboard->Down(controlMap["SOUTH_"+playerID]))
+			shoot(315);
+		// Right
+		else
+			shoot(0);
+	}
+	// Down
+	else if (m_pKeyboard->Down(controlMap["SOUTH_"+playerID]))
+		shoot(270);
+	// Up
+	else if (m_pKeyboard->Down(controlMap["NORTH_"+playerID]))
+		shoot(90);
 }
\ No newline at end of file
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 53)
+++ Source/Game.cpp	(revision 54)
@@ -8,8 +8,10 @@
 #include "ComponentIncludes.h"
 
 CGame::~CGame() {
+	delete m_pRenderer;
 	if (activeScene) {
 		delete activeScene;
+		activeScene = nullptr;
 	}
 } //destructor
 
@@ -27,14 +29,12 @@
 	startScene(new TitleScreenScene(this));
 } //Initialize
 
-/// Release all of the DirectX12 objects by deleting the renderer.
-void CGame::Release() {
-	delete m_pRenderer;
-	m_pRenderer = nullptr; //for safety
-} //Release
-
 // Code executed at every new frame
 void CGame::ProcessFrame() {
+	if (willExit)
+		// Exit via destroying the game window
+		DestroyWindow(m_Hwnd);
+
 	m_pAudio->BeginFrame(); //notify audio player that frame has begun
 
 	// Check for debugging keypresses
@@ -50,6 +50,16 @@
 	RenderFrame();
 } //ProcessFrame
 
+/// Release all of the DirectX12 objects by deleting the renderer.
+void CGame::Release() {
+	delete m_pRenderer;
+	m_pRenderer = nullptr; //for safety
+} //Release
+
+void CGame::Exit() {
+	willExit = true;
+}
+
 void CGame::startScene(Scene* scene) {
 	delete activeScene;
 	activeScene = scene;
@@ -56,7 +66,6 @@
 	activeScene->create();
 }
 
-
 /// The renderer is notified of the start and end of the frame so
 /// that it can let Direct3D do its pipelining jiggery-pokery.
 void CGame::RenderFrame() {
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 53)
+++ Source/BaseLevelScene.h	(revision 54)
@@ -49,8 +49,6 @@
 	Vector3 defPos; // Default "true size" camera position
 	bool shouldFollow = false; // Whether the camera is following
 	void handleKeyboard(); // Handler for the keyboard
-	void _handleMoveKeys(); // Internal function used by keyboard handler
-	void _handleShootKeys(); // Internal function used by keyboard handler
 	void checkPlyClsn();
 };
 
Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 53)
+++ Source/Common.cpp	(revision 54)
@@ -6,4 +6,20 @@
 
 #include "Common.h"
 
-CRenderer* CCommon::m_pRenderer = nullptr;
\ No newline at end of file
+CRenderer* CCommon::m_pRenderer = nullptr;
+
+// Default controls
+map<string, WPARAM> CCommon::controlMap = {
+	// Default movement and menu navigation controls
+	{"UP_ONE", 'W'},
+	{"DOWN_ONE", 'S'},
+	{"LEFT_ONE", 'A'},
+	{"RIGHT_ONE", 'D'},
+	// Default aiming and directional activation keys
+	{"NORTH_ONE", VK_UP},
+	{"SOUTH_ONE", VK_DOWN},
+	{"WEST_ONE", VK_LEFT},
+	{"EAST_ONE", VK_RIGHT},
+	// Default accept and special action keys
+	{"ACCEPT_ONE", 'E'}
+};

------------------------------------------------------------------------
r55 | amm0837 | 2020-11-14 23:56:22 -0600 (Sat, 14 Nov 2020) | 1 line

added economy stuff and instructions for placing towers

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 54)
+++ Source/BaseLevelScene.cpp	(revision 55)
@@ -84,6 +84,12 @@
 		string hpString = "Spire";
 		float offset = hpString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(hpString.c_str(), { 640.0f - offset, 26.0f }, Colors::White);
+
+		string credString = "Credits: " + to_string(credits);
+		m_pRenderer->DrawScreenText(credString.c_str(), { 800.0f,60.0f }, Colors::White);
+
+		string priceString = "Range Tower: Press 1 (5 credits)\nMage Tower: Press 2 (10 credits)";
+		m_pRenderer->DrawScreenText(priceString.c_str(), { 100.0f,60.0f }, Colors::White);
 	}
 	else {
 		m_pRenderer->setFont("title_font");
@@ -125,18 +131,33 @@
 
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('1')) {
-		Vector3 pos = player->getPos();
-		addObject(new RangeTower(this, pos.x, pos.y - 32.0f));
+		if (credits >= 5) {
+			Vector3 pos = player->getPos();
+			addObject(new RangeTower(this, pos.x, pos.y - 32.0f));
+			credits -= 5;
+		}
+		
 	}
 	if (m_pKeyboard->TriggerDown('2')) {
-		Vector3 pos = player->getPos();
-		addObject(new MageTower(this, pos.x, pos.y - 32.0f));
+		if (credits >= 10) {
+			Vector3 pos = player->getPos();
+			addObject(new MageTower(this, pos.x, pos.y - 32.0f));
+			credits -= 10;
+		}
 	}
 
 
 	if (m_pKeyboard->TriggerDown('X')) {
 		GameObject* tow = getClosestTower();
-		deleteObject(tow);
+		if (tow != NULL) {
+			if (tow->is("range")) {
+				credits += 3;
+			}
+			if (tow->is("mage")) {
+				credits += 8;
+			}
+			deleteObject(tow);
+		}
 	}
 }
 
@@ -180,12 +201,14 @@
 		if (obj1->is("projectile") && obj2->is("baddie")) {
 			obj2->kill();
 			obj1->kill();
+			credits++;
 		}
 		if (obj1->is("explosive") && obj2->is("baddie")) {	//when fireball intersects baddie, kill baddies within certain radius of fireball
-			obj1->explode();
+			obj1->kill();
 			for (GameObject* obj : this->getBaddies()) {
-				if (obj->inRadius(obj1->getPos(), 50.0f)) {
+				if (obj->inRadius(obj1->getPos(), 50.0f) && (!obj->getWillCull())) {
 					obj->kill();
+					credits++;
 				}
 			}
 
@@ -236,6 +259,9 @@
 			}
 		}
 	}
+	if (tow == NULL)
+		return NULL;
+	else
 	return tow;
 
 }
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 54)
+++ Source/Tower.cpp	(revision 55)
@@ -16,7 +16,6 @@
 void Tower::update() {
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
-		printf("got here");
 		if (this->is("tower")&& this->is("mage")) {		//add conditions for other towers here, set bullet type
 			Vector3 pos = this->getPos();
 			//creating bullet and setting its bounding box
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 54)
+++ Source/GameObject.h	(revision 55)
@@ -30,7 +30,7 @@
 	// Description methods
 	int getSpriteType();
 	bool is(string tag); // Checks if the game object has a certain descriptor tag
-
+	
 	// Animation methods
 	void startAnimation(AnimationDesc& anim, bool loop = false);
 	void stepAnimation();
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 54)
+++ Source/BaseLevelScene.h	(revision 55)
@@ -42,6 +42,7 @@
 	float endTime = 0;
 	float spawnTime = 10;
 	float spawnRate = 10;
+	int credits = 5;
 	Spire* spire = nullptr; // Reference to spire which must be defended
 	PlayerCharacter* player = nullptr; // Reference to the player character
 	vector<BadCharacter*> baddies;

------------------------------------------------------------------------
r56 | jdg0393 | 2020-11-15 05:56:53 -0600 (Sun, 15 Nov 2020) | 1 line

Character selection menu between title and level.

Index: Source/TitleScreenScene.h
===================================================================
--- Source/TitleScreenScene.h	(revision 55)
+++ Source/TitleScreenScene.h	(revision 56)
@@ -17,5 +17,7 @@
 private:
 	vector<string> menu;
 	int selection = 0;
+	void _handleKeyboard();
+	void _handleController();
 };
 
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 55)
+++ Source/PlayerCharacter.cpp	(revision 56)
@@ -2,6 +2,7 @@
 #include "StepTimer.h"
 #include "Bullet.h"
 #include "Scene.h"
+#include "Controller.h"
 
 PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z, string playerID) :
 	Character(scene, HUMAN_IDLE, x, y, z)
@@ -54,6 +55,39 @@
 	}
 }
 
+void PlayerCharacter::handleKeyboard() {
+	_handleMovementKeys();
+	_handleDirectionKeys();
+}
+
+void PlayerCharacter::handleController() {
+	// Get thumb vectors
+	Vector2 leftThumb = m_pController->GetLThumb();
+	Vector2 rightThumb = m_pController->GetRThumb();
+	// Check if sticks are significantly pressed
+	bool leftThumbUsed = abs(leftThumb.x) + abs(leftThumb.y) > 0.05f;
+	bool rightThumbUsed = abs(rightThumb.x) + abs(rightThumb.y) > 0.05f;
+	// Left stick handler
+	if (leftThumbUsed) {
+		// Calculate angles
+		float leftThumbAngle = atan2f(leftThumb.y, leftThumb.x);
+		float leftThumbAngleDegrees = leftThumbAngle * (180.0f / MY_PI);
+		if (leftThumbAngleDegrees < 0) leftThumbAngleDegrees += 360.0f;
+		// Set the player's velocity
+		if (leftThumbUsed) setVelocity(maxSpeed, leftThumbAngleDegrees);
+	}
+	else setVelocity(0, angle);
+	// Right stick handler
+	if (rightThumbUsed) {
+		// Calculate angles
+		float rightThumbAngle = atan2f(rightThumb.y, rightThumb.x);
+		float rightThumbAngleDegrees = rightThumbAngle * (180.0f / MY_PI);
+		if (rightThumbAngleDegrees < 0) rightThumbAngleDegrees += 360.0f;
+		// Control the player's shooting
+		if (rightThumbUsed) shoot(rightThumbAngleDegrees);
+	}
+}
+
 GameObject* PlayerCharacter::_createProjectile() {
 	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .001f));
 }
@@ -71,36 +105,6 @@
 		startAnimation(animations[key], true);
 }
 
-void PlayerCharacter::_updateHat() {
-	// Update the hat's position
-	hat->m_vPos = { m_vPos.x, m_vPos.y + 15, m_vPos.z - 0.01f };
-	hat->m_fRoll = 0;
-	// Check what direction the player is facing
-	if (animationDirection[0] == 'S') hat->m_nCurrentFrame = 0;
-	else if (animationDirection[0] == 'N') hat->m_nCurrentFrame = 1;
-	// And left/right direction
-	if (animationDirection[1] == 'E') {
-		hat->m_fYaw = 0;
-	}
-	else if (animationDirection[1] == 'W') {
-		hat->m_fYaw = MY_PI;
-	}
-	// Bounce the hat if we're moving
-	if (speed > 0) {
-		// Hat bounces a little with player movement
-		hat->m_vPos.y += 9 * (m_nCurrentFrame % 2);
-	}
-	if (abs(velocity.x) > 0.01f) {
-		// Hat tilts back a bit against the "wind" lol
-		hat->m_fRoll = .15f;
-	}
-}
-
-void PlayerCharacter::handleKeyboard() {
-	_handleMovementKeys();
-	_handleDirectionKeys();
-}
-
 void PlayerCharacter::_handleMovementKeys() {
 	// Handles movement keys for the character
 	if (m_pKeyboard->Down(controlMap["LEFT_" + playerID]))
@@ -140,25 +144,25 @@
 
 void PlayerCharacter::_handleDirectionKeys() {
 	// Moving of the character
-	if (m_pKeyboard->Down(controlMap["WEST_"+playerID]))
+	if (m_pKeyboard->Down(controlMap["WEST_" + playerID]))
 	{
 		// Left-Up
-		if (m_pKeyboard->Down(controlMap["NORTH_"+playerID]))
+		if (m_pKeyboard->Down(controlMap["NORTH_" + playerID]))
 			shoot(135);
 		// Left-Down
-		else if (m_pKeyboard->Down(controlMap["SOUTH_"+playerID]))
+		else if (m_pKeyboard->Down(controlMap["SOUTH_" + playerID]))
 			shoot(225);
 		// Left
 		else
 			shoot(180);
 	}
-	else if (m_pKeyboard->Down(controlMap["EAST_"+playerID]))
+	else if (m_pKeyboard->Down(controlMap["EAST_" + playerID]))
 	{
 		// Right-Up
-		if (m_pKeyboard->Down(controlMap["NORTH_"+playerID]))
+		if (m_pKeyboard->Down(controlMap["NORTH_" + playerID]))
 			shoot(45);
 		// Right-Down
-		else if (m_pKeyboard->Down(controlMap["SOUTH_"+playerID]))
+		else if (m_pKeyboard->Down(controlMap["SOUTH_" + playerID]))
 			shoot(315);
 		// Right
 		else
@@ -165,9 +169,35 @@
 			shoot(0);
 	}
 	// Down
-	else if (m_pKeyboard->Down(controlMap["SOUTH_"+playerID]))
+	else if (m_pKeyboard->Down(controlMap["SOUTH_" + playerID]))
 		shoot(270);
 	// Up
-	else if (m_pKeyboard->Down(controlMap["NORTH_"+playerID]))
+	else if (m_pKeyboard->Down(controlMap["NORTH_" + playerID]))
 		shoot(90);
-}
\ No newline at end of file
+}
+
+
+void PlayerCharacter::_updateHat() {
+	// Update the hat's position
+	hat->m_vPos = { m_vPos.x, m_vPos.y + 15, m_vPos.z - 0.01f };
+	hat->m_fRoll = 0;
+	// Check what direction the player is facing
+	if (animationDirection[0] == 'S') hat->m_nCurrentFrame = 0;
+	else if (animationDirection[0] == 'N') hat->m_nCurrentFrame = 1;
+	// And left/right direction
+	if (animationDirection[1] == 'E') {
+		hat->m_fYaw = 0;
+	}
+	else if (animationDirection[1] == 'W') {
+		hat->m_fYaw = MY_PI;
+	}
+	// Bounce the hat if we're moving
+	if (speed > 0) {
+		// Hat bounces a little with player movement
+		hat->m_vPos.y += 9 * (m_nCurrentFrame % 2);
+	}
+	if (abs(velocity.x) > 0.01f) {
+		// Hat tilts back a bit against the "wind" lol
+		hat->m_fRoll = .15f;
+	}
+}
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 55)
+++ Source/Game.cpp	(revision 56)
@@ -23,6 +23,8 @@
 	m_pRenderer->LoadImages(); //load images from xml file list
 	m_pAudio->Load(); //load the sounds for this game
 
+	if (m_pController->IsConnected()) controllerOwner = 1;
+
 	// Start the initial scene, maybe this should be a main menu?
 	// (We pass a pointer to this object because the scene has a circular
 	// reference for things such as swapping itself with another scene)
@@ -37,8 +39,11 @@
 
 	m_pAudio->BeginFrame(); //notify audio player that frame has begun
 
+	// Get key/control states
+	m_pKeyboard->GetState();
+	if (controllerOwner > -1) m_pController->GetState();
+
 	// Check for debugging keypresses
-	m_pKeyboard->GetState();
 	if (m_pKeyboard->TriggerDown(VK_F4)) displayFramerate = displayFramerate ? false : true;
 
 	m_pStepTimer->Tick([&]() {
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 55)
+++ Source/BaseLevelScene.h	(revision 56)
@@ -14,7 +14,7 @@
 	public TiledScene
 {
 public:
-	BaseLevelScene(CGame* game);
+	BaseLevelScene(CGame* game, eSpriteType ply1Hat = WIZARD_HAT, eSpriteType ply2Hat = WIZARD_HAT, bool coop = false);
 	virtual ~BaseLevelScene() override;
 	virtual void create() override;
 	virtual void update() override;
@@ -43,8 +43,12 @@
 	float spawnTime = 10;
 	float spawnRate = 10;
 	int credits = 5;
+	bool coOp;
+	PlayerCharacter* player = nullptr; // Reference to the player character
+	PlayerCharacter* player2 = nullptr; // Reference to the player character
+	eSpriteType ply1Hat;
+	eSpriteType ply2Hat;
 	Spire* spire = nullptr; // Reference to spire which must be defended
-	PlayerCharacter* player = nullptr; // Reference to the player character
 	vector<BadCharacter*> baddies;
 	GameObject* followTarget = nullptr; // What the camera follows
 	Vector3 defPos; // Default "true size" camera position
Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 55)
+++ Source/Common.cpp	(revision 56)
@@ -21,5 +21,7 @@
 	{"WEST_ONE", VK_LEFT},
 	{"EAST_ONE", VK_RIGHT},
 	// Default accept and special action keys
-	{"ACCEPT_ONE", 'E'}
+	{"ACCEPT_ONE", VK_RETURN}
 };
+
+int CCommon::controllerOwner = -1;
\ No newline at end of file
Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(nonexistent)
+++ Source/HatSelectScene.cpp	(revision 56)
@@ -0,0 +1,58 @@
+#include "HatSelectScene.h"
+#include "Game.h"
+#include "Controller.h"
+#include "BaseLevelScene.h"
+
+HatSelectScene::HatSelectScene(CGame* game) : Scene(game) {
+	hatsMenu = {
+		{"Loaf", WIZARD_HAT},
+		{"Doepler", VIKING_HAT}
+	};
+	selection = 0;
+}
+
+HatSelectScene::~HatSelectScene() {}
+
+void HatSelectScene::create() {
+	hat = addObject(new HUDObject(this, WIZARD_HAT, 0, 0, 0));
+	hat->m_fXScale = 4.0f;
+	hat->m_fYScale = 4.0f;
+}
+
+void HatSelectScene::update() {
+	hat->m_nSpriteIndex = hatsMenu[selection].second;
+	// Control the selection with keyboard
+	if (m_pKeyboard->TriggerDown(controlMap["LEFT_ONE"])) selection--;
+	else if (m_pKeyboard->TriggerDown(controlMap["RIGHT_ONE"])) selection = (selection + 1) % (int)hatsMenu.size();
+	// Control the selection with controller
+	if (controllerOwner > -1) {
+		if (controllerReady) {
+			if (m_pController->GetDPadLeft()) {
+				selection--;
+				controllerReady = false;
+			}
+			else if (m_pController->GetDPadRight()) {
+				selection = (selection + 1) % (int)hatsMenu.size();
+				controllerReady = false;
+			}
+		}
+		else if (!m_pController->GetDPadLeft() && !m_pController->GetDPadRight())
+			controllerReady = true;
+	}
+	// If it's below zero, loop selection around
+	if (selection < 0) selection = hatsMenu.size() - 1;
+
+	// Check for selection confirmation and proceed
+	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"]) || m_pController->GetButtonAToggle())
+		game->startScene(new BaseLevelScene(game, hatsMenu[selection].second));
+}
+
+void HatSelectScene::render() {
+	Scene::render();
+	m_pRenderer->setFont("title_font");
+	m_pRenderer->DrawScreenText("Choose your hat!", Vector2(330, 10), Colors::Black);
+	m_pRenderer->setFont("font");
+	m_pRenderer->DrawScreenText("(and with it, your destiny...)", Vector2(470, 100), Colors::Black);
+	float x = 640.0f - (7.0f * hatsMenu[selection].first.size());
+	m_pRenderer->DrawScreenText(hatsMenu[selection].first.c_str(), Vector2(x, 420), Colors::Black);
+}
\ No newline at end of file
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 55)
+++ Source/TitleScreenScene.cpp	(revision 56)
@@ -1,7 +1,8 @@
 #include "TitleScreenScene.h"
-#include "BaseLevelScene.h"
+#include "HatSelectScene.h"
 #include "Game.h"
 #include "Abort.h"
+#include "Controller.h"
 
 TitleScreenScene::TitleScreenScene(CGame* game) : Scene(game) {
 	menu.push_back("Play Game");
@@ -21,6 +22,29 @@
 }
 
 void TitleScreenScene::update() {
+	_handleKeyboard();
+	if (controllerOwner > -1)
+		_handleController();
+}
+
+void TitleScreenScene::render() {
+	Scene::render();
+	m_pRenderer->setFont("title_font");
+	m_pRenderer->DrawScreenText("Spire Panic!", Vector2(710, 80), Colors::OrangeRed);
+	m_pRenderer->setFont("font");
+	for (int i = 0; i < menu.size(); i++) {
+		if (i == selection) {
+			m_pRenderer->setFont("selection_font");
+			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780.0f, 180.0f + (40.0f * i)), Colors::DarkOrange);
+			m_pRenderer->setFont("font");
+		}
+		else {
+			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780.0f, 180.0f + (40.0f * i)), Colors::Orange);
+		}
+	}
+}
+
+void TitleScreenScene::_handleKeyboard() {
 	if (m_pKeyboard->TriggerDown(controlMap["UP_ONE"]))
 		if (selection > 0) selection--;
 	if (m_pKeyboard->TriggerDown(controlMap["DOWN_ONE"]))
@@ -30,7 +54,7 @@
 	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"])) {
 		if (menu[selection] == "Play Game") {
 			m_pAudio->stop();
-			game->startScene(new BaseLevelScene(game));
+			game->startScene(new HatSelectScene(game));
 		}
 		else if (menu[selection] == "Exit") {
 			game->Exit();
@@ -38,19 +62,20 @@
 	}
 }
 
-void TitleScreenScene::render() {
-	Scene::render();
-	m_pRenderer->setFont("title_font");
-	m_pRenderer->DrawScreenText("Spire Panic!", Vector2(710, 80), Colors::OrangeRed);
-	m_pRenderer->setFont("font");
-	for (int i = 0; i < menu.size(); i++) {
-		if (i == selection) {
-			m_pRenderer->setFont("selection_font");
-			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780.0f, 180.0f + (40.0f * i)), Colors::DarkOrange);
-			m_pRenderer->setFont("font");
+void TitleScreenScene::_handleController() {
+	if (m_pController->GetDPadUp())
+		if (selection > 0) selection--;
+	if (m_pController->GetDPadDown())
+		if (selection < menu.size() - 1) selection++;
+
+	// Making a selection
+	if (m_pController->GetButtonAToggle()) {
+		if (menu[selection] == "Play Game") {
+			m_pAudio->stop();
+			game->startScene(new HatSelectScene(game));
 		}
-		else {
-			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780.0f, 180.0f + (40.0f * i)), Colors::Orange);
+		else if (menu[selection] == "Exit") {
+			game->Exit();
 		}
 	}
-}
+}
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 55)
+++ Source/Source.vcxproj	(revision 56)
@@ -171,6 +171,7 @@
     <ClCompile Include="Fireball.cpp" />
     <ClCompile Include="Game.cpp" />
     <ClCompile Include="GameObject.cpp" />
+    <ClCompile Include="HatSelectScene.cpp" />
     <ClCompile Include="HUDObject.cpp" />
     <ClCompile Include="MageTower.cpp" />
     <ClCompile Include="Main.cpp" />
@@ -196,6 +197,7 @@
     <ClInclude Include="Game.h" />
     <ClInclude Include="GameDefines.h" />
     <ClInclude Include="GameObject.h" />
+    <ClInclude Include="HatSelectScene.h" />
     <ClInclude Include="HUDObject.h" />
     <ClInclude Include="MageTower.h" />
     <ClInclude Include="PlayerCharacter.h" />
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 55)
+++ Source/PlayerCharacter.h	(revision 56)
@@ -13,6 +13,7 @@
 	float getMaxSpeed() { return maxSpeed; }
 	// Keyboard handler just for the player, for use in the scenes keyboard handler
 	virtual void handleKeyboard();
+	virtual void handleController();
 protected:
 	string playerID;
 	float shootCooldown;
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 55)
+++ Source/Source.vcxproj.filters	(revision 56)
@@ -56,6 +56,9 @@
     <ClCompile Include="MageTower.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="HatSelectScene.cpp">
+      <Filter>Scenes</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -115,6 +118,9 @@
     <ClInclude Include="MageTower.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="HatSelectScene.h">
+      <Filter>Scenes</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 55)
+++ Source/BaseLevelScene.cpp	(revision 56)
@@ -7,8 +7,13 @@
 #include "MageTower.h"
 #include "RangeTower.h"
 
-BaseLevelScene::BaseLevelScene(CGame* game) :
-	TiledScene(game) {}
+BaseLevelScene::BaseLevelScene(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coOp) :
+	TiledScene(game)
+{
+	this->ply1Hat = ply1Hat;
+	this->ply2Hat = ply2Hat;
+	this->coOp = coOp;
+}
 
 BaseLevelScene::~BaseLevelScene() {}
 
@@ -25,7 +30,10 @@
 	backgroundSprite->m_fYScale = backgroundSprite->m_fYScale * 1.5f;
 	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5f;
 	// Place the player on the map
-	player = (PlayerCharacter*)addObject(new WizardPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
+	if (ply1Hat == WIZARD_HAT)
+		player = (PlayerCharacter*)addObject(new WizardPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
+	else if (ply1Hat == VIKING_HAT)
+		player = (PlayerCharacter*)addObject(new VikingPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
 	// Set the camera to follow the player
 	camFollowVision(player);
 	// Create the spire object
@@ -119,7 +127,10 @@
 	// Just check values on the keyboard :)
 
 	// Handle the main player's controls
-	player->handleKeyboard();
+	if (controllerOwner == 1)
+		player->handleController();
+	else
+		player->handleKeyboard();
 
 	// Toggle camera mode
 	if (m_pKeyboard->TriggerDown('Z'))
@@ -136,7 +147,7 @@
 			addObject(new RangeTower(this, pos.x, pos.y - 32.0f));
 			credits -= 5;
 		}
-		
+
 	}
 	if (m_pKeyboard->TriggerDown('2')) {
 		if (credits >= 10) {
@@ -262,7 +273,7 @@
 	if (tow == NULL)
 		return NULL;
 	else
-	return tow;
+		return tow;
 
 }
 
Index: Source/Common.h
===================================================================
--- Source/Common.h	(revision 55)
+++ Source/Common.h	(revision 56)
@@ -26,6 +26,8 @@
 	static CRenderer* m_pRenderer; ///< Pointer to the renderer.
 	// Game controls, name->keycode map
 	static map<string, WPARAM> controlMap;
+	// Who is using the controller, -1=Disconnected, 0=No one, 1=Player 1, 2=Player 2
+	static int controllerOwner;
 }; //CCommon
 
 // Common structures
Index: Source/HatSelectScene.h
===================================================================
--- Source/HatSelectScene.h	(nonexistent)
+++ Source/HatSelectScene.h	(revision 56)
@@ -0,0 +1,24 @@
+#pragma once
+#include <utility>
+#include <string>
+#include <vector>
+#include "Scene.h"
+
+class CGame;
+
+class HatSelectScene :
+	public Scene
+{
+public:
+	HatSelectScene(CGame* game);
+	~HatSelectScene();
+	void create() override;
+	void update() override;
+	void render() override;
+protected:
+	vector<pair<string, eSpriteType>> hatsMenu;
+	HUDObject* hat;
+	int selection;
+	bool controllerReady = true;
+};
+

------------------------------------------------------------------------
r57 | jdg0393 | 2020-11-15 21:29:13 -0600 (Sun, 15 Nov 2020) | 1 line

Gamepad wrapper for pretty debouncing of ranged inputs like sticks. Doesn't wrap all methods, but there's also no reason it can't be used in concurrently with the actual controller object.

Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 56)
+++ Source/HatSelectScene.cpp	(revision 57)
@@ -1,6 +1,7 @@
 #include "HatSelectScene.h"
 #include "Game.h"
 #include "Controller.h"
+#include "GamepadWrapper.h"
 #include "BaseLevelScene.h"
 
 HatSelectScene::HatSelectScene(CGame* game) : Scene(game) {
@@ -26,24 +27,14 @@
 	else if (m_pKeyboard->TriggerDown(controlMap["RIGHT_ONE"])) selection = (selection + 1) % (int)hatsMenu.size();
 	// Control the selection with controller
 	if (controllerOwner > -1) {
-		if (controllerReady) {
-			if (m_pController->GetDPadLeft()) {
-				selection--;
-				controllerReady = false;
-			}
-			else if (m_pController->GetDPadRight()) {
-				selection = (selection + 1) % (int)hatsMenu.size();
-				controllerReady = false;
-			}
-		}
-		else if (!m_pController->GetDPadLeft() && !m_pController->GetDPadRight())
-			controllerReady = true;
+		if (gamepad.isPressed("LSTICK_LEFT")) selection--;
+		else if (gamepad.isPressed("LSTICK_RIGHT")) selection = (selection + 1) % (int)hatsMenu.size();
 	}
 	// If it's below zero, loop selection around
-	if (selection < 0) selection = hatsMenu.size() - 1;
+	if (selection < 0) selection = (int)hatsMenu.size() - 1;
 
 	// Check for selection confirmation and proceed
-	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"]) || m_pController->GetButtonAToggle())
+	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"]) || gamepad.isPressed("BUTTON_A"))
 		game->startScene(new BaseLevelScene(game, hatsMenu[selection].second));
 }
 
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 56)
+++ Source/TitleScreenScene.cpp	(revision 57)
@@ -63,13 +63,13 @@
 }
 
 void TitleScreenScene::_handleController() {
-	if (m_pController->GetDPadUp())
+	// Selecting a menu item
+	if (gamepad.isPressed("LSTICK_UP"))
 		if (selection > 0) selection--;
-	if (m_pController->GetDPadDown())
+	if (gamepad.isPressed("LSTICK_DOWN"))
 		if (selection < menu.size() - 1) selection++;
-
-	// Making a selection
-	if (m_pController->GetButtonAToggle()) {
+	// Confirming a selection
+	if (gamepad.isPressed("BUTTON_A")) {
 		if (menu[selection] == "Play Game") {
 			m_pAudio->stop();
 			game->startScene(new HatSelectScene(game));
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 56)
+++ Source/Source.vcxproj	(revision 57)
@@ -171,6 +171,7 @@
     <ClCompile Include="Fireball.cpp" />
     <ClCompile Include="Game.cpp" />
     <ClCompile Include="GameObject.cpp" />
+    <ClCompile Include="GamepadWrapper.cpp" />
     <ClCompile Include="HatSelectScene.cpp" />
     <ClCompile Include="HUDObject.cpp" />
     <ClCompile Include="MageTower.cpp" />
@@ -197,6 +198,7 @@
     <ClInclude Include="Game.h" />
     <ClInclude Include="GameDefines.h" />
     <ClInclude Include="GameObject.h" />
+    <ClInclude Include="GamepadWrapper.h" />
     <ClInclude Include="HatSelectScene.h" />
     <ClInclude Include="HUDObject.h" />
     <ClInclude Include="MageTower.h" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 56)
+++ Source/Source.vcxproj.filters	(revision 57)
@@ -59,6 +59,7 @@
     <ClCompile Include="HatSelectScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
+    <ClCompile Include="GamepadWrapper.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -121,6 +122,7 @@
     <ClInclude Include="HatSelectScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
+    <ClInclude Include="GamepadWrapper.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Common.h
===================================================================
--- Source/Common.h	(revision 56)
+++ Source/Common.h	(revision 57)
@@ -7,6 +7,7 @@
 #include <string>
 #include "SndList.h"
 #include "ParticleEngine.h"
+#include "GamepadWrapper.h"
 
 //forward declarations to make the compiler less stroppy
 class CRenderer;
@@ -24,6 +25,8 @@
 class CCommon {
 protected:
 	static CRenderer* m_pRenderer; ///< Pointer to the renderer.
+	// Controller wrapper
+	static GamepadWrapper gamepad;
 	// Game controls, name->keycode map
 	static map<string, WPARAM> controlMap;
 	// Who is using the controller, -1=Disconnected, 0=No one, 1=Player 1, 2=Player 2
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 56)
+++ Source/Game.cpp	(revision 57)
@@ -23,7 +23,7 @@
 	m_pRenderer->LoadImages(); //load images from xml file list
 	m_pAudio->Load(); //load the sounds for this game
 
-	if (m_pController->IsConnected()) controllerOwner = 1;
+	if (gamepad.connected()) controllerOwner = 1;
 
 	// Start the initial scene, maybe this should be a main menu?
 	// (We pass a pointer to this object because the scene has a circular
@@ -41,7 +41,7 @@
 
 	// Get key/control states
 	m_pKeyboard->GetState();
-	if (controllerOwner > -1) m_pController->GetState();
+	if (controllerOwner > -1) gamepad.getState();
 
 	// Check for debugging keypresses
 	if (m_pKeyboard->TriggerDown(VK_F4)) displayFramerate = displayFramerate ? false : true;
Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 56)
+++ Source/Common.cpp	(revision 57)
@@ -7,6 +7,7 @@
 #include "Common.h"
 
 CRenderer* CCommon::m_pRenderer = nullptr;
+GamepadWrapper CCommon::gamepad;
 
 // Default controls
 map<string, WPARAM> CCommon::controlMap = {

------------------------------------------------------------------------
r58 | jdg0393 | 2020-11-16 03:57:02 -0600 (Mon, 16 Nov 2020) | 1 line

Uploading GamepadWrapper files that were missing in previous update.

Index: Source/GamepadWrapper.cpp
===================================================================
--- Source/GamepadWrapper.cpp	(nonexistent)
+++ Source/GamepadWrapper.cpp	(revision 58)
@@ -0,0 +1,113 @@
+#include "ABORT.h"
+#include "GamepadWrapper.h"
+#include "Controller.h"
+
+GamepadWrapper::GamepadWrapper() {
+	// Range button keycodes
+	rangeKeys = {
+		// Sticks as 4-directional buttons
+		"LSTICK_UP",
+		"LSTICK_DOWN",
+		"LSTICK_LEFT",
+		"LSTICK_RIGHT",
+		"RSTICK_UP",
+		"RSTICK_DOWN",
+		"RSTICK_LEFT",
+		"RSTICK_RIGHT",
+		// Triggers
+		"BUTTON_LT",
+		"BUTTON_RT"
+	};
+	// Toggle button keycodes
+	toggleKeys = {
+		// Main action buttons
+		"BUTTON_A",
+		"BUTTON_B",
+		"BUTTON_X",
+		"BUTTON_Y",
+		// Shoulder buttons
+		"BUTTON_LB",
+		"BUTTON_RB"
+	};
+	// Set the starting status of each of the range keys
+	for (auto code : rangeKeys) {
+		down[code] = false;
+		debounced[code] = false;
+	}
+	// Set the starting status of each of the toggle keys
+	for (auto code : toggleKeys) {
+		down[code] = false;
+	}
+}
+
+bool GamepadWrapper::connected() { return m_pController->IsConnected(); }
+
+void GamepadWrapper::getState() {
+	// Handle debouncing for range buttons
+	for (auto code : rangeKeys) {
+		if (down[code] && !debounced[code])
+			debounced[code] = true;
+		else if (!down[code] && debounced[code])
+			debounced[code] = false;
+	}
+
+	// Get the current state of the controller object we're wrapping
+	m_pController->GetState();
+
+	// Range buttons
+	Vector2 LThumb = m_pController->GetLThumb();
+	Vector2 RThumb = m_pController->GetRThumb();
+	down["LSTICK_UP"] = LThumb.y > 0.1f;
+	down["LSTICK_DOWN"] = LThumb.y < -0.1f;
+	down["LSTICK_LEFT"] = LThumb.x < -0.1f;
+	down["LSTICK_RIGHT"] = LThumb.x > 0.1f;
+	down["RSTICK_UP"] = RThumb.y > 0.1f;
+	down["RSTICK_DOWN"] = RThumb.y < -0.1f;
+	down["RSTICK_LEFT"] = RThumb.x < -0.1f;
+	down["RSTICK_RIGHT"] = RThumb.x > 0.1f;
+	down["BUTTON_LT"] = m_pController->GetLTrigger() > 0.1f;
+	down["BUTTON_RT"] = m_pController->GetLTrigger() > 0.1f;
+
+	// Toggle buttons
+	down["BUTTON_A"] = m_pController->GetButtonAToggle();
+	down["BUTTON_B"] = m_pController->GetButtonBToggle();
+	down["BUTTON_X"] = m_pController->GetButtonXToggle();
+	down["BUTTON_Y"] = m_pController->GetButtonYToggle();
+	down["BUTTON_LB"] = m_pController->GetButtonLSToggle();
+	down["BUTTON_RB"] = m_pController->GetButtonRSToggle();
+}
+
+bool GamepadWrapper::isHeld(std::string keycode) {
+	// isHeld can't be used with toggle buttons, kill it!
+	if (toggleKeys.count(keycode)) {
+		std::string error = "Sorry, toggle buttons like ["
+			+ keycode
+			+ "] can't be used with isHeld()!\n"
+			+ "(There's no way to see if they're held down, as they're "
+			+ "automatically debounced)\n:(\n";
+		ABORT(error.c_str());
+	}
+	return down[keycode];
+}
+
+bool GamepadWrapper::isPressed(std::string keycode) {
+	// Toggle buttons just return whether they're marked as down
+	// (because they're automatically debounced)
+	if (toggleKeys.count(keycode)) {
+		return down[keycode];
+	}
+	// Other keys check for debouncing
+	return down[keycode] && !debounced[keycode];
+}
+
+bool GamepadWrapper::isReleased(std::string keycode) {
+	// isReleased can't be used with toggle buttons, kill it!
+	if (toggleKeys.count(keycode)) {
+		std::string error = "Sorry, toggle buttons like ["
+			+ keycode
+			+ "] can't be used with isReleased()!\n"
+			+ "(There's no way to check when they're released)\n:(\n";
+		ABORT(error.c_str());
+	}
+	return !down[keycode] && debounced[keycode];
+}
\ No newline at end of file
Index: Source/GamepadWrapper.h
===================================================================
--- Source/GamepadWrapper.h	(nonexistent)
+++ Source/GamepadWrapper.h	(revision 58)
@@ -0,0 +1,22 @@
+#pragma once
+#include <map>
+#include <set>
+#include <string>
+#include <Component.h>
+
+class GamepadWrapper :
+	public CComponent
+{
+public:
+	GamepadWrapper();
+	bool connected();
+	void getState();
+	bool isHeld(std::string keycode);
+	bool isPressed(std::string keycode);
+	bool isReleased(std::string keycode);
+private:
+	std::set<std::string> rangeKeys;
+	std::set<std::string> toggleKeys;
+	std::map<std::string, bool> down;
+	std::map<std::string, bool> debounced;
+};

------------------------------------------------------------------------
r59 | jdg0393 | 2020-11-16 03:58:19 -0600 (Mon, 16 Nov 2020) | 1 line

Co-op gameplay with customizable controls and controller support. (Controller only works for player 2 at the moment)

Index: Source/TitleScreenScene.h
===================================================================
--- Source/TitleScreenScene.h	(revision 58)
+++ Source/TitleScreenScene.h	(revision 59)
@@ -17,6 +17,7 @@
 private:
 	vector<string> menu;
 	int selection = 0;
+	void _accept();
 	void _handleKeyboard();
 	void _handleController();
 };
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 58)
+++ Source/Game.cpp	(revision 59)
@@ -23,7 +23,7 @@
 	m_pRenderer->LoadImages(); //load images from xml file list
 	m_pAudio->Load(); //load the sounds for this game
 
-	if (gamepad.connected()) controllerOwner = 1;
+	if (gamepad.connected()) controllerOwner = 2;
 
 	// Start the initial scene, maybe this should be a main menu?
 	// (We pass a pointer to this object because the scene has a circular
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 58)
+++ Source/PlayerCharacter.cpp	(revision 59)
@@ -11,6 +11,8 @@
 	this->playerID = playerID;
 	// Create collision box for the player
 	m_sAabb = BoundingBox({ x,y + 4,z }, { 16,16,16 });
+	// Descriptor tags
+	tags.insert("player");
 	// Defining animations for the player
 	animations["IDLE_NE"] = AnimationDesc(HUMAN_IDLE, 0, 3, 0.15f);
 	animations["IDLE_NW"] = AnimationDesc(HUMAN_IDLE, 4, 7, 0.15f);
@@ -55,6 +57,8 @@
 	}
 }
 
+void PlayerCharacter::setPlayerID(string id) { playerID = id; }
+
 void PlayerCharacter::handleKeyboard() {
 	_handleMovementKeys();
 	_handleDirectionKeys();
Index: Source/OptionsScene.h
===================================================================
--- Source/OptionsScene.h	(nonexistent)
+++ Source/OptionsScene.h	(revision 59)
@@ -0,0 +1,22 @@
+#pragma once
+#include <string>
+#include <utility>
+#include <vector>
+#include "Scene.h"
+
+class CGame;
+
+class OptionsScene :
+    public Scene
+{
+public:
+    OptionsScene(CGame* game);
+    void update() override;
+    void render() override;
+private:
+    vector<pair<string, WPARAM>> controlsList;
+    bool controlsListSelected;
+    int selectedControl;
+    bool pending;
+};
+
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 58)
+++ Source/BaseLevelScene.h	(revision 59)
@@ -19,24 +19,27 @@
 	virtual void create() override;
 	virtual void update() override;
 	virtual void render() override;
-	void camFollowVision(GameObject* target); // Set the camera to follow a target
-	void camMapVision(); // Set the camera to center on the tilemap
+	// Starts timer to end the game
+	void endGame();
+	bool getGameOver() { return gameOver; }
 
+	// Set the camera to follow a target
+	void camFollowVision(GameObject* target, GameObject* target2 = nullptr);
+	// Set the camera to center on the tilemap
+	void camMapVision();
+
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
+	void spawnBaddie();
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
 	Spire* getSpire() { return spire; }
-
 	void setSpire(Spire* sp) { spire = sp; }
 
+	// Checks collision boxes of every object against every other object
 	void BroadPhaseClsn();
-	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
-	void cullObjects() override; //finds objects with isDead = true, remove from objlist and deallocate pointer
-	void endGame();
-	void spawnBaddie();
+	// Finds objects which are flagged to be removed and deletes them, removes from game lists
+	void cullObjects() override;
 
-	bool getGameOver() { return gameOver; }
-
 private:
 	bool gameOver = false;
 	float endTime = 0;
@@ -44,16 +47,25 @@
 	float spawnRate = 10;
 	int credits = 5;
 	bool coOp;
-	PlayerCharacter* player = nullptr; // Reference to the player character
-	PlayerCharacter* player2 = nullptr; // Reference to the player character
-	eSpriteType ply1Hat;
-	eSpriteType ply2Hat;
-	Spire* spire = nullptr; // Reference to spire which must be defended
+	// References to player characters
+	pair<PlayerCharacter*, PlayerCharacter*> players = { nullptr, nullptr };
+	pair<eSpriteType, eSpriteType> hats;
+	// Reference to spire which must be defended
+	Spire* spire = nullptr;
+	// List of enemies
 	vector<BadCharacter*> baddies;
-	GameObject* followTarget = nullptr; // What the camera follows
-	Vector3 defPos; // Default "true size" camera position
-	bool shouldFollow = false; // Whether the camera is following
+	// 1-2 objects that the camera follows
+	pair<GameObject*, GameObject*> followTargets = { nullptr, nullptr };
+	// Default "true size" camera position
+	Vector3 defPos;
+	// Whether the camera is following
+	bool shouldFollow = false;
+	// Controlling the game
 	void handleKeyboard(); // Handler for the keyboard
-	void checkPlyClsn();
+	// Creates a player object
+	void _createPlayer(PlayerCharacter*& player, eSpriteType hat, string id = "ONE");
+	// Collision handling
+	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
+	void TilemapClsn(GameObject* obj);
 };
 
Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 58)
+++ Source/Common.cpp	(revision 59)
@@ -22,7 +22,32 @@
 	{"WEST_ONE", VK_LEFT},
 	{"EAST_ONE", VK_RIGHT},
 	// Default accept and special action keys
-	{"ACCEPT_ONE", VK_RETURN}
+	{"ACCEPT_ONE", 'E'},
+	{"BACK_ONE", VK_ESCAPE},
+	// Player 2 move keys
+	{"UP_TWO", 'T'},
+	{"DOWN_TWO", 'G'},
+	{"LEFT_TWO", 'F'},
+	{"RIGHT_TWO", 'H'},
+	// Player 2 aiming keys
+	{"NORTH_TWO", 'I'},
+	{"SOUTH_TWO", 'K'},
+	{"WEST_TWO", 'J'},
+	{"EAST_TWO", 'L'},
+	// Player 2 accept key
+	{"ACCEPT_TWO", 'Y'},
+	{"BACK_TWO", 'U'},
 };
 
-int CCommon::controllerOwner = -1;
\ No newline at end of file
+int CCommon::controllerOwner = -1;
+
+map<WPARAM, string> CCommon::keyboardKeys = {
+	{'A',"A"}, {'B',"B"}, {'C',"C"}, {'D',"D"}, {'E',"E"}, {'F',"F"}, {'G',"G"}, {'H',"H"}, {'I',"I"},
+	{'J',"J"}, {'K',"K"}, {'L',"L"}, {'M',"M"}, {'N',"N"}, {'O',"O"}, {'P',"P"}, {'Q',"Q"}, {'R',"R"},
+	{'S',"S"}, {'T',"T"}, {'U',"U"}, {'V',"V"}, {'W',"W"}, {'X',"X"}, {'Y',"Y"}, {'Z',"Z"}, {'0',"0"},
+	{'1',"1"}, {'2',"2"}, {'3',"3"}, {'4',"4"}, {'5',"5"}, {'6',"6"}, {'7',"7"}, {'8',"8"}, {'9',"9"},
+	{VK_F1,"F1"}, {VK_F2,"F2"}, {VK_F3,"F3"}, {VK_F4,"F4"}, {VK_F5,"F5"}, {VK_F6,"F6"}, {VK_F7,"F7"},
+	{VK_F8,"F8"}, {VK_F9,"F9"}, {VK_F10,"F10"}, {VK_F11,"F11"}, {VK_F12,"F12"},
+	{VK_UP,"Up Arrow"}, {VK_DOWN,"Down Arrow"}, {VK_LEFT,"Left Arrow"}, {VK_RIGHT,"Right Arrow"},
+	{VK_RETURN, "Enter/Return"}, {VK_ESCAPE, "Escape"}
+};
\ No newline at end of file
Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 58)
+++ Source/HatSelectScene.cpp	(revision 59)
@@ -4,38 +4,77 @@
 #include "GamepadWrapper.h"
 #include "BaseLevelScene.h"
 
-HatSelectScene::HatSelectScene(CGame* game) : Scene(game) {
+HatSelectScene::HatSelectScene(CGame* game, bool coOp) : Scene(game) {
+	this->coOp = coOp;
 	hatsMenu = {
 		{"Loaf", WIZARD_HAT},
 		{"Doepler", VIKING_HAT}
 	};
-	selection = 0;
+	selection.first = 0;
+	selection.second = 0;
 }
 
 HatSelectScene::~HatSelectScene() {}
 
 void HatSelectScene::create() {
-	hat = addObject(new HUDObject(this, WIZARD_HAT, 0, 0, 0));
-	hat->m_fXScale = 4.0f;
-	hat->m_fYScale = 4.0f;
+	if (coOp) {
+		// Co-operative
+		hats.first = addObject(new HUDObject(this, WIZARD_HAT, -.5f, 0, 0));
+		hats.first->m_fXScale = 4.0f;
+		hats.first->m_fYScale = 4.0f;
+		// Player 2
+		hats.second = addObject(new HUDObject(this, WIZARD_HAT, .5f, 0, 0));
+		hats.second->m_fXScale = 4.0f;
+		hats.second->m_fYScale = 4.0f;
+	}
+	else {
+		// Singleplayer
+		hats.first = addObject(new HUDObject(this, WIZARD_HAT, 0, 0, 0));
+		hats.first->m_fXScale = 4.0f;
+		hats.first->m_fYScale = 4.0f;
+		hats.second = nullptr;
+	}
 }
 
 void HatSelectScene::update() {
-	hat->m_nSpriteIndex = hatsMenu[selection].second;
+	hats.first->m_nSpriteIndex = hatsMenu[selection.first].second;
 	// Control the selection with keyboard
-	if (m_pKeyboard->TriggerDown(controlMap["LEFT_ONE"])) selection--;
-	else if (m_pKeyboard->TriggerDown(controlMap["RIGHT_ONE"])) selection = (selection + 1) % (int)hatsMenu.size();
+	if (m_pKeyboard->TriggerDown(controlMap["LEFT_ONE"])) selection.first--;
+	else if (m_pKeyboard->TriggerDown(controlMap["RIGHT_ONE"])) selection.first =
+		(selection.first + 1) % (int)hatsMenu.size();
 	// Control the selection with controller
-	if (controllerOwner > -1) {
-		if (gamepad.isPressed("LSTICK_LEFT")) selection--;
-		else if (gamepad.isPressed("LSTICK_RIGHT")) selection = (selection + 1) % (int)hatsMenu.size();
+	if (controllerOwner == 1) {
+		if (gamepad.isPressed("LSTICK_LEFT")) selection.first--;
+		else if (gamepad.isPressed("LSTICK_RIGHT")) selection.first =
+			(selection.first + 1) % (int)hatsMenu.size();
 	}
 	// If it's below zero, loop selection around
-	if (selection < 0) selection = (int)hatsMenu.size() - 1;
+	if (selection.first < 0) selection.first = (int)hatsMenu.size() - 1;
 
+	// Controlling the menu for co-op player
+	if (coOp) {
+		hats.second->m_nSpriteIndex = hatsMenu[selection.second].second;
+		// Control the selection with keyboard
+		if (m_pKeyboard->TriggerDown(controlMap["LEFT_TWO"])) selection.second--;
+		else if (m_pKeyboard->TriggerDown(controlMap["RIGHT_TWO"])) selection.second =
+			(selection.second + 1) % (int)hatsMenu.size();
+		// Control the selection with controller
+		if (controllerOwner == 2) {
+			if (gamepad.isPressed("LSTICK_LEFT")) selection.second--;
+			else if (gamepad.isPressed("LSTICK_RIGHT")) selection.second =
+				(selection.second + 1) % (int)hatsMenu.size();
+		}
+		// If it's below zero, loop selection around
+		if (selection.second < 0) selection.second = (int)hatsMenu.size() - 1;
+	}
+
 	// Check for selection confirmation and proceed
-	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"]) || gamepad.isPressed("BUTTON_A"))
-		game->startScene(new BaseLevelScene(game, hatsMenu[selection].second));
+	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"]) || gamepad.isPressed("BUTTON_A")) {
+		m_pAudio->stop();
+		game->startScene(new BaseLevelScene(game,
+			hatsMenu[selection.first].second,
+			hatsMenu[selection.second].second, coOp));
+	}
 }
 
 void HatSelectScene::render() {
@@ -44,6 +83,13 @@
 	m_pRenderer->DrawScreenText("Choose your hat!", Vector2(330, 10), Colors::Black);
 	m_pRenderer->setFont("font");
 	m_pRenderer->DrawScreenText("(and with it, your destiny...)", Vector2(470, 100), Colors::Black);
-	float x = 640.0f - (7.0f * hatsMenu[selection].first.size());
-	m_pRenderer->DrawScreenText(hatsMenu[selection].first.c_str(), Vector2(x, 420), Colors::Black);
+	// Position hat name text of Player 1
+	float x = hats.first->m_vPos.x - (7.0f * hatsMenu[selection.first].first.size());
+	m_pRenderer->DrawScreenText(hatsMenu[selection.first].first.c_str(), Vector2(x, 420), Colors::Black);
+	if (coOp) {
+		// Position hat name text of Player 2
+		x = hats.second->m_vPos.x - (7.0f * hatsMenu[selection.second].first.size());
+		m_pRenderer->DrawScreenText(hatsMenu[selection.second].first.c_str(), Vector2(x, 420), Colors::Black);
+	}
+
 }
\ No newline at end of file
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 58)
+++ Source/TitleScreenScene.cpp	(revision 59)
@@ -1,11 +1,14 @@
 #include "TitleScreenScene.h"
 #include "HatSelectScene.h"
+#include "OptionsScene.h"
 #include "Game.h"
 #include "Abort.h"
 #include "Controller.h"
 
 TitleScreenScene::TitleScreenScene(CGame* game) : Scene(game) {
-	menu.push_back("Play Game");
+	menu.push_back("Play Singleplayer");
+	menu.push_back("Play Cooperative");
+	menu.push_back("Options");
 	menu.push_back("Exit");
 }
 
@@ -52,13 +55,7 @@
 
 	// Making a selection
 	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"])) {
-		if (menu[selection] == "Play Game") {
-			m_pAudio->stop();
-			game->startScene(new HatSelectScene(game));
-		}
-		else if (menu[selection] == "Exit") {
-			game->Exit();
-		}
+		_accept();
 	}
 }
 
@@ -70,12 +67,21 @@
 		if (selection < menu.size() - 1) selection++;
 	// Confirming a selection
 	if (gamepad.isPressed("BUTTON_A")) {
-		if (menu[selection] == "Play Game") {
-			m_pAudio->stop();
-			game->startScene(new HatSelectScene(game));
-		}
-		else if (menu[selection] == "Exit") {
-			game->Exit();
-		}
+		_accept();
 	}
+}
+
+void TitleScreenScene::_accept() {
+	if (menu[selection] == "Play Singleplayer") {
+		game->startScene(new HatSelectScene(game));
+	}
+	else if (menu[selection] == "Play Cooperative") {
+		game->startScene(new HatSelectScene(game, true));
+	}
+	else if (menu[selection] == "Options") {
+		game->startScene(new OptionsScene(game));
+	}
+	else if (menu[selection] == "Exit") {
+		game->Exit();
+	}
 }
\ No newline at end of file
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 58)
+++ Source/GameObject.cpp	(revision 59)
@@ -77,7 +77,7 @@
 }
 
 bool GameObject::is(string tag) {
-	return tags.find(tag) != tags.end();
+	return tags.count(tag);
 }
 
 void GameObject::startAnimation(AnimationDesc& anim, bool loop) {
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 58)
+++ Source/BadCharacter.cpp	(revision 59)
@@ -13,6 +13,7 @@
 
 	// Descriptor tags
 	tags.insert("baddie");
+	tags.insert("unpassable");
 
 	// Defining animations for the bad guy
 	animations["WALK_NE"] = AnimationDesc(GOBLIN_WALK, 0, 3, 0.15f);
Index: Source/OptionsScene.cpp
===================================================================
--- Source/OptionsScene.cpp	(nonexistent)
+++ Source/OptionsScene.cpp	(revision 59)
@@ -0,0 +1,67 @@
+#include "OptionsScene.h"
+#include "Game.h"
+
+OptionsScene::OptionsScene(CGame* game) : Scene(game)
+{
+	controlsListSelected = true;
+	selectedControl = 0;
+	pending = false;
+	// Create the controls list
+	for (auto c : controlMap) controlsList.push_back({ c.first, c.second });
+}
+
+void OptionsScene::update() {
+	if (pending) {
+		for (auto key : keyboardKeys) {
+			if (m_pKeyboard->TriggerDown(key.first)) {
+				// Update the control
+				controlMap[controlsList[selectedControl].first] = key.first;
+				controlsList[selectedControl].second = key.first;
+				// Cease pending
+				pending = false;
+			}
+		}
+	}
+	else if (controlsListSelected) {
+		// Handle the player moving through the list
+		if (m_pKeyboard->TriggerDown(controlMap["UP_ONE"])) selectedControl--;
+		else if (m_pKeyboard->TriggerDown(controlMap["DOWN_ONE"])) selectedControl++;
+		if (selectedControl >= (int)controlsList.size()) selectedControl = 0;
+		else if (selectedControl < 0) selectedControl = (int)controlsList.size() - 1;
+		// Set to pending if the player wants to change a control
+		if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"])) pending = true;
+	}
+	if (m_pKeyboard->TriggerDown(controlMap["BACK_ONE"])) {
+		game->startScene(new TitleScreenScene(game));
+	}
+}
+
+void OptionsScene::render() {
+	Scene::render();
+	// Draw the names of controls
+	for (int r = 0; r < controlsList.size(); r++) {
+		auto code = controlsList[r].first;
+		auto key = controlsList[r].second;
+		// Draw the text for the selected control
+		if (r == selectedControl) {
+			m_pRenderer->DrawScreenText(code.c_str(),
+				{ 850.0f, 16.0f + 32.0f * r }, Colors::White);
+		}
+		// Draw the text for all the unselected controls
+		else {
+			m_pRenderer->DrawScreenText(code.c_str(),
+				{ 850.0f, 16.0f + 32.0f * r }, Colors::LimeGreen);
+		}
+		if (!pending || r != selectedControl) {
+			// Draw the key currently mapped to the control
+			m_pRenderer->DrawScreenText(
+				("[ " + keyboardKeys[key] + " ]").c_str(),
+				{ 1050.0f, 16.0f + 32.0f * r }, Colors::LimeGreen);
+		}
+		else {
+			// Draw pending text
+			m_pRenderer->DrawScreenText("[ Press any key ]",
+				{ 1050.0f, 16.0f + 32.0f * r }, Colors::Red);
+		}
+	}
+}
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 58)
+++ Source/Source.vcxproj	(revision 59)
@@ -176,6 +176,7 @@
     <ClCompile Include="HUDObject.cpp" />
     <ClCompile Include="MageTower.cpp" />
     <ClCompile Include="Main.cpp" />
+    <ClCompile Include="OptionsScene.cpp" />
     <ClCompile Include="PlayerCharacter.cpp" />
     <ClCompile Include="RangeTower.cpp" />
     <ClCompile Include="Renderer.cpp" />
@@ -202,6 +203,7 @@
     <ClInclude Include="HatSelectScene.h" />
     <ClInclude Include="HUDObject.h" />
     <ClInclude Include="MageTower.h" />
+    <ClInclude Include="OptionsScene.h" />
     <ClInclude Include="PlayerCharacter.h" />
     <ClInclude Include="RangeTower.h" />
     <ClInclude Include="Renderer.h" />
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 58)
+++ Source/PlayerCharacter.h	(revision 59)
@@ -11,6 +11,7 @@
 	void update() override; // Character's update loop, runs every frame
 	void shoot(float angle_in_degrees);
 	float getMaxSpeed() { return maxSpeed; }
+	void setPlayerID(string id);
 	// Keyboard handler just for the player, for use in the scenes keyboard handler
 	virtual void handleKeyboard();
 	virtual void handleController();
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 58)
+++ Source/BaseLevelScene.cpp	(revision 59)
@@ -10,8 +10,8 @@
 BaseLevelScene::BaseLevelScene(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coOp) :
 	TiledScene(game)
 {
-	this->ply1Hat = ply1Hat;
-	this->ply2Hat = ply2Hat;
+	this->hats.first = ply1Hat;
+	this->hats.second = ply2Hat;
 	this->coOp = coOp;
 }
 
@@ -30,12 +30,13 @@
 	backgroundSprite->m_fYScale = backgroundSprite->m_fYScale * 1.5f;
 	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5f;
 	// Place the player on the map
-	if (ply1Hat == WIZARD_HAT)
-		player = (PlayerCharacter*)addObject(new WizardPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
-	else if (ply1Hat == VIKING_HAT)
-		player = (PlayerCharacter*)addObject(new VikingPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
-	// Set the camera to follow the player
-	camFollowVision(player);
+	_createPlayer(players.first, hats.first);
+	if (coOp) _createPlayer(players.second, hats.second, "TWO");
+	// Set the camera to follow the player/s
+	if (coOp)
+		camFollowVision(players.first, players.second);
+	else
+		camFollowVision(players.first);
 	// Create the spire object
 	spire = (Spire*)addObject(new Spire(this, paths["end"].x, paths["end"].y));
 }
@@ -45,12 +46,26 @@
 	handleKeyboard();
 	// Core scene update, including updating objects
 	Scene::update();
-	// Check for the player colliding with the tilemap
-	checkPlyClsn();
+	// Runs checks for object and tilemap collisions
 	BroadPhaseClsn();
 	// Update the camera position if we're following the player
-	if (followTarget)
-		m_pRenderer->SetCameraPos(Vector3(followTarget->m_vPos.x, followTarget->m_vPos.y, defPos.z / 1.5f));
+	if (shouldFollow) {
+		if (followTargets.second) {
+			Vector3 p1 = followTargets.first->getPos();
+			Vector3 p2 = followTargets.second->getPos();
+			Vector2 between = (p1 + p2) / 2.0f;
+			float dx = abs(p1.x - p2.x) * .002f;
+			float dy = abs(p1.y - p2.y) * .003f;
+			float zMod = dx > dy ? dx : dy;
+			if (zMod > 1.0f)
+				m_pRenderer->SetCameraPos({ between.x, between.y, (.66f * defPos.z) * zMod });
+			else
+				m_pRenderer->SetCameraPos({ between.x, between.y, (.66f * defPos.z) });
+		}
+		else {
+			m_pRenderer->SetCameraPos(Vector3(followTargets.first->m_vPos.x, followTargets.first->m_vPos.y, defPos.z / 1.5f));
+		}
+	}
 	// After changing camera position, make sure to adjust any HUD elements
 	adjustHUD();
 	// Delete objects that need to be culled
@@ -74,7 +89,7 @@
 	// If we are set to draw collision boxes, do that now
 	if (drawMapClsn) {
 		m_pRenderer->DrawBoundingBox(spire->m_sAabb);
-		m_pRenderer->DrawBoundingBox(player->m_sAabb);
+		m_pRenderer->DrawBoundingBox(players.first->m_sAabb);
 		for (auto obj : objectList) {
 			if (obj->is("tower")) {
 				m_pRenderer->DrawBoundingBox(obj->m_sAabb);
@@ -109,15 +124,26 @@
 	}
 }
 
-void BaseLevelScene::camFollowVision(GameObject* target) {
+void BaseLevelScene::_createPlayer(PlayerCharacter*& player, eSpriteType hat, string id) {
+	// Place the player on the map
+	if (hat == WIZARD_HAT)
+		player = (PlayerCharacter*)addObject(new WizardPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
+	else if (hat == VIKING_HAT)
+		player = (PlayerCharacter*)addObject(new VikingPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
+	player->setPlayerID(id);
+}
+
+void BaseLevelScene::camFollowVision(GameObject* target, GameObject* target2) {
 	shouldFollow = true;
-	followTarget = target;
+	followTargets.first = target;
+	followTargets.second = target2;
 }
 
 void BaseLevelScene::camMapVision() {
 	if (tileSize > 0) {
 		shouldFollow = false;
-		followTarget = nullptr;
+		followTargets.first = nullptr;
+		followTargets.second = nullptr;
 		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, defPos.z * 2.0f));
 	}
 }
@@ -126,15 +152,34 @@
 	// No need to get the keyboard state, it's done in the Game!
 	// Just check values on the keyboard :)
 
-	// Handle the main player's controls
+	// Handle Player 1 controls
 	if (controllerOwner == 1)
-		player->handleController();
+		players.first->handleController();
 	else
-		player->handleKeyboard();
+		players.first->handleKeyboard();
+	// Handle Player 2 controls
+	if (coOp) {
+		if (controllerOwner == 2)
+			players.second->handleController();
+		else
+			players.second->handleKeyboard();
+	}
 
 	// Toggle camera mode
-	if (m_pKeyboard->TriggerDown('Z'))
-		shouldFollow ? camMapVision() : camFollowVision(player);
+	if (m_pKeyboard->TriggerDown('Z')) {
+		// If we currently are zoomed in, zoom out
+		if (shouldFollow) camMapVision();
+		// If we are zoomed out, zoom in
+		else {
+			// Singleplayer or CoOp cam?
+			if (coOp) {
+				camFollowVision(players.first, players.second);
+			}
+			else {
+				camFollowVision(players.first);
+			}
+		}
+	}
 
 	// Toggle drawing of tilemap collision boxes
 	if (m_pKeyboard->TriggerDown(VK_F4))
@@ -143,7 +188,7 @@
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('1')) {
 		if (credits >= 5) {
-			Vector3 pos = player->getPos();
+			Vector3 pos = players.first->getPos();
 			addObject(new RangeTower(this, pos.x, pos.y - 32.0f));
 			credits -= 5;
 		}
@@ -151,7 +196,7 @@
 	}
 	if (m_pKeyboard->TriggerDown('2')) {
 		if (credits >= 10) {
-			Vector3 pos = player->getPos();
+			Vector3 pos = players.first->getPos();
 			addObject(new MageTower(this, pos.x, pos.y - 32.0f));
 			credits -= 10;
 		}
@@ -172,61 +217,6 @@
 	}
 }
 
-void BaseLevelScene::checkPlyClsn() {
-	// Determine if the player is colliding with the map
-	bool hit = false;
-	for (auto i = clsnBoxes.begin(); i != clsnBoxes.end() && !hit; i++)
-		hit = player->m_sAabb.Intersects(*i);
-	// Check if the play is colliding with the spire
-	if (player->m_sAabb.Intersects(spire->m_sAabb)) hit = true;
-	// If the player is colliding, move them back
-	//check if player collides with a tower
-	for (auto obj : objectList) {
-		if (obj->is("tower")) {
-			if (player->m_sAabb.Intersects(obj->m_sAabb)) hit = true;
-		}
-	}
-	if (hit)
-		player->unmove();
-}
-//creates all possible pairs of objects to pass to narrow phase
-void BaseLevelScene::BroadPhaseClsn() {
-	for (auto i : objectList) {
-		for (auto j : objectList) {
-			NarrowPhaseClsn(i, j);
-		}
-	}
-	for (auto i : clsnBoxes) {
-		for (auto j : objectList) {
-			if (j->is("projectile")) {
-				if (j->m_sAabb.Intersects(i))
-					j->kill();
-			}
-		}
-	}
-}
-//checks if 2 objects collide given their sprite type, we can add many more
-//possibilities of 2 objects colliding
-void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
-	if (obj1->m_sAabb.Intersects(obj2->m_sAabb)) {
-		if (obj1->is("projectile") && obj2->is("baddie")) {
-			obj2->kill();
-			obj1->kill();
-			credits++;
-		}
-		if (obj1->is("explosive") && obj2->is("baddie")) {	//when fireball intersects baddie, kill baddies within certain radius of fireball
-			obj1->kill();
-			for (GameObject* obj : this->getBaddies()) {
-				if (obj->inRadius(obj1->getPos(), 50.0f) && (!obj->getWillCull())) {
-					obj->kill();
-					credits++;
-				}
-			}
-
-		}
-	}
-}
-
 void BaseLevelScene::cullObjects() {
 	size_t sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
@@ -246,7 +236,7 @@
 
 // Provides the player character pointer
 PlayerCharacter* BaseLevelScene::getPlayer() {
-	return player;
+	return players.first;
 }
 
 vector<BadCharacter*> BaseLevelScene::getBaddies() {
@@ -255,7 +245,7 @@
 
 //returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
 GameObject* BaseLevelScene::getClosestTower() {
-	Vector3 playerPos = player->getPos();
+	Vector3 playerPos = players.first->getPos();
 	Vector3 towerPos;
 	GameObject* tow = NULL;
 	float difX = 1000, difY = 1000, dif = 1000;
@@ -290,3 +280,47 @@
 	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, .851f)));
 	baddies[baddies.size() - 1]->setDestinationID(sp);
 }
+
+//creates all possible pairs of objects to pass to narrow phase
+void BaseLevelScene::BroadPhaseClsn() {
+	for (auto i : objectList) {
+		for (auto j : objectList) {
+			if (i->m_sAabb.Intersects(j->m_sAabb))
+				NarrowPhaseClsn(i, j);
+		}
+	}
+	for (const auto& box : clsnBoxes) {
+		for (auto obj : objectList) {
+			if (obj->m_sAabb.Intersects(box))
+				TilemapClsn(obj);
+		}
+	}
+}
+
+
+// Handler for collisions, check for specific object types and handle collisions for them
+void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
+	// Stop the player from moving into solid objects
+	if (obj1->is("player") && obj2->is("unpassable")) ((PlayerCharacter*)obj1)->unmove();
+	// Behavior when a projectile hits an enemy
+	if (obj1->is("projectile") && obj2->is("baddie")) {
+		obj2->kill();
+		obj1->kill();
+		credits++;
+	}
+	// When explosive hits baddie, kill baddies within certain radius of fireball
+	if (obj1->is("explosive") && obj2->is("baddie")) {
+		obj1->kill();
+		for (GameObject* obj : this->getBaddies()) {
+			if (obj->inRadius(obj1->getPos(), 50.0f) && (!obj->getWillCull())) {
+				obj->kill();
+				credits++;
+			}
+		}
+	}
+}
+
+void BaseLevelScene::TilemapClsn(GameObject* obj) {
+	if (obj->is("player")) ((PlayerCharacter*)obj)->unmove();
+	if (obj->is("projectile")) obj->kill();
+}
\ No newline at end of file
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 58)
+++ Source/Source.vcxproj.filters	(revision 59)
@@ -11,9 +11,6 @@
     <ClCompile Include="GameObject.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
-    <ClCompile Include="Tower.cpp">
-      <Filter>Objects</Filter>
-    </ClCompile>
     <ClCompile Include="BaseLevelScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
@@ -50,16 +47,22 @@
     <ClCompile Include="VikingPlayer.cpp">
       <Filter>Objects\Players</Filter>
     </ClCompile>
-    <ClCompile Include="RangeTower.cpp">
-      <Filter>Objects</Filter>
+    <ClCompile Include="HatSelectScene.cpp">
+      <Filter>Scenes</Filter>
     </ClCompile>
+    <ClCompile Include="GamepadWrapper.cpp" />
     <ClCompile Include="MageTower.cpp">
-      <Filter>Objects</Filter>
+      <Filter>Objects\Towers</Filter>
     </ClCompile>
-    <ClCompile Include="HatSelectScene.cpp">
+    <ClCompile Include="RangeTower.cpp">
+      <Filter>Objects\Towers</Filter>
+    </ClCompile>
+    <ClCompile Include="Tower.cpp">
+      <Filter>Objects\Towers</Filter>
+    </ClCompile>
+    <ClCompile Include="OptionsScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
-    <ClCompile Include="GamepadWrapper.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -73,9 +76,6 @@
     <ClInclude Include="GameObject.h">
       <Filter>Objects</Filter>
     </ClInclude>
-    <ClInclude Include="Tower.h">
-      <Filter>Objects</Filter>
-    </ClInclude>
     <ClInclude Include="BaseLevelScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
@@ -113,16 +113,22 @@
     <ClInclude Include="VikingPlayer.h">
       <Filter>Objects\Players</Filter>
     </ClInclude>
+    <ClInclude Include="HatSelectScene.h">
+      <Filter>Scenes</Filter>
+    </ClInclude>
+    <ClInclude Include="GamepadWrapper.h" />
     <ClInclude Include="RangeTower.h">
-      <Filter>Objects</Filter>
+      <Filter>Objects\Towers</Filter>
     </ClInclude>
     <ClInclude Include="MageTower.h">
-      <Filter>Objects</Filter>
+      <Filter>Objects\Towers</Filter>
     </ClInclude>
-    <ClInclude Include="HatSelectScene.h">
+    <ClInclude Include="Tower.h">
+      <Filter>Objects\Towers</Filter>
+    </ClInclude>
+    <ClInclude Include="OptionsScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
-    <ClInclude Include="GamepadWrapper.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
@@ -137,5 +143,8 @@
     <Filter Include="Objects\Players">
       <UniqueIdentifier>{b5c7cfe7-d5cc-4799-b634-54a321244af7}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Objects\Towers">
+      <UniqueIdentifier>{5b908b78-61c4-4b73-a712-c3bd7c29ad34}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 58)
+++ Source/Spire.cpp	(revision 59)
@@ -10,6 +10,9 @@
 	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15f);
 	healthBar = scene->addObject(new HUDObject(scene, GREENLINE_SPRITE, 0, 0.9f, 0));
 	healthBar->relativeYScale = 10.0f;
+
+	// Descriptor tags
+	tags.insert("unpassable");
 }
 
 void Spire::update()
Index: Source/Common.h
===================================================================
--- Source/Common.h	(revision 58)
+++ Source/Common.h	(revision 59)
@@ -29,6 +29,8 @@
 	static GamepadWrapper gamepad;
 	// Game controls, name->keycode map
 	static map<string, WPARAM> controlMap;
+	// All keyboard keys that can be used in game
+	static map<WPARAM, string> keyboardKeys;
 	// Who is using the controller, -1=Disconnected, 0=No one, 1=Player 1, 2=Player 2
 	static int controllerOwner;
 }; //CCommon
Index: Source/HatSelectScene.h
===================================================================
--- Source/HatSelectScene.h	(revision 58)
+++ Source/HatSelectScene.h	(revision 59)
@@ -10,7 +10,7 @@
 	public Scene
 {
 public:
-	HatSelectScene(CGame* game);
+	HatSelectScene(CGame* game, bool coOp = false);
 	~HatSelectScene();
 	void create() override;
 	void update() override;
@@ -17,8 +17,9 @@
 	void render() override;
 protected:
 	vector<pair<string, eSpriteType>> hatsMenu;
-	HUDObject* hat;
-	int selection;
+	pair<HUDObject*, HUDObject*> hats;
+	pair<int, int> selection;
+	bool coOp;
 	bool controllerReady = true;
 };
 
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 58)
+++ Source/Tower.cpp	(revision 59)
@@ -9,9 +9,10 @@
 	objScene = scene;
 	setRoll(XM_2PI);
 	m_sAabb = BoundingBox({ x,y - 17,z }, { 12,8,4 });
+
+	// Descriptor tags
 	tags.insert("tower");
-
-
+	tags.insert("unpassable");
 }
 void Tower::update() {
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {

------------------------------------------------------------------------
r60 | jdg0393 | 2020-11-16 05:02:37 -0600 (Mon, 16 Nov 2020) | 1 line

Implemented features that form the basis of wave-based gameplay.

Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 59)
+++ Source/BaseLevelScene.h	(revision 60)
@@ -5,6 +5,7 @@
 #include "Spire.h"
 #include "Tower.h"
 #include "Fireball.h"
+#include "SpawnDesc.h"
 
 
 // Forward declarations for circular dependency
@@ -30,7 +31,7 @@
 
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
-	void spawnBaddie();
+	void waveSpawns();
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
 	Spire* getSpire() { return spire; }
 	void setSpire(Spire* sp) { spire = sp; }
@@ -43,10 +44,10 @@
 private:
 	bool gameOver = false;
 	float endTime = 0;
-	float spawnTime = 10;
-	float spawnRate = 10;
+	int wave = 1;
 	int credits = 5;
 	bool coOp;
+	SpawnDesc goblinWaves;
 	// References to player characters
 	pair<PlayerCharacter*, PlayerCharacter*> players = { nullptr, nullptr };
 	pair<eSpriteType, eSpriteType> hats;
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 59)
+++ Source/Source.vcxproj	(revision 60)
@@ -210,6 +210,7 @@
     <ClInclude Include="Scene.h" />
     <ClInclude Include="BaseLevelScene.h" />
     <ClInclude Include="Sndlist.h" />
+    <ClInclude Include="SpawnDesc.h" />
     <ClInclude Include="Spire.h" />
     <ClInclude Include="TiledScene.h" />
     <ClInclude Include="TitleScreenScene.h" />
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 59)
+++ Source/BaseLevelScene.cpp	(revision 60)
@@ -13,6 +13,16 @@
 	this->hats.first = ply1Hat;
 	this->hats.second = ply2Hat;
 	this->coOp = coOp;
+
+	goblinWaves.addPerWave = 10;
+	goblinWaves.multiplyPerWave = 1.1f;
+	goblinWaves.nextSpawn = 0.0f;
+	goblinWaves.numberSpawned = 0;
+	goblinWaves.ready = true;
+	goblinWaves.startWave = 1;
+	goblinWaves.timeAddPerSpawn = -0.1f;
+	goblinWaves.timeMultiplyPerSpawn = 0.9f;
+	goblinWaves.timeToSpawn = 3.0f;
 }
 
 BaseLevelScene::~BaseLevelScene() {}
@@ -76,11 +86,14 @@
 		m_pRenderer->SetCameraPos(defPos);
 		game->startScene(new TitleScreenScene(game));
 	}
-	// Maybe spawn some new enemies?
-	if (!gameOver && m_pStepTimer->GetTotalSeconds() > spawnTime) {
-		spawnBaddie();
-		spawnTime = m_pStepTimer->GetTotalSeconds() + spawnRate;
-		spawnRate *= .9f;
+	// Handle spawning waves
+	if (!gameOver) {
+		waveSpawns();
+		if (!goblinWaves.ready) {
+			wave++;
+			goblinWaves.numberSpawned = 0;
+			goblinWaves.ready = true;
+		}
 	}
 }
 
@@ -108,6 +121,12 @@
 		float offset = hpString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(hpString.c_str(), { 640.0f - offset, 26.0f }, Colors::White);
 
+		string waveString = "Wave " + to_string(wave);
+		offset = waveString.size() * 7.5f;
+		m_pRenderer->DrawScreenText(waveString.c_str(), { 640.0f - offset, 66.0f }, Colors::White);
+
+		m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
+
 		string credString = "Credits: " + to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 800.0f,60.0f }, Colors::White);
 
@@ -274,11 +293,33 @@
 	}
 }
 
-void BaseLevelScene::spawnBaddie() {
-	// Create some stupid bad guy
-	string sp = m_pRandom->randn(0, 1) ? "enSpawn1" : "enSpawn2";
-	baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, .851f)));
-	baddies[baddies.size() - 1]->setDestinationID(sp);
+void BaseLevelScene::waveSpawns() {
+	// If spawns are ready this wave and we're on a wave where they should appear
+	if (goblinWaves.ready && wave >= goblinWaves.startWave) {
+		int maxSpawns = (wave * goblinWaves.multiplyPerWave) + goblinWaves.addPerWave;
+		// If we haven't exceeded this waves number of spawns and if it's time to spawn
+		if (goblinWaves.numberSpawned < maxSpawns && m_pStepTimer->GetTotalSeconds() > goblinWaves.nextSpawn) {
+			// Random spawning location out of 3 possible
+			string sp = "enSpawn" + to_string(m_pRandom->randn(1, 3));
+			// Spawn the enemy
+			baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, 1.15f)));
+			// Set the enemie's destination to be their starting point initially
+			baddies[baddies.size() - 1]->setDestinationID(sp);
+
+			// Increase the number of enemies spawned
+			goblinWaves.numberSpawned++;
+			if (goblinWaves.numberSpawned >= maxSpawns) goblinWaves.ready = false;
+
+			// Calculating time until next spawn
+			float untilNextSpawn = goblinWaves.timeToSpawn
+				* powf(goblinWaves.timeMultiplyPerSpawn, (float)goblinWaves.numberSpawned)
+				+ goblinWaves.timeAddPerSpawn * goblinWaves.numberSpawned;
+			// Hard lower limit on time to spawn
+			if (untilNextSpawn < 0.25f) untilNextSpawn = 0.25f;
+			// Setting the time of next spawn
+			goblinWaves.nextSpawn = goblinWaves.nextSpawn + untilNextSpawn;
+		}
+	}
 }
 
 //creates all possible pairs of objects to pass to narrow phase
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 59)
+++ Source/Source.vcxproj.filters	(revision 60)
@@ -11,9 +11,6 @@
     <ClCompile Include="GameObject.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
-    <ClCompile Include="BaseLevelScene.cpp">
-      <Filter>Scenes</Filter>
-    </ClCompile>
     <ClCompile Include="TiledScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
@@ -63,6 +60,9 @@
     <ClCompile Include="OptionsScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
+    <ClCompile Include="BaseLevelScene.cpp">
+      <Filter>Scenes\Levels</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -76,9 +76,6 @@
     <ClInclude Include="GameObject.h">
       <Filter>Objects</Filter>
     </ClInclude>
-    <ClInclude Include="BaseLevelScene.h">
-      <Filter>Scenes</Filter>
-    </ClInclude>
     <ClInclude Include="TiledScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
@@ -129,6 +126,10 @@
     <ClInclude Include="OptionsScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
+    <ClInclude Include="BaseLevelScene.h">
+      <Filter>Scenes\Levels</Filter>
+    </ClInclude>
+    <ClInclude Include="SpawnDesc.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
@@ -146,5 +147,8 @@
     <Filter Include="Objects\Towers">
       <UniqueIdentifier>{5b908b78-61c4-4b73-a712-c3bd7c29ad34}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Scenes\Levels">
+      <UniqueIdentifier>{8aace6fe-8e58-4cdb-b790-0ee95ee2eb3d}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: Source/SpawnDesc.h
===================================================================
--- Source/SpawnDesc.h	(nonexistent)
+++ Source/SpawnDesc.h	(revision 60)
@@ -0,0 +1,15 @@
+#pragma once
+class SpawnDesc
+{
+public:
+	int startWave = 1;
+	int addPerWave = 1;
+	float multiplyPerWave = 1;
+	int numberSpawned = 0;
+	float timeToSpawn = 5.0f;
+	float timeAddPerSpawn = -0.01f;
+	float timeMultiplyPerSpawn = 1.0f;
+	float nextSpawn = 0.0f;
+	bool ready = true;
+};
+

------------------------------------------------------------------------
r61 | jdg0393 | 2020-11-16 05:18:39 -0600 (Mon, 16 Nov 2020) | 1 line

Still some bugs to sort out but in case of technical error this is a good and mostly bug-free version for Milestone 2.

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 60)
+++ Source/BaseLevelScene.cpp	(revision 61)
@@ -125,7 +125,7 @@
 		offset = waveString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(waveString.c_str(), { 640.0f - offset, 66.0f }, Colors::White);
 
-		m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
+		//m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
 
 		string credString = "Credits: " + to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 800.0f,60.0f }, Colors::White);

------------------------------------------------------------------------
r62 | jdg0393 | 2020-11-16 15:07:02 -0600 (Mon, 16 Nov 2020) | 1 line

Fixed spawn 3 and timer reset. Goblins walk around each other.

Index: Source/Character.cpp
===================================================================
--- Source/Character.cpp	(revision 61)
+++ Source/Character.cpp	(revision 62)
@@ -5,32 +5,6 @@
 {}
 Character::~Character() {}
 
-void Character::move() {
-	// Store the current position
-	oldPosition = { m_vPos.x, m_vPos.y };
-	// Get the time passed since last frame
-	const float t = m_pStepTimer->GetElapsedSeconds();
-	// Move based on velocity (in px/s) * time (in s)
-	m_vPos.x += velocity.x * t;
-	m_vPos.y += velocity.y * t;
-	// Update the bounding box location
-	m_sAabb.Center.x = m_vPos.x;
-	m_sAabb.Center.y = m_vPos.y;
-}
-
-void Character::unmove() {
-	// Store the current position
-	Vector2 nowPos = { m_vPos.x, m_vPos.y };
-	// Move back to the old position
-	m_vPos.x = oldPosition.x;
-	m_vPos.y = oldPosition.y;
-	// Set the new "old" position (which is actually where we started this frame)
-	oldPosition = nowPos;
-	// Update the bounding box location
-	m_sAabb.Center.x = m_vPos.x;
-	m_sAabb.Center.y = m_vPos.y;
-}
-
 void Character::setVelocity(float speed, float angle_in_degrees) {
 	// The desired speed
 	this->speed = speed;
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 61)
+++ Source/GameObject.cpp	(revision 62)
@@ -15,17 +15,41 @@
 
 void GameObject::update() {
 	stepAnimation();
+	move();
+}
 
+void GameObject::move() {
+	// Store the current position
+	oldPosition = { m_vPos.x, m_vPos.y };
+	// Get the time passed since last frame
 	const float t = m_pStepTimer->GetElapsedSeconds();
-	m_vPos.x += m_vVelocity.x * t;
-	m_vPos.y += m_vVelocity.y * t;	//update object position
+	// Adjusted velocity based on force velocity
+	Vector2 adjustedVelocity = velocity + forceVelocity;
+	// Move based on velocity (in px/s) * time (in s)
+	m_vPos.x += adjustedVelocity.x * t;
+	m_vPos.y += adjustedVelocity.y * t;
+	// Update the bounding box location
+	m_sAabb.Center.x = m_vPos.x;
+	m_sAabb.Center.y = m_vPos.y;
+	// Reduce the force velocity over time
+	forceVelocity /= 2;
+}
 
-	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
+void GameObject::unmove() {
+	// Store the current position
+	Vector2 nowPos = { m_vPos.x, m_vPos.y };
+	// Move back to the old position
+	m_vPos.x = oldPosition.x;
+	m_vPos.y = oldPosition.y;
+	// Set the new "old" position (which is actually where we started this frame)
+	oldPosition = nowPos;
+	// Update the bounding box location
+	m_sAabb.Center.x = m_vPos.x;
 	m_sAabb.Center.y = m_vPos.y;
 }
 
 bool GameObject::inRadius(Vector3 pos, float dist) {		//returns true if object is within dist of pos
-	if (abs(sqrt(pow(pos.x, 2) + pow(pos.y, 2)) - sqrt(pow(this->getPos().x, 2) + pow(this->getPos().y, 2))) <= dist)
+	if (abs(sqrt(pow(pos.x, 2) + pow(pos.y, 2)) - sqrt(pow(this->getPosition().x, 2) + pow(this->getPosition().y, 2))) <= dist)
 		return true;
 	else
 		return false;
@@ -32,7 +56,7 @@
 }
 void GameObject::explode() {
 	//TODO: smoke effect is not appearing for some reason
-	const Vector3 pos = this->getPos();
+	const Vector3 pos = this->getPosition();
 	printf("Smoke effect should play?\n");
 	CParticleDesc3D dExplosion;
 	dExplosion.m_nSpriteIndex = SMOKE;
@@ -63,15 +87,18 @@
 	return Vector2(sinf(m_fRoll), -cosf(m_fRoll));
 }
 
-const Vector3& GameObject::getPos() {
+const Vector3& GameObject::getPosition() {
 	return m_vPos;
 }
-void GameObject::setVel(const Vector2& v) {
-	m_vVelocity = v;
+void GameObject::setVelocity(const Vector2& v) {
+	velocity = v;
 }
-const Vector2& GameObject::getVel() {
-	return m_vVelocity;
+void GameObject::setForceVelocity(const Vector2& v) {
+	forceVelocity = v;
 }
+const Vector2& GameObject::getVelocity() {
+	return velocity;
+}
 int GameObject::getSpriteType() {
 	return m_nSpriteIndex;
 }
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 61)
+++ Source/Tower.cpp	(revision 62)
@@ -18,13 +18,13 @@
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
 		if (this->is("tower")&& this->is("mage")) {		//add conditions for other towers here, set bullet type
-			Vector3 pos = this->getPos();
+			Vector3 pos = this->getPosition();
 			//creating bullet and setting its bounding box
 			GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z));
 			fire(b);
 		}
 		else if (this->is("tower") && this->is("range")) {
-			Vector3 pos = this->getPos();
+			Vector3 pos = this->getPosition();
 			//creating bullet and setting its bounding box
 			GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z));
 			fire(b);
@@ -40,8 +40,8 @@
 
 	float difX = 1000, difY = 1000, dif = 1000;
 	for (GameObject* obj : ((BaseLevelScene*)scene)->getBaddies()) {
-		enemyPos = obj->getPos();		//enemy position
-		towerPos = this->getPos();		//tower position
+		enemyPos = obj->getPosition();		//enemy position
+		towerPos = this->getPosition();		//tower position
 
 		difX = abs(enemyPos.x - towerPos.x);		//pythagorean to find nearest enemy object
 		difY = abs(enemyPos.y - towerPos.y);
@@ -71,11 +71,11 @@
 		
 
 		//set bullet direction to enemy direction
-		const Vector3 dir = b->getPos() - target->getPos();
+		const Vector3 dir = b->getPosition() - target->getPosition();
 		b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
 		const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
 														//the direction of bullet velocity
-		b->setVel(500.0f * view);
+		b->setVelocity(500.0f * view);
 		b->setRoll(b->m_fRoll);
 	}
 	else {
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 61)
+++ Source/BadCharacter.cpp	(revision 62)
@@ -47,7 +47,7 @@
 	}
 	// If targeting the tower and within range, attack it!
 	else if (destID == "end" && m_sAabb.Intersects(level->getSpire()->m_sAabb)) {
-		Vector2 spire = level->getSpire()->getPos();
+		Vector2 spire = level->getSpire()->getPosition();
 		stopped = true;
 		attacking = true;
 		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
@@ -97,7 +97,7 @@
 	// The the bad guy is within range of his destination
 	if (destID == "end") {
 		GameObject* spire = ((BaseLevelScene*)scene)->getSpire();
-		dest = { spire->getPos().x, spire->getPos().y - 22 };
+		dest = { spire->getPosition().x, spire->getPosition().y - 22 };
 	}
 	else if (dist < 3 && paths[destID].next != "null") {
 		destID = paths[destID].next;
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 61)
+++ Source/PlayerCharacter.cpp	(revision 62)
@@ -51,7 +51,7 @@
 		Vector2 projectileVelocity = { xSpeed, ySpeed };
 		// Create the bullet object
 		GameObject* b = _createProjectile();
-		b->setVel(projectileVelocity);
+		b->setVelocity(projectileVelocity);
 		// Update the next time I can shoot
 		shootTime = m_pStepTimer->GetTotalSeconds() + shootCooldown;
 	}
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 61)
+++ Source/Fireball.cpp	(revision 62)
@@ -12,8 +12,8 @@
 void Fireball::update() {
 	stepAnimation();
 	const float t = m_pStepTimer->GetElapsedSeconds();
-	m_vPos.x += m_vVelocity.x * t;
-	m_vPos.y += m_vVelocity.y * t;	//update object position
+	m_vPos.x += velocity.x * t;
+	m_vPos.y += velocity.y * t;	//update object position
 
 	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
 	m_sAabb.Center.y = m_vPos.y;
@@ -22,7 +22,7 @@
 
 void Fireball::kill() {
 	startAnimation(explodeAnimation);
-	m_vVelocity = { 0,0,0 };
+	velocity = { 0,0,0 };
 	m_fXScale = 2.0;
 	m_fYScale = 2.0;
 }
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 61)
+++ Source/BaseLevelScene.cpp	(revision 62)
@@ -16,11 +16,11 @@
 
 	goblinWaves.addPerWave = 10;
 	goblinWaves.multiplyPerWave = 1.1f;
-	goblinWaves.nextSpawn = 0.0f;
+	goblinWaves.nextSpawn = m_pStepTimer->GetTotalSeconds();
 	goblinWaves.numberSpawned = 0;
 	goblinWaves.ready = true;
 	goblinWaves.startWave = 1;
-	goblinWaves.timeAddPerSpawn = -0.1f;
+	goblinWaves.timeAddPerSpawn = -0.01f;
 	goblinWaves.timeMultiplyPerSpawn = 0.9f;
 	goblinWaves.timeToSpawn = 3.0f;
 }
@@ -61,8 +61,8 @@
 	// Update the camera position if we're following the player
 	if (shouldFollow) {
 		if (followTargets.second) {
-			Vector3 p1 = followTargets.first->getPos();
-			Vector3 p2 = followTargets.second->getPos();
+			Vector3 p1 = followTargets.first->getPosition();
+			Vector3 p2 = followTargets.second->getPosition();
 			Vector2 between = (p1 + p2) / 2.0f;
 			float dx = abs(p1.x - p2.x) * .002f;
 			float dy = abs(p1.y - p2.y) * .003f;
@@ -89,7 +89,7 @@
 	// Handle spawning waves
 	if (!gameOver) {
 		waveSpawns();
-		if (!goblinWaves.ready) {
+		if (!goblinWaves.ready && !baddies.size()) {
 			wave++;
 			goblinWaves.numberSpawned = 0;
 			goblinWaves.ready = true;
@@ -125,7 +125,7 @@
 		offset = waveString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(waveString.c_str(), { 640.0f - offset, 66.0f }, Colors::White);
 
-		//m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
+		m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
 
 		string credString = "Credits: " + to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 800.0f,60.0f }, Colors::White);
@@ -207,7 +207,7 @@
 	//Press T to place a tower at the PC's current location
 	if (m_pKeyboard->TriggerDown('1')) {
 		if (credits >= 5) {
-			Vector3 pos = players.first->getPos();
+			Vector3 pos = players.first->getPosition();
 			addObject(new RangeTower(this, pos.x, pos.y - 32.0f));
 			credits -= 5;
 		}
@@ -215,7 +215,7 @@
 	}
 	if (m_pKeyboard->TriggerDown('2')) {
 		if (credits >= 10) {
-			Vector3 pos = players.first->getPos();
+			Vector3 pos = players.first->getPosition();
 			addObject(new MageTower(this, pos.x, pos.y - 32.0f));
 			credits -= 10;
 		}
@@ -264,13 +264,13 @@
 
 //returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
 GameObject* BaseLevelScene::getClosestTower() {
-	Vector3 playerPos = players.first->getPos();
+	Vector3 playerPos = players.first->getPosition();
 	Vector3 towerPos;
 	GameObject* tow = NULL;
 	float difX = 1000, difY = 1000, dif = 1000;
 	for (GameObject*& obj : objectList) {
 		if (obj->is("tower")) {
-			towerPos = obj->getPos();
+			towerPos = obj->getPosition();
 			difX = abs(playerPos.x - towerPos.x);
 			difY = abs(playerPos.y - towerPos.y);
 			if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif) {
@@ -315,9 +315,9 @@
 				* powf(goblinWaves.timeMultiplyPerSpawn, (float)goblinWaves.numberSpawned)
 				+ goblinWaves.timeAddPerSpawn * goblinWaves.numberSpawned;
 			// Hard lower limit on time to spawn
-			if (untilNextSpawn < 0.25f) untilNextSpawn = 0.25f;
+			if (untilNextSpawn < 1.0f) untilNextSpawn = 1.0f;
 			// Setting the time of next spawn
-			goblinWaves.nextSpawn = goblinWaves.nextSpawn + untilNextSpawn;
+			goblinWaves.nextSpawn = m_pStepTimer->GetTotalSeconds() + untilNextSpawn;
 		}
 	}
 }
@@ -326,7 +326,7 @@
 void BaseLevelScene::BroadPhaseClsn() {
 	for (auto i : objectList) {
 		for (auto j : objectList) {
-			if (i->m_sAabb.Intersects(j->m_sAabb))
+			if (i != j && i->m_sAabb.Intersects(j->m_sAabb))
 				NarrowPhaseClsn(i, j);
 		}
 	}
@@ -343,6 +343,20 @@
 void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
 	// Stop the player from moving into solid objects
 	if (obj1->is("player") && obj2->is("unpassable")) ((PlayerCharacter*)obj1)->unmove();
+	// Enemies running into each other
+	if (obj1->is("baddie") && obj2->is("baddie")) {
+		// Get the vector between the two objects positions
+		Vector2 force = obj2->getPosition() - obj1->getPosition();
+		// Get just the direction between the two objects
+		force.Normalize();
+		// Scale force to the size of the velocity to oppose it
+		force *= obj2->getVelocity().Length();
+		// Change the direction of the bad guy a little bit
+		if (force.x > force.y) force.x *= 2.5f;
+		else force.y *= 2.5f;
+		// Force the second object to go around
+		obj2->setForceVelocity(force);
+	}
 	// Behavior when a projectile hits an enemy
 	if (obj1->is("projectile") && obj2->is("baddie")) {
 		obj2->kill();
@@ -353,7 +367,7 @@
 	if (obj1->is("explosive") && obj2->is("baddie")) {
 		obj1->kill();
 		for (GameObject* obj : this->getBaddies()) {
-			if (obj->inRadius(obj1->getPos(), 50.0f) && (!obj->getWillCull())) {
+			if (obj->inRadius(obj1->getPosition(), 50.0f) && (!obj->getWillCull())) {
 				obj->kill();
 				credits++;
 			}
Index: Source/Character.h
===================================================================
--- Source/Character.h	(revision 61)
+++ Source/Character.h	(revision 62)
@@ -10,16 +10,12 @@
 public:
 	Character(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
 	virtual ~Character() override;
-	virtual void move(); // Move the character once based on their velocity
-	virtual void unmove(); // Undo the character's last movement
 	float getAngle() { return angle; } // Get the current angle in degrees
 	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
 protected:
 	// Position & motion
-	Vector2 oldPosition; // Stores the position from the previous frame
 	float angle = 0; // Angle of the character in degrees
 	float speed = 0; // Speed of the character regardless of direction
-	Vector2 velocity = { 0,0 }; // Velocity of the character, accounts for direction
 
 	// Animations
 	map<string, AnimationDesc> animations;
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 61)
+++ Source/GameObject.h	(revision 62)
@@ -22,15 +22,18 @@
 	// Motion related methods
 	void setRoll(float angle);
 	float getRoll();
-	void setVel(const Vector2& v);
-	const Vector2& getVel();
-	const Vector3& getPos();
+	void setVelocity(const Vector2& v);
+	void setForceVelocity(const Vector2& v);
+	const Vector2& getVelocity();
+	const Vector3& getPosition();
 	bool inRadius(Vector3 pos, float dist);
+	virtual void move(); // Move the character once based on their velocity
+	virtual void unmove(); // Undo the character's last movement
 
 	// Description methods
 	int getSpriteType();
 	bool is(string tag); // Checks if the game object has a certain descriptor tag
-	
+
 	// Animation methods
 	void startAnimation(AnimationDesc& anim, bool loop = false);
 	void stepAnimation();
@@ -46,7 +49,11 @@
 	void explode(); // particle effect for fireball explosion
 protected:
 	Scene* scene; // Scene which manages this object
-	Vector2 m_vVelocity = Vector2::Zero;
+	// Stores the position from the previous frame
+	Vector2 oldPosition;
+	// Speed and direction of motion
+	Vector2 velocity = Vector2::Zero;
+	Vector2 forceVelocity = Vector2::Zero;
 	bool willCull = false;
 	unordered_set<string> tags;
 	// Animation related variables

------------------------------------------------------------------------
r63 | jdg0393 | 2020-11-16 17:21:45 -0600 (Mon, 16 Nov 2020) | 1 line

New projectile handling including damage variants. Health for enemies. New death handling.

Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 62)
+++ Source/GameObject.cpp	(revision 63)
@@ -1,5 +1,6 @@
 #include "GameObject.h"
 
+GameObject::GameObject() {}
 
 GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x, float y, float z) {
 	this->scene = scene;
@@ -95,6 +96,7 @@
 }
 void GameObject::setForceVelocity(const Vector2& v) {
 	forceVelocity = v;
+	//printf("Force Velocity: %f %f\n", forceVelocity.x, forceVelocity.y);
 }
 const Vector2& GameObject::getVelocity() {
 	return velocity;
Index: Source/Character.h
===================================================================
--- Source/Character.h	(revision 62)
+++ Source/Character.h	(revision 63)
@@ -12,7 +12,13 @@
 	virtual ~Character() override;
 	float getAngle() { return angle; } // Get the current angle in degrees
 	void setVelocity(float speed, float angle_in_degrees); // Set character velocity
+	void damage(int dmg);
+	bool isDying() { return dying; }
 protected:
+	// Health of character
+	int hp = 10;
+	bool dying = false;
+
 	// Position & motion
 	float angle = 0; // Angle of the character in degrees
 	float speed = 0; // Speed of the character regardless of direction
Index: Source/Game.ico
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 62)
+++ Source/BadCharacter.cpp	(revision 63)
@@ -29,18 +29,23 @@
 
 void BadCharacter::update() {
 	// Animate the character
-	stepAnimation();
+	if (!dying)
+		stepAnimation();
 	// Set the bad guy's destination
 	_updateDestination();
-	// Check if the game is over
-	if (level->getGameOver()) {
+	// Check if the game is over or the monster is dead/dying
+	if (level->getGameOver() || hp < 0) {
 		stopped = true;
 		attacking = false;
+		dying = true;
+		if (is("unpassable")) tags.erase(tags.find("unpassable"));
 		if (m_fAlpha > 0) {
 			// Fade the bad guy out on game over
 			m_fAlpha -= .01f;
 		}
 		else {
+			// Get some money
+			level->addCredits(1);
 			// Destroy this creature once it's faded out
 			kill();
 		}
@@ -60,7 +65,8 @@
 		attacking = false;
 	}
 	// Move the bad guy
-	_updateVelocity();
+	if (!dying)
+		_updateVelocity();
 	if (!stopped) move();
 	// Updates what animation is playing
 	_updateAnimation();
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 62)
+++ Source/Source.vcxproj	(revision 63)
@@ -195,6 +195,7 @@
     <ClInclude Include="Bullet.h" />
     <ClInclude Include="Character.h" />
     <ClInclude Include="Common.h" />
+    <ClInclude Include="Explosive.h" />
     <ClInclude Include="Fireball.h" />
     <ClInclude Include="Game.h" />
     <ClInclude Include="GameDefines.h" />
@@ -205,6 +206,7 @@
     <ClInclude Include="MageTower.h" />
     <ClInclude Include="OptionsScene.h" />
     <ClInclude Include="PlayerCharacter.h" />
+    <ClInclude Include="Projectile.h" />
     <ClInclude Include="RangeTower.h" />
     <ClInclude Include="Renderer.h" />
     <ClInclude Include="Scene.h" />
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 62)
+++ Source/BaseLevelScene.cpp	(revision 63)
@@ -359,18 +359,39 @@
 	}
 	// Behavior when a projectile hits an enemy
 	if (obj1->is("projectile") && obj2->is("baddie")) {
-		obj2->kill();
-		obj1->kill();
-		credits++;
+		Projectile* p = dynamic_cast<Projectile*>(obj1);
+		BadCharacter* baddie = dynamic_cast<BadCharacter*>(obj2);
+		if (!baddie->isDying()) {
+			baddie->damage(p->damage);
+			// Knockback from the projectile
+			obj2->setForceVelocity(obj1->getVelocity());
+			// Don't kill if object is explosive, we need it's properties until it's
+			// killed in the handler for explosives
+			if (!obj1->is("explosive"))
+				obj1->kill();
+		}
 	}
 	// When explosive hits baddie, kill baddies within certain radius of fireball
 	if (obj1->is("explosive") && obj2->is("baddie")) {
-		obj1->kill();
-		for (GameObject* obj : this->getBaddies()) {
-			if (obj->inRadius(obj1->getPosition(), 50.0f) && (!obj->getWillCull())) {
-				obj->kill();
-				credits++;
+		if (!dynamic_cast<BadCharacter*>(obj2)->isDying()) {
+			// Object as an explosive
+			Explosive* expl = dynamic_cast<Explosive*>(obj1);
+			// Get all bad guys in the scene
+			for (BadCharacter* obj : this->getBaddies()) {
+				if (obj != obj2 && obj->inRadius(obj1->getPosition(), expl->radius && !obj->isDying())) {
+					// Damage the bad guy
+					obj->damage(expl->splash);
+					// Get the vector between the explosion center and the object
+					Vector2 force = obj->getPosition() - obj1->getPosition();
+					force.Normalize();
+					// Scale the knockback force
+					force *= obj1->getVelocity().Length();
+					// Apply knockback to enemy
+					obj->setForceVelocity(force);
+				}
 			}
+			// Destroy the explosive
+			obj1->kill();
 		}
 	}
 }
@@ -378,4 +399,8 @@
 void BaseLevelScene::TilemapClsn(GameObject* obj) {
 	if (obj->is("player")) ((PlayerCharacter*)obj)->unmove();
 	if (obj->is("projectile")) obj->kill();
+}
+
+void BaseLevelScene::addCredits(int amount) {
+	credits += amount;
 }
\ No newline at end of file
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 62)
+++ Source/Fireball.cpp	(revision 63)
@@ -7,24 +7,24 @@
 	tags.insert("explosive");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
 	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15f);
+	damage = 4;
+	splash = 3;
 }
 
 void Fireball::update() {
 	stepAnimation();
-	const float t = m_pStepTimer->GetElapsedSeconds();
-	m_vPos.x += velocity.x * t;
-	m_vPos.y += velocity.y * t;	//update object position
-
-	m_sAabb.Center.x = m_vPos.x;	//update bounding box pos
-	m_sAabb.Center.y = m_vPos.y;
-
+	if (!detonated) move();
 }
 
 void Fireball::kill() {
 	startAnimation(explodeAnimation);
-	velocity = { 0,0,0 };
+	// Size of the explosion
 	m_fXScale = 2.0;
 	m_fYScale = 2.0;
+	// Set damage to nothing after initial hit
+	detonated = true;
+	damage = 0;
+	splash = 0;
 }
 
 void Fireball::onAnimationComplete(AnimationDesc& anim) {
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 62)
+++ Source/Source.vcxproj.filters	(revision 63)
@@ -26,12 +26,6 @@
     <ClCompile Include="Spire.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
-    <ClCompile Include="Bullet.cpp">
-      <Filter>Objects</Filter>
-    </ClCompile>
-    <ClCompile Include="Fireball.cpp">
-      <Filter>Objects</Filter>
-    </ClCompile>
     <ClCompile Include="HUDObject.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
@@ -63,6 +57,12 @@
     <ClCompile Include="BaseLevelScene.cpp">
       <Filter>Scenes\Levels</Filter>
     </ClCompile>
+    <ClCompile Include="Bullet.cpp">
+      <Filter>Objects\Projectiles</Filter>
+    </ClCompile>
+    <ClCompile Include="Fireball.cpp">
+      <Filter>Objects\Projectiles</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -91,13 +91,7 @@
     <ClInclude Include="Spire.h">
       <Filter>Objects</Filter>
     </ClInclude>
-    <ClInclude Include="Bullet.h">
-      <Filter>Objects</Filter>
-    </ClInclude>
     <ClInclude Include="AnimationDesc.h" />
-    <ClInclude Include="Fireball.h">
-      <Filter>Objects</Filter>
-    </ClInclude>
     <ClInclude Include="HUDObject.h">
       <Filter>Objects</Filter>
     </ClInclude>
@@ -130,6 +124,18 @@
       <Filter>Scenes\Levels</Filter>
     </ClInclude>
     <ClInclude Include="SpawnDesc.h" />
+    <ClInclude Include="Bullet.h">
+      <Filter>Objects\Projectiles</Filter>
+    </ClInclude>
+    <ClInclude Include="Fireball.h">
+      <Filter>Objects\Projectiles</Filter>
+    </ClInclude>
+    <ClInclude Include="Explosive.h">
+      <Filter>Properties</Filter>
+    </ClInclude>
+    <ClInclude Include="Projectile.h">
+      <Filter>Properties</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
@@ -150,5 +156,11 @@
     <Filter Include="Scenes\Levels">
       <UniqueIdentifier>{8aace6fe-8e58-4cdb-b790-0ee95ee2eb3d}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Objects\Projectiles">
+      <UniqueIdentifier>{a94f225f-267b-4eac-8fb2-cd2265d2e4bc}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Properties">
+      <UniqueIdentifier>{318ac610-e21c-47b3-99df-21107ddeaea4}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: Source/Explosive.h
===================================================================
--- Source/Explosive.h	(nonexistent)
+++ Source/Explosive.h	(revision 63)
@@ -0,0 +1,12 @@
+#pragma once
+#include "GameObject.h"
+
+class Explosive : virtual public GameObject
+{
+public:
+	Explosive() {}
+	float radius = 20.0f;
+	int splash = 1;
+	bool detonated = false;
+};
+
Index: Source/Bullet.h
===================================================================
--- Source/Bullet.h	(revision 62)
+++ Source/Bullet.h	(revision 63)
@@ -1,7 +1,9 @@
 #pragma once
 #include "GameObject.h"
+#include "Projectile.h"
+
 class Bullet :
-    public GameObject
+    public Projectile
 {
 public:
     Bullet(Scene* scene, float x = 0, float y = 0, float z = 0);
Index: Source/Character.cpp
===================================================================
--- Source/Character.cpp	(revision 62)
+++ Source/Character.cpp	(revision 63)
@@ -59,4 +59,8 @@
 	if (animationDirection != oldDirection) onChangedAnimationDirection();
 }
 
-void Character::onChangedAnimationDirection() {}
\ No newline at end of file
+void Character::onChangedAnimationDirection() {}
+
+void Character::damage(int dmg) {
+	hp -= dmg;
+}
\ No newline at end of file
Index: Source/Projectile.h
===================================================================
--- Source/Projectile.h	(nonexistent)
+++ Source/Projectile.h	(revision 63)
@@ -0,0 +1,12 @@
+#pragma once
+#include "GameObject.h"
+
+class Projectile : virtual public GameObject
+{
+public:
+	Projectile() {}
+	int damage = 1;
+	float range = 100.0f;
+	float traveled = 0.0f;
+};
+
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 62)
+++ Source/GameObject.h	(revision 63)
@@ -14,6 +14,7 @@
 class GameObject : public CComponent, public CSpriteDesc3D, public CCommon
 {
 public:
+	GameObject();
 	// Constructor with default position
 	GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x = 0.0f, float y = 0.0f, float z = 0.0f);
 	virtual ~GameObject();
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 62)
+++ Source/BaseLevelScene.h	(revision 63)
@@ -29,6 +29,8 @@
 	// Set the camera to center on the tilemap
 	void camMapVision();
 
+	void addCredits(int amount);
+
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
 	void waveSpawns();
Index: Source/Fireball.h
===================================================================
--- Source/Fireball.h	(revision 62)
+++ Source/Fireball.h	(revision 63)
@@ -1,16 +1,19 @@
 #pragma once
 #include "AnimationDesc.h"
 #include "GameObject.h"
+#include "Projectile.h"
+#include "Explosive.h"
 #include "Tower.h"
 
 class Fireball :
-    public GameObject
+	public Projectile,
+	public Explosive
 {
 public:
-    Fireball(Scene* scene, float x = 0, float y = 0, float z = 0);
-    void update() override;
-    void kill() override;
-    void onAnimationComplete(AnimationDesc& anim) override;
+	Fireball(Scene* scene, float x = 0, float y = 0, float z = 0);
+	void update() override;
+	void kill() override;
+	void onAnimationComplete(AnimationDesc& anim) override;
 protected:
-    AnimationDesc explodeAnimation;
+	AnimationDesc explodeAnimation;
 };
\ No newline at end of file
Index: Source/Bullet.cpp
===================================================================
--- Source/Bullet.cpp	(revision 62)
+++ Source/Bullet.cpp	(revision 63)
@@ -5,4 +5,5 @@
 {
 	tags.insert("projectile");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
+	damage = 10;
 }

------------------------------------------------------------------------
r64 | jdg0393 | 2020-11-16 17:58:13 -0600 (Mon, 16 Nov 2020) | 1 line

Minor fix of following issues: forgot to remove debug statement, no fallback for player 1 to use controller

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 63)
+++ Source/BaseLevelScene.cpp	(revision 64)
@@ -125,7 +125,7 @@
 		offset = waveString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(waveString.c_str(), { 640.0f - offset, 66.0f }, Colors::White);
 
-		m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
+		//m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
 
 		string credString = "Credits: " + to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 800.0f,60.0f }, Colors::White);
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 63)
+++ Source/TitleScreenScene.cpp	(revision 64)
@@ -73,6 +73,8 @@
 
 void TitleScreenScene::_accept() {
 	if (menu[selection] == "Play Singleplayer") {
+		if (controllerOwner == 2)
+			controllerOwner = 1;
 		game->startScene(new HatSelectScene(game));
 	}
 	else if (menu[selection] == "Play Cooperative") {

------------------------------------------------------------------------
r65 | amm0837 | 2020-11-16 18:13:14 -0600 (Mon, 16 Nov 2020) | 1 line

added tower upgrade feature

Index: Source/MageTower.cpp
===================================================================
--- Source/MageTower.cpp	(revision 64)
+++ Source/MageTower.cpp	(revision 65)
@@ -1,12 +1,22 @@
 #include "MageTower.h"
 
-MageTower::MageTower(Scene* scene, float x, float y, float z) :
-	Tower(scene, MAGE1, x, y, z) {
+MageTower::MageTower(Scene* scene,eSpriteType t, float level, float x, float y, float z) :
+	Tower(scene, t, x, y, z) {
 
 	tags.insert("mage");
-
+	if (level == 0)
+		tags.insert("lvl0");
+	else if (level == 1)
+		tags.insert("lvl1");
+	else if (level == 2)
+		tags.insert("lvl2");
+	lvl = level;
 }
 
 void MageTower::update() {
 	Tower::update();
+}
+
+float MageTower::getLevel() {
+	return lvl;
 }
\ No newline at end of file
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 64)
+++ Source/GameObject.cpp	(revision 65)
@@ -49,6 +49,13 @@
 	m_sAabb.Center.y = m_vPos.y;
 }
 
+void GameObject::upgradeSprite(GameObject* obj) {
+	//eSpriteType t = eSpriteType(obj->getSpriteType());
+	if (obj->is("range")) {
+		
+	}
+}
+
 bool GameObject::inRadius(Vector3 pos, float dist) {		//returns true if object is within dist of pos
 	if (abs(sqrt(pow(pos.x, 2) + pow(pos.y, 2)) - sqrt(pow(this->getPosition().x, 2) + pow(this->getPosition().y, 2))) <= dist)
 		return true;
Index: Source/RangeTower.cpp
===================================================================
--- Source/RangeTower.cpp	(revision 64)
+++ Source/RangeTower.cpp	(revision 65)
@@ -1,11 +1,21 @@
 #include "RangeTower.h"
 
-RangeTower::RangeTower(Scene* scene, float x, float y,float z) :
-	Tower(scene, RANGE1, x, y, z) {
+RangeTower::RangeTower(Scene* scene, eSpriteType t, float level, float x, float y,float z) :
+	Tower(scene, t, x, y, z) {
 	
 	tags.insert("range");
+	if (level == 0)
+		tags.insert("lvl0");
+	else if (level == 1)
+		tags.insert("lvl1");
+	else if(level == 2)
+		tags.insert("lvl2");
+	lvl = level;
 }
 
 void RangeTower::update() {
 	Tower::update();
+}
+float RangeTower::getLevel() {
+	return lvl;
 }
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 64)
+++ Source/BaseLevelScene.cpp	(revision 65)
@@ -130,7 +130,7 @@
 		string credString = "Credits: " + to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 800.0f,60.0f }, Colors::White);
 
-		string priceString = "Range Tower: Press 1 (5 credits)\nMage Tower: Press 2 (10 credits)";
+		string priceString = "Range Tower: Press 1 (5 credits)\nMage Tower: Press 2 (10 credits)\nPress 'U' to upgrade a tower";
 		m_pRenderer->DrawScreenText(priceString.c_str(), { 100.0f,60.0f }, Colors::White);
 	}
 	else {
@@ -208,7 +208,7 @@
 	if (m_pKeyboard->TriggerDown('1')) {
 		if (credits >= 5) {
 			Vector3 pos = players.first->getPosition();
-			addObject(new RangeTower(this, pos.x, pos.y - 32.0f));
+			addObject(new RangeTower(this,RANGE1, 0, pos.x, pos.y - 32.0f));
 			credits -= 5;
 		}
 
@@ -216,12 +216,51 @@
 	if (m_pKeyboard->TriggerDown('2')) {
 		if (credits >= 10) {
 			Vector3 pos = players.first->getPosition();
-			addObject(new MageTower(this, pos.x, pos.y - 32.0f));
+			addObject(new MageTower(this, MAGE1, 0, pos.x, pos.y - 32.0f));
 			credits -= 10;
 		}
 	}
 
+	if (m_pKeyboard->TriggerDown('U')) {
+		
+		GameObject* tow = getClosestTower();
+		if (tow != NULL) {
+			if (tow->is("range")) {
+				if (tow->is("lvl0")) {
+					if (credits >= 10) {
+						addObject(new RangeTower(this, RANGE2, 1, tow->getPosition().x, tow->getPosition().y));
+						tow->kill();
+						credits -= 10;
+					}
+				}
+				if (tow->is("lvl1")) {
+					if (credits >= 20) {		
+						addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
+						tow->kill();
+						credits -= 20;
+					}
+				}
+			}
+			if (tow->is("mage")) {
+				if (tow->is("lvl0")) {
+					if (credits >= 15) {			
+						addObject(new MageTower(this, MAGE2, 1, tow->getPosition().x, tow->getPosition().y));
+						tow->kill();
+						credits -= 15;
+					}
+				}
+				if (tow->is("lvl1")) {
+					if (credits >= 30) {
+						addObject(new MageTower(this, MAGE3, 2, tow->getPosition().x, tow->getPosition().y));
+						tow->kill();
+						credits -= 30;
+					}
+				}
+			}
+		}
+	}
 
+
 	if (m_pKeyboard->TriggerDown('X')) {
 		GameObject* tow = getClosestTower();
 		if (tow != NULL) {
@@ -378,7 +417,7 @@
 			Explosive* expl = dynamic_cast<Explosive*>(obj1);
 			// Get all bad guys in the scene
 			for (BadCharacter* obj : this->getBaddies()) {
-				if (obj != obj2 && obj->inRadius(obj1->getPosition(), expl->radius && !obj->isDying())) {
+				if (obj != obj2 && obj->inRadius(obj1->getPosition(), expl->radius )&& !obj->isDying()) {
 					// Damage the bad guy
 					obj->damage(expl->splash);
 					// Get the vector between the explosion center and the object
Index: Source/MageTower.h
===================================================================
--- Source/MageTower.h	(revision 64)
+++ Source/MageTower.h	(revision 65)
@@ -6,9 +6,10 @@
 	public Tower {
 
 public:
-	MageTower(Scene* scene, float x, float y, float z = 1.14);
+	MageTower(Scene* scene,eSpriteType t, float level, float x, float y, float z = 1.14);
 	virtual void update();
+	float getLevel();
 private:
-	
+	float lvl;
 
 };
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 64)
+++ Source/GameObject.h	(revision 65)
@@ -46,7 +46,7 @@
 	Vector2 getViewVect();
 	bool getWillCull(); //true if dead, false otherwise
 	virtual void kill(); // set isdead flag to true;
-
+	void upgradeSprite(GameObject* obj);
 	void explode(); // particle effect for fireball explosion
 protected:
 	Scene* scene; // Scene which manages this object
Index: Source/RangeTower.h
===================================================================
--- Source/RangeTower.h	(revision 64)
+++ Source/RangeTower.h	(revision 65)
@@ -6,8 +6,9 @@
 	public Tower {
 
 public:
-	RangeTower(Scene* scene, float x, float y,float z = 1.14);
+	RangeTower(Scene* scene,eSpriteType t, float level, float x, float y,float z = 1.14);
 	virtual void update();
+	float getLevel();
 private:
-	
+	float lvl;
 };
Index: Source/Explosive.h
===================================================================
--- Source/Explosive.h	(revision 64)
+++ Source/Explosive.h	(revision 65)
@@ -5,7 +5,7 @@
 {
 public:
 	Explosive() {}
-	float radius = 20.0f;
+	float radius = 50.0f;
 	int splash = 1;
 	bool detonated = false;
 };
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 64)
+++ Source/BaseLevelScene.h	(revision 65)
@@ -47,7 +47,7 @@
 	bool gameOver = false;
 	float endTime = 0;
 	int wave = 1;
-	int credits = 5;
+	int credits = 10;
 	bool coOp;
 	SpawnDesc goblinWaves;
 	// References to player characters

------------------------------------------------------------------------
r68 | jdg0393 | 2020-11-21 04:38:35 -0600 (Sat, 21 Nov 2020) | 1 line

Created inherited baddie classes.

Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 67)
+++ Source/Source.vcxproj	(revision 68)
@@ -165,6 +165,8 @@
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="BadCharacter.cpp" />
+    <ClCompile Include="BadGoblin.cpp" />
+    <ClCompile Include="BadMinotaur.cpp" />
     <ClCompile Include="Bullet.cpp" />
     <ClCompile Include="Character.cpp" />
     <ClCompile Include="Common.cpp" />
@@ -192,6 +194,8 @@
   <ItemGroup>
     <ClInclude Include="AnimationDesc.h" />
     <ClInclude Include="BadCharacter.h" />
+    <ClInclude Include="BadGoblin.h" />
+    <ClInclude Include="BadMinotaur.h" />
     <ClInclude Include="Bullet.h" />
     <ClInclude Include="Character.h" />
     <ClInclude Include="Common.h" />
Index: Source/BadMinotaur.h
===================================================================
--- Source/BadMinotaur.h	(nonexistent)
+++ Source/BadMinotaur.h	(revision 68)
@@ -0,0 +1,11 @@
+#pragma once
+#include "BadCharacter.h"
+class BadMinotaur :
+	public BadCharacter
+{
+public:
+	BadMinotaur(Scene* scene, float x = 0, float y = 0, float z = 1.15);
+	~BadMinotaur() override;
+private:
+};
+
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 67)
+++ Source/BaseLevelScene.cpp	(revision 68)
@@ -6,6 +6,8 @@
 #include "WizardPlayer.h"
 #include "MageTower.h"
 #include "RangeTower.h"
+#include "BadGoblin.h"
+#include "BadMinotaur.h"
 
 BaseLevelScene::BaseLevelScene(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coOp) :
 	TiledScene(game)
@@ -341,7 +343,7 @@
 			// Random spawning location out of 3 possible
 			string sp = "enSpawn" + to_string(m_pRandom->randn(1, 3));
 			// Spawn the enemy
-			baddies.push_back((BadCharacter*)addObject(new BadCharacter(this, paths[sp].x, paths[sp].y, 1.15f)));
+			baddies.push_back((BadCharacter*)addObject(new BadMinotaur(this, paths[sp].x, paths[sp].y, 1.15f)));
 			// Set the enemie's destination to be their starting point initially
 			baddies[baddies.size() - 1]->setDestinationID(sp);
 
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 67)
+++ Source/Source.vcxproj.filters	(revision 68)
@@ -17,9 +17,6 @@
     <ClCompile Include="Character.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
-    <ClCompile Include="BadCharacter.cpp">
-      <Filter>Objects</Filter>
-    </ClCompile>
     <ClCompile Include="TitleScreenScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
@@ -63,6 +60,15 @@
     <ClCompile Include="Fireball.cpp">
       <Filter>Objects\Projectiles</Filter>
     </ClCompile>
+    <ClCompile Include="BadCharacter.cpp">
+      <Filter>Objects\Baddies</Filter>
+    </ClCompile>
+    <ClCompile Include="BadGoblin.cpp">
+      <Filter>Objects\Baddies</Filter>
+    </ClCompile>
+    <ClCompile Include="BadMinotaur.cpp">
+      <Filter>Objects\Baddies</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -82,9 +88,6 @@
     <ClInclude Include="Character.h">
       <Filter>Objects</Filter>
     </ClInclude>
-    <ClInclude Include="BadCharacter.h">
-      <Filter>Objects</Filter>
-    </ClInclude>
     <ClInclude Include="TitleScreenScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
@@ -136,6 +139,15 @@
     <ClInclude Include="Projectile.h">
       <Filter>Properties</Filter>
     </ClInclude>
+    <ClInclude Include="BadCharacter.h">
+      <Filter>Objects\Baddies</Filter>
+    </ClInclude>
+    <ClInclude Include="BadGoblin.h">
+      <Filter>Objects\Baddies</Filter>
+    </ClInclude>
+    <ClInclude Include="BadMinotaur.h">
+      <Filter>Objects\Baddies</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
@@ -162,5 +174,8 @@
     <Filter Include="Properties">
       <UniqueIdentifier>{318ac610-e21c-47b3-99df-21107ddeaea4}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Objects\Baddies">
+      <UniqueIdentifier>{081718fd-0d90-4eb6-a936-1f139a8a3e71}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: Source/BadGoblin.h
===================================================================
--- Source/BadGoblin.h	(nonexistent)
+++ Source/BadGoblin.h	(revision 68)
@@ -0,0 +1,11 @@
+#pragma once
+#include "BadCharacter.h"
+class BadGoblin :
+	public BadCharacter
+{
+public:
+	BadGoblin(Scene* scene, float x = 0, float y = 0, float z = 1.15);
+	~BadGoblin() override;
+private:
+};
+
Index: Source/BadMinotaur.cpp
===================================================================
--- Source/BadMinotaur.cpp	(nonexistent)
+++ Source/BadMinotaur.cpp	(revision 68)
@@ -0,0 +1,17 @@
+#include "BadMinotaur.h"
+#include "BaseLevelScene.h"
+
+BadMinotaur::BadMinotaur(Scene* scene, float x, float y, float z) :
+	BadCharacter(scene, x, y, z)
+{
+	// Defining animations for the bad guy
+	animations["WALK_NE"] = AnimationDesc(MINOTAUR_WALK, 0, 5, 0.15f);
+	animations["WALK_NW"] = AnimationDesc(MINOTAUR_WALK, 6, 11, 0.15f);
+	animations["WALK_SW"] = AnimationDesc(MINOTAUR_WALK, 12, 17, 0.15f);
+	animations["WALK_SE"] = AnimationDesc(MINOTAUR_WALK, 18, 23, 0.15f);
+	animations["ATTACK_NE"] = AnimationDesc(MINOTAUR_ATTACK, 0, 7, 0.15f);
+	animations["ATTACK_NW"] = AnimationDesc(MINOTAUR_ATTACK, 8, 15, 0.15f);
+	animations["ATTACK_SW"] = AnimationDesc(MINOTAUR_ATTACK, 16, 23, 0.15f);
+	animations["ATTACK_SE"] = AnimationDesc(MINOTAUR_ATTACK, 24, 31, 0.15f);
+}
+BadMinotaur::~BadMinotaur() {}
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 67)
+++ Source/Renderer.cpp	(revision 68)
@@ -34,10 +34,6 @@
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(VIKING_HAT, "viking_hat");
 	Load(WIZARD_HAT, "wizard_hat");
-	Load(HUMAN_IDLE, "human_idle");
-	Load(HUMAN_WALK, "human_walk");
-	Load(GOBLIN_WALK, "goblin_walk");
-	Load(GOBLIN_ATTACK, "goblin_attack");
 	Load(BULLET1, "bullet1");
 	Load(SPIRE_BASE, "spire_base");
 	Load(SPIRE_PEAK, "spire_peak");
@@ -50,6 +46,13 @@
 	Load(FIREBALL, "fireball");
 	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
+	// Characters
+	Load(HUMAN_IDLE, "human_idle");
+	Load(HUMAN_WALK, "human_walk");
+	Load(GOBLIN_WALK, "goblin_walk");
+	Load(GOBLIN_ATTACK, "goblin_attack");
+	Load(MINOTAUR_WALK, "minotaur_walk");
+	Load(MINOTAUR_ATTACK, "minotaur_attack");
 	// Load any additional fonts
 	loadNewFont("title_font");
 	loadNewFont("selection_font");
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 67)
+++ Source/BadCharacter.h	(revision 68)
@@ -9,9 +9,9 @@
 	public Character
 {
 public:
-	bool stopped = false;
-	bool attacking = false;
-	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.16);
+	bool isStopped = false;
+	bool isAttacking = false;
+	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15);
 	virtual ~BadCharacter() override;
 	virtual void update() override;
 	void setDestination(float x, float y);
@@ -18,8 +18,8 @@
 	void setDestinationID(string id);
 protected:
 	BaseLevelScene* level = nullptr;
-	float cooldown = .6f;
-	float cooldown_time = 0;
+	float attackCooldown = .6f;
+	float nextAttackTime = 0;
 	map<string, PathPoint> paths;
 	Vector2 dest = { 0,0 };
 	string destID = "";
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 67)
+++ Source/GameDefines.h	(revision 68)
@@ -16,10 +16,6 @@
 	SIMPLE_TILE,
 	VIKING_HAT,
 	WIZARD_HAT,
-	HUMAN_IDLE,
-	HUMAN_WALK,
-	GOBLIN_WALK,
-	GOBLIN_ATTACK,
 	BULLET1,
 	SPIRE_BASE,
 	SPIRE_PEAK,
@@ -32,5 +28,12 @@
 	FIREBALL,
 	EXPLOSION,
 	SMOKE,
+	// Characters
+	HUMAN_IDLE,
+	HUMAN_WALK,
+	GOBLIN_WALK,
+	GOBLIN_ATTACK,
+	MINOTAUR_WALK,
+	MINOTAUR_ATTACK,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/BadGoblin.cpp
===================================================================
--- Source/BadGoblin.cpp	(nonexistent)
+++ Source/BadGoblin.cpp	(revision 68)
@@ -0,0 +1,17 @@
+#include "BadGoblin.h"
+#include "BaseLevelScene.h"
+
+BadGoblin::BadGoblin(Scene* scene, float x, float y, float z) :
+	BadCharacter(scene, x, y, z)
+{
+	// Defining animations for the bad guy
+	animations["WALK_NE"] = AnimationDesc(GOBLIN_WALK, 0, 3, 0.15f);
+	animations["WALK_NW"] = AnimationDesc(GOBLIN_WALK, 4, 7, 0.15f);
+	animations["WALK_SW"] = AnimationDesc(GOBLIN_WALK, 8, 11, 0.15f);
+	animations["WALK_SE"] = AnimationDesc(GOBLIN_WALK, 12, 15, 0.15f);
+	animations["ATTACK_NE"] = AnimationDesc(GOBLIN_ATTACK, 0, 3, 0.15f);
+	animations["ATTACK_NW"] = AnimationDesc(GOBLIN_ATTACK, 4, 7, 0.15f);
+	animations["ATTACK_SW"] = AnimationDesc(GOBLIN_ATTACK, 8, 11, 0.15f);
+	animations["ATTACK_SE"] = AnimationDesc(GOBLIN_ATTACK, 12, 15, 0.15f);
+}
+BadGoblin::~BadGoblin() {}
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 67)
+++ Source/BadCharacter.cpp	(revision 68)
@@ -2,7 +2,7 @@
 #include "BaseLevelScene.h"
 
 BadCharacter::BadCharacter(Scene* scene, float x, float y, float z) :
-	Character(scene, GOBLIN_WALK, x, y, z)
+	Character(scene, BLACK_SQUARE, x, y, z)
 {
 	// Track the scene as a level scene
 	level = (BaseLevelScene*)scene;
@@ -14,16 +14,6 @@
 	// Descriptor tags
 	tags.insert("baddie");
 	tags.insert("unpassable");
-
-	// Defining animations for the bad guy
-	animations["WALK_NE"] = AnimationDesc(GOBLIN_WALK, 0, 3, 0.15f);
-	animations["WALK_NW"] = AnimationDesc(GOBLIN_WALK, 4, 7, 0.15f);
-	animations["WALK_SW"] = AnimationDesc(GOBLIN_WALK, 8, 11, 0.15f);
-	animations["WALK_SE"] = AnimationDesc(GOBLIN_WALK, 12, 15, 0.15f);
-	animations["ATTACK_NE"] = AnimationDesc(GOBLIN_ATTACK, 0, 3, 0.15f);
-	animations["ATTACK_NW"] = AnimationDesc(GOBLIN_ATTACK, 4, 7, 0.15f);
-	animations["ATTACK_SW"] = AnimationDesc(GOBLIN_ATTACK, 8, 11, 0.15f);
-	animations["ATTACK_SE"] = AnimationDesc(GOBLIN_ATTACK, 12, 15, 0.15f);
 }
 BadCharacter::~BadCharacter() {}
 
@@ -35,8 +25,8 @@
 	_updateDestination();
 	// Check if the game is over or the monster is dead/dying
 	if (level->getGameOver() || hp < 0) {
-		stopped = true;
-		attacking = false;
+		isStopped = true;
+		isAttacking = false;
 		dying = true;
 		if (is("unpassable")) tags.erase(tags.find("unpassable"));
 		if (m_fAlpha > 0) {
@@ -53,21 +43,21 @@
 	// If targeting the tower and within range, attack it!
 	else if (destID == "end" && m_sAabb.Intersects(level->getSpire()->m_sAabb)) {
 		Vector2 spire = level->getSpire()->getPosition();
-		stopped = true;
-		attacking = true;
-		if (m_pStepTimer->GetTotalSeconds() > cooldown_time) {
+		isStopped = true;
+		isAttacking = true;
+		if (m_pStepTimer->GetTotalSeconds() > nextAttackTime) {
 			level->getSpire()->hp -= 20;
-			cooldown_time = m_pStepTimer->GetTotalSeconds() + cooldown;
+			nextAttackTime = m_pStepTimer->GetTotalSeconds() + attackCooldown;
 		}
 	}
 	else {
-		stopped = false;
-		attacking = false;
+		isStopped = false;
+		isAttacking = false;
 	}
 	// Move the bad guy
 	if (!dying)
 		_updateVelocity();
-	if (!stopped) move();
+	if (!isStopped) move();
 	// Updates what animation is playing
 	_updateAnimation();
 }
@@ -76,7 +66,7 @@
 	string key = "";
 
 	// Possible animation prefixes
-	if (attacking) key += "ATTACK_";
+	if (isAttacking) key += "ATTACK_";
 	else key += "WALK_";
 
 	// Set the direction of the animation

------------------------------------------------------------------------
r69 | jdg0393 | 2020-11-21 06:22:16 -0600 (Sat, 21 Nov 2020) | 1 line

WaveSpawner class and multi-enemy type management.

Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 68)
+++ Source/Source.vcxproj	(revision 69)
@@ -189,6 +189,7 @@
     <ClCompile Include="TitleScreenScene.cpp" />
     <ClCompile Include="Tower.cpp" />
     <ClCompile Include="VikingPlayer.cpp" />
+    <ClCompile Include="WaveSpawner.cpp" />
     <ClCompile Include="WizardPlayer.cpp" />
   </ItemGroup>
   <ItemGroup>
@@ -222,6 +223,7 @@
     <ClInclude Include="TitleScreenScene.h" />
     <ClInclude Include="Tower.h" />
     <ClInclude Include="VikingPlayer.h" />
+    <ClInclude Include="WaveSpawner.h" />
     <ClInclude Include="WizardPlayer.h" />
   </ItemGroup>
   <ItemGroup>
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 68)
+++ Source/Source.vcxproj.filters	(revision 69)
@@ -69,6 +69,7 @@
     <ClCompile Include="BadMinotaur.cpp">
       <Filter>Objects\Baddies</Filter>
     </ClCompile>
+    <ClCompile Include="WaveSpawner.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -148,6 +149,7 @@
     <ClInclude Include="BadMinotaur.h">
       <Filter>Objects\Baddies</Filter>
     </ClInclude>
+    <ClInclude Include="WaveSpawner.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 68)
+++ Source/GameObject.h	(revision 69)
@@ -27,6 +27,7 @@
 	void setForceVelocity(const Vector2& v);
 	const Vector2& getVelocity();
 	const Vector3& getPosition();
+	void setPosition(const Vector3& pos);
 	bool inRadius(Vector3 pos, float dist);
 	virtual void move(); // Move the character once based on their velocity
 	virtual void unmove(); // Undo the character's last movement
Index: Source/WaveSpawner.h
===================================================================
--- Source/WaveSpawner.h	(nonexistent)
+++ Source/WaveSpawner.h	(revision 69)
@@ -0,0 +1,25 @@
+#pragma once
+#include <string>
+#include <vector>
+#include "Component.h"
+#include "BadCharacter.h"
+#include "SpawnDesc.h"
+
+class BaseLevelScene;
+
+class WaveSpawner : CComponent
+{
+public:
+	WaveSpawner(BaseLevelScene* level);
+	void update();
+	int getWaveNumber();
+	bool isWaveComplete();
+	void addSpawnDesc(SpawnDesc spawnType);
+	void nextWave();
+	BadCharacter* spawnSwitch(string key);
+private:
+	BaseLevelScene* level;
+	vector<SpawnDesc> spawns;
+	int wave = 1;
+};
+
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 68)
+++ Source/BaseLevelScene.h	(revision 69)
@@ -6,6 +6,7 @@
 #include "Tower.h"
 #include "Fireball.h"
 #include "SpawnDesc.h"
+#include "WaveSpawner.h"
 
 
 // Forward declarations for circular dependency
@@ -29,11 +30,11 @@
 	// Set the camera to center on the tilemap
 	void camMapVision();
 
+	BadCharacter* addBaddie(BadCharacter* baddie);
 	void addCredits(int amount);
 
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	GameObject* getClosestTower();//returns the tower closest to the PC
-	void waveSpawns();
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
 	Spire* getSpire() { return spire; }
 	void setSpire(Spire* sp) { spire = sp; }
@@ -46,10 +47,9 @@
 private:
 	bool gameOver = false;
 	float endTime = 0;
-	int wave = 1;
 	int credits = 10;
 	bool coOp;
-	SpawnDesc goblinWaves;
+	WaveSpawner* waves = nullptr;
 	// References to player characters
 	pair<PlayerCharacter*, PlayerCharacter*> players = { nullptr, nullptr };
 	pair<eSpriteType, eSpriteType> hats;
Index: Source/SpawnDesc.h
===================================================================
--- Source/SpawnDesc.h	(revision 68)
+++ Source/SpawnDesc.h	(revision 69)
@@ -1,7 +1,10 @@
 #pragma once
+#include <string>
+
 class SpawnDesc
 {
 public:
+	string key = "goblin";
 	int startWave = 1;
 	int addPerWave = 1;
 	float multiplyPerWave = 1;
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 68)
+++ Source/GameObject.cpp	(revision 69)
@@ -52,7 +52,7 @@
 void GameObject::upgradeSprite(GameObject* obj) {
 	//eSpriteType t = eSpriteType(obj->getSpriteType());
 	if (obj->is("range")) {
-		
+
 	}
 }
 
@@ -98,6 +98,11 @@
 const Vector3& GameObject::getPosition() {
 	return m_vPos;
 }
+
+void GameObject::setPosition(const Vector3& pos) {
+	m_vPos = pos;
+}
+
 void GameObject::setVelocity(const Vector2& v) {
 	velocity = v;
 }
Index: Source/WaveSpawner.cpp
===================================================================
--- Source/WaveSpawner.cpp	(nonexistent)
+++ Source/WaveSpawner.cpp	(revision 69)
@@ -0,0 +1,92 @@
+#include "WaveSpawner.h"
+#include "BaseLevelScene.h"
+#include "BadGoblin.h"
+#include "BadMinotaur.h"
+
+WaveSpawner::WaveSpawner(BaseLevelScene* level) {
+	this->level = level;
+}
+
+void WaveSpawner::update() {
+	// For each of the spawn descriptors, update the spawn state
+	for (auto& spawnState : spawns) {
+		// Any spawn descriptor for which we have not reached the first wave should be marked not ready
+		if (wave < spawnState.startWave) spawnState.ready = false;
+		// If these spawns are ready
+		if (spawnState.ready) {
+			int waveOffset = wave - spawnState.startWave + 1;
+			int maxSpawns = (waveOffset * spawnState.addPerWave) + pow(spawnState.multiplyPerWave, waveOffset);
+
+			// If we haven't exceeded this waves max number of spawns and if it's time to spawn
+			if (spawnState.numberSpawned < maxSpawns && m_pStepTimer->GetTotalSeconds() > spawnState.nextSpawn) {
+
+				// Random spawning location out of 3 possible
+				string sp = "enSpawn" + to_string(m_pRandom->randn(1, 3));
+				// Retrieve paths for starting points from level
+				map<string, PathPoint> paths = level->getPaths();
+
+				// Create the baddie object
+				BadCharacter* baddie = level->addBaddie(spawnSwitch(spawnState.key));
+				// A little bit of random offset on spawn to keep enemies from stacking on each other
+				float yoffset = m_pRandom->randf();
+				float xoffset = m_pRandom->randf();
+				// Move the enemy to a spawn point
+				baddie->setPosition({ paths[sp].x + xoffset, paths[sp].y + yoffset, 1.15f });
+				// Set the enemie's destination to be their starting point initially
+				baddie->setDestinationID(sp);
+
+				// Increase the counter of number of enemies spawned
+				spawnState.numberSpawned++;
+				if (spawnState.numberSpawned >= maxSpawns) spawnState.ready = false;
+
+				// Calculating time until next spawn
+				float untilNextSpawn = spawnState.timeToSpawn
+					* powf(spawnState.timeMultiplyPerSpawn, (float)spawnState.numberSpawned)
+					+ spawnState.timeAddPerSpawn * spawnState.numberSpawned;
+				// Hard lower limit on time to spawn
+				if (untilNextSpawn < 1.0f) untilNextSpawn = 1.0f;
+				// Setting the time of next spawn
+				spawnState.nextSpawn = m_pStepTimer->GetTotalSeconds() + untilNextSpawn;
+			}
+		}
+	}
+}
+
+int WaveSpawner::getWaveNumber() {
+	return wave;
+}
+
+bool WaveSpawner::isWaveComplete() {
+	for (const auto& spawnState : spawns) {
+		if (spawnState.ready) {
+			return false;
+		}
+	}
+	return true;
+}
+
+void WaveSpawner::addSpawnDesc(SpawnDesc spawnType) {
+	spawns.push_back(spawnType);
+}
+
+void WaveSpawner::nextWave() {
+	// Update the wave number
+	wave++;
+	// Reset each of the spawn state's counters and ready them
+	for (auto& spawnState : spawns) {
+		spawnState.numberSpawned = 0;
+		spawnState.ready = true;
+	}
+}
+
+BadCharacter* WaveSpawner::spawnSwitch(string key) {
+	if (key == "goblin") {
+		return new BadGoblin(level);
+	}
+	else if (key == "minotaur") {
+		return new BadMinotaur(level);
+	}
+	else {
+		ABORT("Tried to spawn a baddie with an invalid key!");
+	}
+}
\ No newline at end of file
Index: Source/BadMinotaur.cpp
===================================================================
--- Source/BadMinotaur.cpp	(revision 68)
+++ Source/BadMinotaur.cpp	(revision 69)
@@ -4,6 +4,8 @@
 BadMinotaur::BadMinotaur(Scene* scene, float x, float y, float z) :
 	BadCharacter(scene, x, y, z)
 {
+	// Minotaur has big HP
+	hp = 35;
 	// Defining animations for the bad guy
 	animations["WALK_NE"] = AnimationDesc(MINOTAUR_WALK, 0, 5, 0.15f);
 	animations["WALK_NW"] = AnimationDesc(MINOTAUR_WALK, 6, 11, 0.15f);
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 68)
+++ Source/BaseLevelScene.cpp	(revision 69)
@@ -15,19 +15,38 @@
 	this->hats.first = ply1Hat;
 	this->hats.second = ply2Hat;
 	this->coOp = coOp;
+	waves = new WaveSpawner(this);
 
-	goblinWaves.addPerWave = 10;
-	goblinWaves.multiplyPerWave = 1.1f;
-	goblinWaves.nextSpawn = m_pStepTimer->GetTotalSeconds();
-	goblinWaves.numberSpawned = 0;
-	goblinWaves.ready = true;
-	goblinWaves.startWave = 1;
-	goblinWaves.timeAddPerSpawn = -0.01f;
-	goblinWaves.timeMultiplyPerSpawn = 0.9f;
-	goblinWaves.timeToSpawn = 3.0f;
+	// Define some spawn descriptors for the wave spawner
+	SpawnDesc goblins;
+	goblins.addPerWave = 10;
+	goblins.multiplyPerWave = 1.1f;
+	goblins.nextSpawn = m_pStepTimer->GetTotalSeconds();
+	goblins.numberSpawned = 0;
+	goblins.ready = true;
+	goblins.startWave = 1;
+	goblins.timeAddPerSpawn = -0.01f;
+	goblins.timeMultiplyPerSpawn = 0.9f;
+	goblins.timeToSpawn = 3.0f;
+	SpawnDesc minotaurs;
+	minotaurs.key = "minotaur";
+	minotaurs.addPerWave = 3;
+	minotaurs.multiplyPerWave = 1.2f;
+	minotaurs.nextSpawn = m_pStepTimer->GetTotalSeconds() + 6.0f;
+	minotaurs.numberSpawned = 0;
+	minotaurs.ready = true;
+	minotaurs.startWave = 2;
+	minotaurs.timeAddPerSpawn = -3.0f;
+	minotaurs.timeMultiplyPerSpawn = 1.0f;
+	minotaurs.timeToSpawn = 12.0f;
+	// Add the spawn descriptions
+	waves->addSpawnDesc(goblins);
+	waves->addSpawnDesc(minotaurs);
 }
 
-BaseLevelScene::~BaseLevelScene() {}
+BaseLevelScene::~BaseLevelScene() {
+	delete waves;
+}
 
 void BaseLevelScene::create() {
 	// Play some music
@@ -88,13 +107,13 @@
 		m_pRenderer->SetCameraPos(defPos);
 		game->startScene(new TitleScreenScene(game));
 	}
+
 	// Handle spawning waves
 	if (!gameOver) {
-		waveSpawns();
-		if (!goblinWaves.ready && !baddies.size()) {
-			wave++;
-			goblinWaves.numberSpawned = 0;
-			goblinWaves.ready = true;
+		waves->update();
+		// If the wave is done spawning and all the baddies are killed, progress to the next wave
+		if (waves->isWaveComplete() && !baddies.size()) {
+			waves->nextWave();
 		}
 	}
 }
@@ -123,7 +142,7 @@
 		float offset = hpString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(hpString.c_str(), { 640.0f - offset, 26.0f }, Colors::White);
 
-		string waveString = "Wave " + to_string(wave);
+		string waveString = "Wave " + to_string(waves->getWaveNumber());
 		offset = waveString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(waveString.c_str(), { 640.0f - offset, 66.0f }, Colors::White);
 
@@ -210,7 +229,7 @@
 	if (m_pKeyboard->TriggerDown('1')) {
 		if (credits >= 5) {
 			Vector3 pos = players.first->getPosition();
-			addObject(new RangeTower(this,RANGE1, 0, pos.x, pos.y - 32.0f));
+			addObject(new RangeTower(this, RANGE1, 0, pos.x, pos.y - 32.0f));
 			credits -= 5;
 		}
 
@@ -224,7 +243,7 @@
 	}
 
 	if (m_pKeyboard->TriggerDown('U')) {
-		
+
 		GameObject* tow = getClosestTower();
 		if (tow != NULL) {
 			if (tow->is("range")) {
@@ -236,7 +255,7 @@
 					}
 				}
 				if (tow->is("lvl1")) {
-					if (credits >= 20) {		
+					if (credits >= 20) {
 						addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
 						tow->kill();
 						credits -= 20;
@@ -245,7 +264,7 @@
 			}
 			if (tow->is("mage")) {
 				if (tow->is("lvl0")) {
-					if (credits >= 15) {			
+					if (credits >= 15) {
 						addObject(new MageTower(this, MAGE2, 1, tow->getPosition().x, tow->getPosition().y));
 						tow->kill();
 						credits -= 15;
@@ -299,6 +318,12 @@
 	return players.first;
 }
 
+BadCharacter* BaseLevelScene::addBaddie(BadCharacter* baddie) {
+	addObject((GameObject*)baddie);
+	baddies.push_back(baddie);
+	return baddie;
+}
+
 vector<BadCharacter*> BaseLevelScene::getBaddies() {
 	return baddies;
 }
@@ -334,35 +359,35 @@
 	}
 }
 
-void BaseLevelScene::waveSpawns() {
-	// If spawns are ready this wave and we're on a wave where they should appear
-	if (goblinWaves.ready && wave >= goblinWaves.startWave) {
-		int maxSpawns = (wave * goblinWaves.multiplyPerWave) + goblinWaves.addPerWave;
-		// If we haven't exceeded this waves number of spawns and if it's time to spawn
-		if (goblinWaves.numberSpawned < maxSpawns && m_pStepTimer->GetTotalSeconds() > goblinWaves.nextSpawn) {
-			// Random spawning location out of 3 possible
-			string sp = "enSpawn" + to_string(m_pRandom->randn(1, 3));
-			// Spawn the enemy
-			baddies.push_back((BadCharacter*)addObject(new BadMinotaur(this, paths[sp].x, paths[sp].y, 1.15f)));
-			// Set the enemie's destination to be their starting point initially
-			baddies[baddies.size() - 1]->setDestinationID(sp);
+//void BaseLevelScene::waveSpawns() {
+//	// If spawns are ready this wave and we're on a wave where they should appear
+//	if (goblinWaves.ready && wave >= goblinWaves.startWave) {
+//		int maxSpawns = (wave * goblinWaves.multiplyPerWave) + goblinWaves.addPerWave;
+//		// If we haven't exceeded this waves number of spawns and if it's time to spawn
+//		if (goblinWaves.numberSpawned < maxSpawns && m_pStepTimer->GetTotalSeconds() > goblinWaves.nextSpawn) {
+//			// Random spawning location out of 3 possible
+//			string sp = "enSpawn" + to_string(m_pRandom->randn(1, 3));
+//			// Spawn the enemy
+//			baddies.push_back((BadCharacter*)addObject(new BadMinotaur(this, paths[sp].x, paths[sp].y, 1.15f)));
+//			// Set the enemie's destination to be their starting point initially
+//			baddies[baddies.size() - 1]->setDestinationID(sp);
+//
+//			// Increase the number of enemies spawned
+//			goblinWaves.numberSpawned++;
+//			if (goblinWaves.numberSpawned >= maxSpawns) goblinWaves.ready = false;
+//
+//			// Calculating time until next spawn
+//			float untilNextSpawn = goblinWaves.timeToSpawn
+//				* powf(goblinWaves.timeMultiplyPerSpawn, (float)goblinWaves.numberSpawned)
+//				+ goblinWaves.timeAddPerSpawn * goblinWaves.numberSpawned;
+//			// Hard lower limit on time to spawn
+//			if (untilNextSpawn < 1.0f) untilNextSpawn = 1.0f;
+//			// Setting the time of next spawn
+//			goblinWaves.nextSpawn = m_pStepTimer->GetTotalSeconds() + untilNextSpawn;
+//		}
+//	}
+//}
 
-			// Increase the number of enemies spawned
-			goblinWaves.numberSpawned++;
-			if (goblinWaves.numberSpawned >= maxSpawns) goblinWaves.ready = false;
-
-			// Calculating time until next spawn
-			float untilNextSpawn = goblinWaves.timeToSpawn
-				* powf(goblinWaves.timeMultiplyPerSpawn, (float)goblinWaves.numberSpawned)
-				+ goblinWaves.timeAddPerSpawn * goblinWaves.numberSpawned;
-			// Hard lower limit on time to spawn
-			if (untilNextSpawn < 1.0f) untilNextSpawn = 1.0f;
-			// Setting the time of next spawn
-			goblinWaves.nextSpawn = m_pStepTimer->GetTotalSeconds() + untilNextSpawn;
-		}
-	}
-}
-
 //creates all possible pairs of objects to pass to narrow phase
 void BaseLevelScene::BroadPhaseClsn() {
 	for (auto i : objectList) {
@@ -419,7 +444,7 @@
 			Explosive* expl = dynamic_cast<Explosive*>(obj1);
 			// Get all bad guys in the scene
 			for (BadCharacter* obj : this->getBaddies()) {
-				if (obj != obj2 && obj->inRadius(obj1->getPosition(), expl->radius )&& !obj->isDying()) {
+				if (obj != obj2 && obj->inRadius(obj1->getPosition(), expl->radius) && !obj->isDying()) {
 					// Damage the bad guy
 					obj->damage(expl->splash);
 					// Get the vector between the explosion center and the object

------------------------------------------------------------------------
r70 | jdg0393 | 2020-11-21 22:11:25 -0600 (Sat, 21 Nov 2020) | 1 line

Slightly improved the utility of control mapping.

Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 69)
+++ Source/Common.cpp	(revision 70)
@@ -12,31 +12,35 @@
 // Default controls
 map<string, WPARAM> CCommon::controlMap = {
 	// Default movement and menu navigation controls
-	{"UP_ONE", 'W'},
-	{"DOWN_ONE", 'S'},
-	{"LEFT_ONE", 'A'},
-	{"RIGHT_ONE", 'D'},
+	{"PLAYER1_UP", 'W'},
+	{"PLAYER1_DOWN", 'S'},
+	{"PLAYER1_LEFT", 'A'},
+	{"PLAYER1_RIGHT", 'D'},
 	// Default aiming and directional activation keys
-	{"NORTH_ONE", VK_UP},
-	{"SOUTH_ONE", VK_DOWN},
-	{"WEST_ONE", VK_LEFT},
-	{"EAST_ONE", VK_RIGHT},
+	{"PLAYER1_AIM_NORTH", VK_UP},
+	{"PLAYER1_AIM_SOUTH", VK_DOWN},
+	{"PLAYER1_AIM_WEST", VK_LEFT},
+	{"PLAYER1_AIM_EAST", VK_RIGHT},
 	// Default accept and special action keys
-	{"ACCEPT_ONE", 'E'},
-	{"BACK_ONE", VK_ESCAPE},
+	{"PLAYER1_ACCEPT", 'E'},
+	{"PLAYER1_BACK", VK_ESCAPE},
 	// Player 2 move keys
-	{"UP_TWO", 'T'},
-	{"DOWN_TWO", 'G'},
-	{"LEFT_TWO", 'F'},
-	{"RIGHT_TWO", 'H'},
+	{"PLAYER2_UP", 'T'},
+	{"PLAYER2_DOWN", 'G'},
+	{"PLAYER2_LEFT", 'F'},
+	{"PLAYER2_RIGHT", 'H'},
 	// Player 2 aiming keys
-	{"NORTH_TWO", 'I'},
-	{"SOUTH_TWO", 'K'},
-	{"WEST_TWO", 'J'},
-	{"EAST_TWO", 'L'},
+	{"PLAYER2_AIM_NORTH", 'I'},
+	{"PLAYER2_AIM_SOUTH", 'K'},
+	{"PLAYER2_AIM_WEST", 'J'},
+	{"PLAYER2_AIM_EAST", 'L'},
 	// Player 2 accept key
-	{"ACCEPT_TWO", 'Y'},
-	{"BACK_TWO", 'U'},
+	{"PLAYER2_ACCEPT", 'Y'},
+	{"PLAYER2_BACK", 'U'},
+	// Debugging keys
+	{"DEBUG_ZOOM", 'Z'},
+	{"DEBUG_SHOW_CLSN", VK_F4},
+	{"DEBUG_SHOW_FPS", VK_F4}
 };
 
 int CCommon::controllerOwner = -1;
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 69)
+++ Source/TitleScreenScene.cpp	(revision 70)
@@ -48,13 +48,13 @@
 }
 
 void TitleScreenScene::_handleKeyboard() {
-	if (m_pKeyboard->TriggerDown(controlMap["UP_ONE"]))
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_UP"]))
 		if (selection > 0) selection--;
-	if (m_pKeyboard->TriggerDown(controlMap["DOWN_ONE"]))
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_DOWN"]))
 		if (selection < menu.size() - 1) selection++;
 
 	// Making a selection
-	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"])) {
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_ACCEPT"])) {
 		_accept();
 	}
 }
Index: Source/OptionsScene.cpp
===================================================================
--- Source/OptionsScene.cpp	(revision 69)
+++ Source/OptionsScene.cpp	(revision 70)
@@ -24,14 +24,14 @@
 	}
 	else if (controlsListSelected) {
 		// Handle the player moving through the list
-		if (m_pKeyboard->TriggerDown(controlMap["UP_ONE"])) selectedControl--;
-		else if (m_pKeyboard->TriggerDown(controlMap["DOWN_ONE"])) selectedControl++;
+		if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_UP"])) selectedControl--;
+		else if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_DOWN"])) selectedControl++;
 		if (selectedControl >= (int)controlsList.size()) selectedControl = 0;
 		else if (selectedControl < 0) selectedControl = (int)controlsList.size() - 1;
 		// Set to pending if the player wants to change a control
-		if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"])) pending = true;
+		if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_ACCEPT"])) pending = true;
 	}
-	if (m_pKeyboard->TriggerDown(controlMap["BACK_ONE"])) {
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_BACK"])) {
 		game->startScene(new TitleScreenScene(game));
 	}
 }
@@ -38,30 +38,49 @@
 
 void OptionsScene::render() {
 	Scene::render();
+	render_controls();
+	string prompts = "Use "
+		+ keyboardKeys[controlMap["PLAYER1_UP"]] + " and "
+		+ keyboardKeys[controlMap["PLAYER1_DOWN"]]
+		+ " to select a control.\n"
+		+ "Press "
+		+ keyboardKeys[controlMap["PLAYER1_ACCEPT"]]
+		+ " to modify the selected control.\n"
+		+ "Press "
+		+ keyboardKeys[controlMap["PLAYER1_BACK"]]
+		+ " to exit this menu...\n";
+	m_pRenderer->DrawScreenText(prompts.c_str(), { 15,15 }, Colors::LimeGreen);
+}
+
+void OptionsScene::render_controls() {
+	float keysXOffset = 800.0f;
 	// Draw the names of controls
 	for (int r = 0; r < controlsList.size(); r++) {
 		auto code = controlsList[r].first;
 		auto key = controlsList[r].second;
+		// Calculate the Y position
+		int offset = selectedControl - r;
+		float y = 344.0f - (offset * 32);
 		// Draw the text for the selected control
 		if (r == selectedControl) {
 			m_pRenderer->DrawScreenText(code.c_str(),
-				{ 850.0f, 16.0f + 32.0f * r }, Colors::White);
+				{ keysXOffset, y }, Colors::White);
 		}
 		// Draw the text for all the unselected controls
 		else {
 			m_pRenderer->DrawScreenText(code.c_str(),
-				{ 850.0f, 16.0f + 32.0f * r }, Colors::LimeGreen);
+				{ keysXOffset, y }, Colors::LimeGreen);
 		}
 		if (!pending || r != selectedControl) {
 			// Draw the key currently mapped to the control
 			m_pRenderer->DrawScreenText(
 				("[ " + keyboardKeys[key] + " ]").c_str(),
-				{ 1050.0f, 16.0f + 32.0f * r }, Colors::LimeGreen);
+				{ 1050.0f, y }, Colors::LimeGreen);
 		}
 		else {
 			// Draw pending text
 			m_pRenderer->DrawScreenText("[ Press any key ]",
-				{ 1050.0f, 16.0f + 32.0f * r }, Colors::Red);
+				{ 1050.0f, y }, Colors::Red);
 		}
 	}
 }
\ No newline at end of file
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 69)
+++ Source/PlayerCharacter.h	(revision 70)
@@ -7,7 +7,7 @@
 	public Character
 {
 public:
-	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15, string playerID = "ONE");
+	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15, string playerID = "PLAYER1");
 	void update() override; // Character's update loop, runs every frame
 	void shoot(float angle_in_degrees);
 	float getMaxSpeed() { return maxSpeed; }
Index: Source/OptionsScene.h
===================================================================
--- Source/OptionsScene.h	(revision 69)
+++ Source/OptionsScene.h	(revision 70)
@@ -7,16 +7,17 @@
 class CGame;
 
 class OptionsScene :
-    public Scene
+	public Scene
 {
 public:
-    OptionsScene(CGame* game);
-    void update() override;
-    void render() override;
+	OptionsScene(CGame* game);
+	void update() override;
+	void render() override;
 private:
-    vector<pair<string, WPARAM>> controlsList;
-    bool controlsListSelected;
-    int selectedControl;
-    bool pending;
+	vector<pair<string, WPARAM>> controlsList;
+	bool controlsListSelected;
+	int selectedControl;
+	bool pending;
+	void render_controls();
 };
 
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 69)
+++ Source/BaseLevelScene.h	(revision 70)
@@ -66,7 +66,7 @@
 	// Controlling the game
 	void handleKeyboard(); // Handler for the keyboard
 	// Creates a player object
-	void _createPlayer(PlayerCharacter*& player, eSpriteType hat, string id = "ONE");
+	void _createPlayer(PlayerCharacter*& player, eSpriteType hat, string id = "PLAYER1");
 	// Collision handling
 	void NarrowPhaseClsn(GameObject* obj1, GameObject* obj2);
 	void TilemapClsn(GameObject* obj);
Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 69)
+++ Source/HatSelectScene.cpp	(revision 70)
@@ -39,8 +39,8 @@
 void HatSelectScene::update() {
 	hats.first->m_nSpriteIndex = hatsMenu[selection.first].second;
 	// Control the selection with keyboard
-	if (m_pKeyboard->TriggerDown(controlMap["LEFT_ONE"])) selection.first--;
-	else if (m_pKeyboard->TriggerDown(controlMap["RIGHT_ONE"])) selection.first =
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_LEFT"])) selection.first--;
+	else if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_RIGHT"])) selection.first =
 		(selection.first + 1) % (int)hatsMenu.size();
 	// Control the selection with controller
 	if (controllerOwner == 1) {
@@ -55,8 +55,8 @@
 	if (coOp) {
 		hats.second->m_nSpriteIndex = hatsMenu[selection.second].second;
 		// Control the selection with keyboard
-		if (m_pKeyboard->TriggerDown(controlMap["LEFT_TWO"])) selection.second--;
-		else if (m_pKeyboard->TriggerDown(controlMap["RIGHT_TWO"])) selection.second =
+		if (m_pKeyboard->TriggerDown(controlMap["PLAYER2_LEFT"])) selection.second--;
+		else if (m_pKeyboard->TriggerDown(controlMap["PLAYER2_RIGHT"])) selection.second =
 			(selection.second + 1) % (int)hatsMenu.size();
 		// Control the selection with controller
 		if (controllerOwner == 2) {
@@ -69,7 +69,7 @@
 	}
 
 	// Check for selection confirmation and proceed
-	if (m_pKeyboard->TriggerDown(controlMap["ACCEPT_ONE"]) || gamepad.isPressed("BUTTON_A")) {
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_ACCEPT"]) || gamepad.isPressed("BUTTON_A")) {
 		m_pAudio->stop();
 		game->startScene(new BaseLevelScene(game,
 			hatsMenu[selection.first].second,
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 69)
+++ Source/BaseLevelScene.cpp	(revision 70)
@@ -62,7 +62,7 @@
 	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5f;
 	// Place the player on the map
 	_createPlayer(players.first, hats.first);
-	if (coOp) _createPlayer(players.second, hats.second, "TWO");
+	if (coOp) _createPlayer(players.second, hats.second, "PLAYER2");
 	// Set the camera to follow the player/s
 	if (coOp)
 		camFollowVision(players.first, players.second);
@@ -206,7 +206,7 @@
 	}
 
 	// Toggle camera mode
-	if (m_pKeyboard->TriggerDown('Z')) {
+	if (m_pKeyboard->TriggerDown(controlMap["DEBUG_ZOOM"])) {
 		// If we currently are zoomed in, zoom out
 		if (shouldFollow) camMapVision();
 		// If we are zoomed out, zoom in
@@ -222,7 +222,7 @@
 	}
 
 	// Toggle drawing of tilemap collision boxes
-	if (m_pKeyboard->TriggerDown(VK_F4))
+	if (m_pKeyboard->TriggerDown(controlMap["DEBUG_SHOW_CLSN"]))
 		drawMapClsn = drawMapClsn ? false : true;
 
 	//Press T to place a tower at the PC's current location
@@ -359,35 +359,6 @@
 	}
 }
 
-//void BaseLevelScene::waveSpawns() {
-//	// If spawns are ready this wave and we're on a wave where they should appear
-//	if (goblinWaves.ready && wave >= goblinWaves.startWave) {
-//		int maxSpawns = (wave * goblinWaves.multiplyPerWave) + goblinWaves.addPerWave;
-//		// If we haven't exceeded this waves number of spawns and if it's time to spawn
-//		if (goblinWaves.numberSpawned < maxSpawns && m_pStepTimer->GetTotalSeconds() > goblinWaves.nextSpawn) {
-//			// Random spawning location out of 3 possible
-//			string sp = "enSpawn" + to_string(m_pRandom->randn(1, 3));
-//			// Spawn the enemy
-//			baddies.push_back((BadCharacter*)addObject(new BadMinotaur(this, paths[sp].x, paths[sp].y, 1.15f)));
-//			// Set the enemie's destination to be their starting point initially
-//			baddies[baddies.size() - 1]->setDestinationID(sp);
-//
-//			// Increase the number of enemies spawned
-//			goblinWaves.numberSpawned++;
-//			if (goblinWaves.numberSpawned >= maxSpawns) goblinWaves.ready = false;
-//
-//			// Calculating time until next spawn
-//			float untilNextSpawn = goblinWaves.timeToSpawn
-//				* powf(goblinWaves.timeMultiplyPerSpawn, (float)goblinWaves.numberSpawned)
-//				+ goblinWaves.timeAddPerSpawn * goblinWaves.numberSpawned;
-//			// Hard lower limit on time to spawn
-//			if (untilNextSpawn < 1.0f) untilNextSpawn = 1.0f;
-//			// Setting the time of next spawn
-//			goblinWaves.nextSpawn = m_pStepTimer->GetTotalSeconds() + untilNextSpawn;
-//		}
-//	}
-//}
-
 //creates all possible pairs of objects to pass to narrow phase
 void BaseLevelScene::BroadPhaseClsn() {
 	for (auto i : objectList) {
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 69)
+++ Source/Game.cpp	(revision 70)
@@ -44,7 +44,7 @@
 	if (controllerOwner > -1) gamepad.getState();
 
 	// Check for debugging keypresses
-	if (m_pKeyboard->TriggerDown(VK_F4)) displayFramerate = displayFramerate ? false : true;
+	if (m_pKeyboard->TriggerDown(controlMap["DEBUG_SHOW_FPS"])) displayFramerate = displayFramerate ? false : true;
 
 	m_pStepTimer->Tick([&]() {
 		// Code executed at every update (tick)
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 69)
+++ Source/PlayerCharacter.cpp	(revision 70)
@@ -111,25 +111,25 @@
 
 void PlayerCharacter::_handleMovementKeys() {
 	// Handles movement keys for the character
-	if (m_pKeyboard->Down(controlMap["LEFT_" + playerID]))
+	if (m_pKeyboard->Down(controlMap[playerID + "_LEFT"]))
 	{
 		// Left-Up
-		if (m_pKeyboard->Down(controlMap["UP_" + playerID]))
+		if (m_pKeyboard->Down(controlMap[playerID + "_UP"]))
 			setVelocity(maxSpeed, 135);
 		// Left-Down
-		else if (m_pKeyboard->Down(controlMap["DOWN_" + playerID]))
+		else if (m_pKeyboard->Down(controlMap[playerID + "_DOWN"]))
 			setVelocity(maxSpeed, 225);
 		// Left
 		else
 			setVelocity(maxSpeed, 180);
 	}
-	else if (m_pKeyboard->Down(controlMap["RIGHT_" + playerID]))
+	else if (m_pKeyboard->Down(controlMap[playerID + "_RIGHT"]))
 	{
 		// Right-Up
-		if (m_pKeyboard->Down(controlMap["UP_" + playerID]))
+		if (m_pKeyboard->Down(controlMap[playerID + "_UP"]))
 			setVelocity(maxSpeed, 45);
 		// Right-Down
-		else if (m_pKeyboard->Down(controlMap["DOWN_" + playerID]))
+		else if (m_pKeyboard->Down(controlMap[playerID + "_DOWN"]))
 			setVelocity(maxSpeed, 315);
 		// Right
 		else
@@ -136,10 +136,10 @@
 			setVelocity(maxSpeed, 0);
 	}
 	// Down
-	else if (m_pKeyboard->Down(controlMap["DOWN_" + playerID]))
+	else if (m_pKeyboard->Down(controlMap[playerID + "_DOWN"]))
 		setVelocity(maxSpeed, 270);
 	// Up
-	else if (m_pKeyboard->Down(controlMap["UP_" + playerID]))
+	else if (m_pKeyboard->Down(controlMap[playerID + "_UP"]))
 		setVelocity(maxSpeed, 90);
 	// No movement
 	else
@@ -148,25 +148,25 @@
 
 void PlayerCharacter::_handleDirectionKeys() {
 	// Moving of the character
-	if (m_pKeyboard->Down(controlMap["WEST_" + playerID]))
+	if (m_pKeyboard->Down(controlMap[playerID + "_AIM_WEST"]))
 	{
 		// Left-Up
-		if (m_pKeyboard->Down(controlMap["NORTH_" + playerID]))
+		if (m_pKeyboard->Down(controlMap[playerID + "_AIM_NORTH"]))
 			shoot(135);
 		// Left-Down
-		else if (m_pKeyboard->Down(controlMap["SOUTH_" + playerID]))
+		else if (m_pKeyboard->Down(controlMap[playerID + "_AIM_SOUTH"]))
 			shoot(225);
 		// Left
 		else
 			shoot(180);
 	}
-	else if (m_pKeyboard->Down(controlMap["EAST_" + playerID]))
+	else if (m_pKeyboard->Down(controlMap[playerID + "_AIM_EAST"]))
 	{
 		// Right-Up
-		if (m_pKeyboard->Down(controlMap["NORTH_" + playerID]))
+		if (m_pKeyboard->Down(controlMap[playerID + "_AIM_NORTH"]))
 			shoot(45);
 		// Right-Down
-		else if (m_pKeyboard->Down(controlMap["SOUTH_" + playerID]))
+		else if (m_pKeyboard->Down(controlMap[playerID + "_AIM_SOUTH"]))
 			shoot(315);
 		// Right
 		else
@@ -173,10 +173,10 @@
 			shoot(0);
 	}
 	// Down
-	else if (m_pKeyboard->Down(controlMap["SOUTH_" + playerID]))
+	else if (m_pKeyboard->Down(controlMap[playerID + "_AIM_SOUTH"]))
 		shoot(270);
 	// Up
-	else if (m_pKeyboard->Down(controlMap["NORTH_" + playerID]))
+	else if (m_pKeyboard->Down(controlMap[playerID + "_AIM_NORTH"]))
 		shoot(90);
 }
 

------------------------------------------------------------------------
r72 | jdg0393 | 2020-11-23 19:57:16 -0600 (Mon, 23 Nov 2020) | 1 line

Rudimentary tower purchase menu. It's not very good. Too bad.

Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 71)
+++ Source/Common.cpp	(revision 72)
@@ -24,6 +24,7 @@
 	// Default accept and special action keys
 	{"PLAYER1_ACCEPT", 'E'},
 	{"PLAYER1_BACK", VK_ESCAPE},
+	{"PLAYER1_MENU", 'Q'},
 	// Player 2 move keys
 	{"PLAYER2_UP", 'T'},
 	{"PLAYER2_DOWN", 'G'},
@@ -37,6 +38,7 @@
 	// Player 2 accept key
 	{"PLAYER2_ACCEPT", 'Y'},
 	{"PLAYER2_BACK", 'U'},
+	{"PLAYER2_MENU", 'R'},
 	// Debugging keys
 	{"DEBUG_ZOOM", 'Z'},
 	{"DEBUG_SHOW_CLSN", VK_F4},
Index: Source/HUDObject.cpp
===================================================================
--- Source/HUDObject.cpp	(revision 71)
+++ Source/HUDObject.cpp	(revision 72)
@@ -22,6 +22,7 @@
 		cameraPos.y + yPercentage * yMaxScale * cameraZ,
 		-5 + relativeZ
 	};
+
 	m_fXScale = relativeXScale * zBaseScale * cameraZ;
 	m_fYScale = relativeYScale * zBaseScale * cameraZ;
 }
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 71)
+++ Source/Source.vcxproj	(revision 72)
@@ -184,6 +184,7 @@
     <ClCompile Include="Renderer.cpp" />
     <ClCompile Include="Scene.cpp" />
     <ClCompile Include="BaseLevelScene.cpp" />
+    <ClCompile Include="ShopMenu.cpp" />
     <ClCompile Include="Spire.cpp" />
     <ClCompile Include="TiledScene.cpp" />
     <ClCompile Include="TitleScreenScene.cpp" />
@@ -216,6 +217,7 @@
     <ClInclude Include="Renderer.h" />
     <ClInclude Include="Scene.h" />
     <ClInclude Include="BaseLevelScene.h" />
+    <ClInclude Include="ShopMenu.h" />
     <ClInclude Include="Sndlist.h" />
     <ClInclude Include="SpawnDesc.h" />
     <ClInclude Include="Spire.h" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 71)
+++ Source/Source.vcxproj.filters	(revision 72)
@@ -70,6 +70,9 @@
       <Filter>Objects\Baddies</Filter>
     </ClCompile>
     <ClCompile Include="WaveSpawner.cpp" />
+    <ClCompile Include="ShopMenu.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -150,6 +153,9 @@
       <Filter>Objects\Baddies</Filter>
     </ClInclude>
     <ClInclude Include="WaveSpawner.h" />
+    <ClInclude Include="ShopMenu.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 71)
+++ Source/Renderer.cpp	(revision 72)
@@ -28,9 +28,6 @@
 	BeginResourceUpload();
 
 	// Loading of images goes here
-	Load(BLACK_SQUARE, "black_square");
-	Load(TITLE_SCREEN, "title_screen");
-	Load(GREENLINE_SPRITE, "greenline");
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(VIKING_HAT, "viking_hat");
 	Load(WIZARD_HAT, "wizard_hat");
@@ -46,6 +43,11 @@
 	Load(FIREBALL, "fireball");
 	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
+	// GUI
+	Load(TITLE_SCREEN, "title_screen");
+	Load(MENU_BOX, "menu_box");
+	Load(BLACK_SQUARE, "black_square");
+	Load(GREENLINE_SPRITE, "greenline");
 	// Characters
 	Load(HUMAN_IDLE, "human_idle");
 	Load(HUMAN_WALK, "human_walk");
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 71)
+++ Source/GameDefines.h	(revision 72)
@@ -10,9 +10,6 @@
 ///
 /// Note: NUM_SPRITES must be last.
 enum eSpriteType {
-	BLACK_SQUARE,
-	TITLE_SCREEN,
-	GREENLINE_SPRITE,
 	SIMPLE_TILE,
 	VIKING_HAT,
 	WIZARD_HAT,
@@ -28,6 +25,11 @@
 	FIREBALL,
 	EXPLOSION,
 	SMOKE,
+	// GUI
+	TITLE_SCREEN,
+	MENU_BOX,
+	BLACK_SQUARE,
+	GREENLINE_SPRITE,
 	// Characters
 	HUMAN_IDLE,
 	HUMAN_WALK,
Index: Source/ShopMenu.cpp
===================================================================
--- Source/ShopMenu.cpp	(nonexistent)
+++ Source/ShopMenu.cpp	(revision 72)
@@ -0,0 +1,148 @@
+#include "ShopMenu.h"
+#include "Scene.h"
+#include "BaseLevelScene.h"
+#include "RangeTower.h"
+#include "MageTower.h"
+
+ShopMenu::ShopMenu(Scene* scene, float xPercentage, float yPercentage, string playerID)
+	: HUDObject(scene, MENU_BOX, xPercentage, yPercentage)
+{
+	this->playerID = playerID;
+	relativeXScale = 0.4f;
+	relativeYScale = 0.4f;
+	m_fAlpha = 0.0f;
+	// The tower to be displayed in the menu
+	selectedTower = scene->addObject(new HUDObject(scene, RANGE1, xPercentage, yPercentage + 0.1f, -0.1f));
+	selectedTower->m_fAlpha = 0.0f;
+	updateSelection();
+}
+
+bool ShopMenu::isOpen() { return open; }
+
+void ShopMenu::toggle() {
+	if (open) {
+		open = false;
+		m_fAlpha = 0.0f;
+		selectedTower->m_fAlpha = 0.0f;
+	}
+	else {
+		open = true;
+		m_fAlpha = 1.0f;
+		selectedTower->m_fAlpha = 1.0f;
+	}
+}
+
+void ShopMenu::nextSelection() {
+	selection += 1;
+	selection %= numChoices;
+	updateSelection();
+}
+
+void ShopMenu::prevSelection() {
+	selection -= 1;
+	if (selection < 0) selection = numChoices - 1;
+	updateSelection();
+}
+
+void ShopMenu::updateSelection() {
+	switch (selection) {
+	case 0:
+		selectedTower->m_nSpriteIndex = RANGE1;
+		selectionName = "Gun Tower";
+		selectionDescription = "Shoots bullets. Questions?     ";
+		cost = 5;
+		break;
+	case 1:
+		selectedTower->m_nSpriteIndex = MAGE1;
+		selectionName = "Magic Tower";
+		selectionDescription = "Crowd control   for pyromaniacs";
+		cost = 10;
+		break;
+	default:
+		break;
+	}
+}
+
+void ShopMenu::handleKeyboard() {
+	if (m_pKeyboard->TriggerDown(controlMap[playerID + "_MENU"])) {
+		toggle();
+	}
+	if (open) {
+		if (m_pKeyboard->TriggerDown(controlMap[playerID + "_RIGHT"])) {
+			nextSelection();
+		}
+		if (m_pKeyboard->TriggerDown(controlMap[playerID + "_LEFT"])) {
+			prevSelection();
+		}
+		if (m_pKeyboard->TriggerDown(controlMap[playerID + "_ACCEPT"])) {
+			buy();
+		}
+	}
+}
+
+void ShopMenu::handleController() {
+	if (gamepad.isPressed("BUTTON_Y")) {
+		toggle();
+	}
+	if (open) {
+		if (gamepad.isPressed("LSTICK_RIGHT")) {
+			nextSelection();
+		}
+		if (gamepad.isPressed("LSTICK_LEFT")) {
+			prevSelection();
+		}
+		if (gamepad.isPressed("BUTTON_A")) {
+			buy();
+		}
+	}
+}
+
+void ShopMenu::buy() {
+	BaseLevelScene* level = (BaseLevelScene*)scene;
+	// Check if we have enough money
+	if (level->getCredits() >= cost) {
+		PlayerCharacter* player = playerID == "PLAYER1" ? level->getPlayers().first : level->getPlayers().second;
+		Vector3 pos = player->getPosition();
+		// Determine which tower to place
+		switch (selection) {
+		case 0:
+			scene->addObject(new RangeTower(scene, RANGE1, 0, pos.x, pos.y - 32.0f));
+			break;
+		case 1:
+			scene->addObject(new MageTower(scene, MAGE1, 0, pos.x, pos.y - 32.0f));
+			break;
+		default:
+			break;
+		}
+		level->removeCredits(cost);
+		toggle();
+	}
+}
+
+void ShopMenu::renderText() {
+	if (open) {
+		// Center x and y coordinates
+		float centerX = 640 + (xPercentage * 640);
+		float centerY = 360 - (yPercentage * 360);
+		// I have absolutely no idea why this is necessary. I looked for the answer for days.
+		// I have scoured ancient tomes. I have summoned spirits and delved into regions of space that
+		// pre-date mankind in search of the reason why I need to do this. I don't know. For whatever reason,
+		// the x position is slightly off only when the menu is on the left side of the screen. I've
+		// given up entirely. We make this ugly little adjustment to preserve what remains of my sanity.
+		if (xPercentage < 0) centerX += 14;
+		// Draw the name of the tower
+		float nameX = centerX - (selectionName.size() * 7.5f);
+		m_pRenderer->DrawScreenText(selectionName.c_str(), { nameX, centerY - 120 }, Colors::GhostWhite);
+		// Draw the description of the tower
+		string desc1 = selectionDescription.substr(0, 16);
+		string desc2 = selectionDescription.substr(16);
+		float descX = centerX - (desc1.size() * 6.5f);
+		m_pRenderer->DrawScreenText(desc1.c_str(), { descX, centerY + 24 }, Colors::GhostWhite);
+		descX = centerX - (desc2.size() * 6.5f);
+		m_pRenderer->DrawScreenText(desc2.c_str(), { descX, centerY + 50 }, Colors::GhostWhite);
+		// Draw the cost of the tower
+		string costStr = "Buy for " + to_string(cost) + " coins";
+		float costX = centerX - (costStr.size() * 6.5f);
+		m_pRenderer->DrawScreenText(costStr.c_str(), { costX, centerY + 80 }, Colors::GhostWhite);
+	}
+}
\ No newline at end of file
Index: Source/Renderer.h
===================================================================
--- Source/Renderer.h	(revision 71)
+++ Source/Renderer.h	(revision 72)
@@ -11,11 +11,8 @@
 	-5
 		-5.0 -> HUD Objects
 	1
-		1.0
-			1.09 -> Spire Peak
 		1.1 -> Overhead Tile Layer
-			1.15 -> Player Object
-			1.19 -> Spire Base
+			1.15 -> Player & most objects
 		1.2 -> Foreground Tile Layer
 	    1.3 -> Background Tiles Layer
 	10
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 71)
+++ Source/BaseLevelScene.cpp	(revision 72)
@@ -42,6 +42,10 @@
 	// Add the spawn descriptions
 	waves->addSpawnDesc(goblins);
 	waves->addSpawnDesc(minotaurs);
+
+	// Create the tower shop menu
+	towerMenus.first = (ShopMenu*)addObject(new ShopMenu(this, -0.5f, -0.3f));
+	towerMenus.second = (ShopMenu*)addObject(new ShopMenu(this, 0.5f, -0.3f, "PLAYER2"));
 }
 
 BaseLevelScene::~BaseLevelScene() {
@@ -74,7 +78,7 @@
 
 void BaseLevelScene::update() {
 	// Handling controls specific to the scene
-	handleKeyboard();
+	handleControls();
 	// Core scene update, including updating objects
 	Scene::update();
 	// Runs checks for object and tilemap collisions
@@ -162,6 +166,9 @@
 		float x = 640.0f - timeLeft.size() * 8.0f;
 		m_pRenderer->DrawScreenText(timeLeft.c_str(), { x, 420.0f }, Colors::IndianRed);
 	}
+	// Render the text from the shop menus
+	towerMenus.first->renderText();
+	towerMenus.second->renderText();
 }
 
 void BaseLevelScene::_createPlayer(PlayerCharacter*& player, eSpriteType hat, string id) {
@@ -188,21 +195,45 @@
 	}
 }
 
-void BaseLevelScene::handleKeyboard() {
+void BaseLevelScene::handleControls() {
 	// No need to get the keyboard state, it's done in the Game!
 	// Just check values on the keyboard :)
 
 	// Handle Player 1 controls
-	if (controllerOwner == 1)
-		players.first->handleController();
-	else
-		players.first->handleKeyboard();
+	if (controllerOwner == 1) {
+		if (!towerMenus.first->isOpen())
+			// We only handle player controls if their menu isn't open
+			players.first->handleController();
+		else
+			players.first->setVelocity(0, players.first->getAngle());
+		towerMenus.first->handleController();
+	}
+	else {
+		if (!towerMenus.first->isOpen())
+			// We only handle player controls if their menu isn't open
+			players.first->handleKeyboard();
+		else
+			players.first->setVelocity(0, players.first->getAngle());
+		towerMenus.first->handleKeyboard();
+	}
 	// Handle Player 2 controls
 	if (coOp) {
-		if (controllerOwner == 2)
-			players.second->handleController();
-		else
-			players.second->handleKeyboard();
+		if (controllerOwner == 2) {
+			if (!towerMenus.second->isOpen())
+				// We only handle player controls if their menu isn't open
+				players.second->handleController();
+			else
+				players.second->setVelocity(0, players.second->getAngle());
+			towerMenus.second->handleController();
+		}
+		else {
+			if (!towerMenus.second->isOpen())
+				// We only handle player controls if their menu isn't open
+				players.second->handleKeyboard();
+			else
+				players.second->setVelocity(0, players.second->getAngle());
+			towerMenus.second->handleKeyboard();
+		}
 	}
 
 	// Toggle camera mode
@@ -317,6 +348,9 @@
 PlayerCharacter* BaseLevelScene::getPlayer() {
 	return players.first;
 }
+pair<PlayerCharacter*, PlayerCharacter*> BaseLevelScene::getPlayers() {
+	return players;
+}
 
 BadCharacter* BaseLevelScene::addBaddie(BadCharacter* baddie) {
 	addObject((GameObject*)baddie);
@@ -438,6 +472,12 @@
 	if (obj->is("projectile")) obj->kill();
 }
 
+int BaseLevelScene::getCredits() {
+	return credits;
+}
 void BaseLevelScene::addCredits(int amount) {
 	credits += amount;
+}
+void BaseLevelScene::removeCredits(int amount) {
+	credits -= amount;
 }
\ No newline at end of file
Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(revision 71)
+++ Source/Spire.h	(revision 72)
@@ -7,7 +7,7 @@
 {
 public:
     int hp;
-    Spire(Scene* scene, float x, float y, float z = 1.19);
+    Spire(Scene* scene, float x, float y, float z = 1.15);
     void update() override;
     void onAnimationComplete(AnimationDesc& anim) override;
 protected:
Index: Source/WaveSpawner.cpp
===================================================================
--- Source/WaveSpawner.cpp	(revision 71)
+++ Source/WaveSpawner.cpp	(revision 72)
@@ -15,7 +15,7 @@
 		// If these spawns are ready
 		if (spawnState.ready) {
 			int waveOffset = wave - spawnState.startWave + 1;
-			int maxSpawns = (waveOffset * spawnState.addPerWave) + pow(spawnState.multiplyPerWave, waveOffset);
+			int maxSpawns = (waveOffset * spawnState.addPerWave) + (int)pow(spawnState.multiplyPerWave, waveOffset);
 
 			// If we haven't exceeded this waves max number of spawns and if it's time to spawn
 			if (spawnState.numberSpawned < maxSpawns && m_pStepTimer->GetTotalSeconds() > spawnState.nextSpawn) {
@@ -88,5 +88,7 @@
 	}
 	else {
 		ABORT("Tried to spawn a baddie with an invalid key!");
+		// Return won't be used, just want to avoid the stupid compiler warning
+		return nullptr;
 	}
 }
\ No newline at end of file
Index: Source/ShopMenu.h
===================================================================
--- Source/ShopMenu.h	(nonexistent)
+++ Source/ShopMenu.h	(revision 72)
@@ -0,0 +1,28 @@
+#pragma once
+#include "HUDObject.h"
+class ShopMenu :
+	public HUDObject,
+	public CComponent
+{
+public:
+	ShopMenu(Scene* scene, float xPercentage, float yPercentage, string playerID = "PLAYER1");
+	void renderText();
+	bool isOpen();
+	void toggle();
+	void buy();
+	void nextSelection();
+	void prevSelection();
+	void handleKeyboard();
+	void handleController();
+private:
+	string playerID;
+	bool open = false;
+	HUDObject* selectedTower = nullptr;
+	int selection = 0;
+	int numChoices = 2;
+	string selectionName = "";
+	string selectionDescription = "";
+	int cost = 0;
+	void updateSelection();
+};
+
Index: Source/HUDObject.h
===================================================================
--- Source/HUDObject.h	(revision 71)
+++ Source/HUDObject.h	(revision 72)
@@ -3,10 +3,10 @@
 #include "GameObject.h"
 
 class HUDObject :
-    public CSpriteDesc3D, CCommon
+    public CSpriteDesc3D, public CCommon
 {
 public:
-    HUDObject(Scene* scene, eSpriteType spriteKey, float xPercentage, float yPercentage, float relativeZ);
+    HUDObject(Scene* scene, eSpriteType spriteKey, float xPercentage, float yPercentage, float relativeZ = 0.0f);
     // Correct the position of HUD object based on camera
     // May be called separately from update() in case camera adjusts after update()
     void adjust(); 
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 71)
+++ Source/BaseLevelScene.h	(revision 72)
@@ -1,5 +1,6 @@
 #pragma once
 #include "TiledScene.h"
+#include "ShopMenu.h"
 #include "PlayerCharacter.h"
 #include "BadCharacter.h"
 #include "Spire.h"
@@ -31,9 +32,12 @@
 	void camMapVision();
 
 	BadCharacter* addBaddie(BadCharacter* baddie);
+	int getCredits();
 	void addCredits(int amount);
+	void removeCredits(int amount);
 
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
+	pair<PlayerCharacter*, PlayerCharacter*> BaseLevelScene::getPlayers();
 	GameObject* getClosestTower();//returns the tower closest to the PC
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
 	Spire* getSpire() { return spire; }
@@ -45,6 +49,7 @@
 	void cullObjects() override;
 
 private:
+	pair<ShopMenu*, ShopMenu*> towerMenus;
 	bool gameOver = false;
 	float endTime = 0;
 	int credits = 10;
@@ -64,7 +69,7 @@
 	// Whether the camera is following
 	bool shouldFollow = false;
 	// Controlling the game
-	void handleKeyboard(); // Handler for the keyboard
+	void handleControls();
 	// Creates a player object
 	void _createPlayer(PlayerCharacter*& player, eSpriteType hat, string id = "PLAYER1");
 	// Collision handling

------------------------------------------------------------------------
r73 | jdg0393 | 2020-11-23 21:10:28 -0600 (Mon, 23 Nov 2020) | 1 line

Player collects coins to increase money.

Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 72)
+++ Source/BadCharacter.cpp	(revision 73)
@@ -1,5 +1,6 @@
 #include "BadCharacter.h"
 #include "BaseLevelScene.h"
+#include "Coin.h"
 
 BadCharacter::BadCharacter(Scene* scene, float x, float y, float z) :
 	Character(scene, BLACK_SQUARE, x, y, z)
@@ -35,7 +36,8 @@
 		}
 		else {
 			// Get some money
-			level->addCredits(1);
+			//level->addCredits(1);
+			scene->addObject(new Coin(scene, m_pRandom->randn(1, 10), m_vPos.x, m_vPos.y));
 			// Destroy this creature once it's faded out
 			kill();
 		}
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 72)
+++ Source/Source.vcxproj	(revision 73)
@@ -169,6 +169,7 @@
     <ClCompile Include="BadMinotaur.cpp" />
     <ClCompile Include="Bullet.cpp" />
     <ClCompile Include="Character.cpp" />
+    <ClCompile Include="Coin.cpp" />
     <ClCompile Include="Common.cpp" />
     <ClCompile Include="Fireball.cpp" />
     <ClCompile Include="Game.cpp" />
@@ -200,6 +201,7 @@
     <ClInclude Include="BadMinotaur.h" />
     <ClInclude Include="Bullet.h" />
     <ClInclude Include="Character.h" />
+    <ClInclude Include="Coin.h" />
     <ClInclude Include="Common.h" />
     <ClInclude Include="Explosive.h" />
     <ClInclude Include="Fireball.h" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 72)
+++ Source/Source.vcxproj.filters	(revision 73)
@@ -73,6 +73,9 @@
     <ClCompile Include="ShopMenu.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="Coin.cpp">
+      <Filter>Objects</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -156,6 +159,9 @@
     <ClInclude Include="ShopMenu.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="Coin.h">
+      <Filter>Objects</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/VikingPlayer.cpp
===================================================================
--- Source/VikingPlayer.cpp	(revision 72)
+++ Source/VikingPlayer.cpp	(revision 73)
@@ -15,5 +15,5 @@
 
 // Creates the fireball as the projectile
 GameObject* VikingPlayer::_createProjectile() {
-	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005f));
+	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z));
 }
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 72)
+++ Source/Renderer.cpp	(revision 73)
@@ -43,6 +43,10 @@
 	Load(FIREBALL, "fireball");
 	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
+	// Currency
+	Load(COIN, "coin");
+	Load(COIN_STACK, "coin_stack");
+	Load(COIN_BAG, "coin_bag");
 	// GUI
 	Load(TITLE_SCREEN, "title_screen");
 	Load(MENU_BOX, "menu_box");
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 72)
+++ Source/GameDefines.h	(revision 73)
@@ -25,6 +25,10 @@
 	FIREBALL,
 	EXPLOSION,
 	SMOKE,
+	// Currency
+	COIN,
+	COIN_STACK,
+	COIN_BAG,
 	// GUI
 	TITLE_SCREEN,
 	MENU_BOX,
Index: Source/WizardPlayer.cpp
===================================================================
--- Source/WizardPlayer.cpp	(revision 72)
+++ Source/WizardPlayer.cpp	(revision 73)
@@ -15,5 +15,5 @@
 
 // Creates the fireball as the projectile
 GameObject* WizardPlayer::_createProjectile() {
-	return scene->addObject(new Fireball(scene, m_vPos.x, m_vPos.y, m_vPos.z + .005f));
+	return scene->addObject(new Fireball(scene, m_vPos.x, m_vPos.y, m_vPos.z));
 }
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 72)
+++ Source/Spire.cpp	(revision 73)
@@ -13,6 +13,7 @@
 
 	// Descriptor tags
 	tags.insert("unpassable");
+	tags.insert("spire");
 }
 
 void Spire::update()
Index: Source/Coin.cpp
===================================================================
--- Source/Coin.cpp	(nonexistent)
+++ Source/Coin.cpp	(revision 73)
@@ -0,0 +1,27 @@
+#include "Coin.h"
+
+Coin::Coin(Scene* scene, int value, float x, float y, float z)
+	: GameObject(scene, COIN, x, y, z)
+{
+	this->value = value;
+	timeCreated = m_pStepTimer->GetTotalSeconds();
+	tags.insert("coins");
+}
+
+void Coin::update() {
+	GameObject::update();
+	if (value < 4) m_nSpriteIndex = COIN;
+	else if (value < 8) m_nSpriteIndex = COIN_STACK;
+	else m_nSpriteIndex = COIN_BAG;
+	// Update the scale
+	float timePassed = m_pStepTimer->GetTotalSeconds() - timeCreated;
+	float maxTimeElapse = 2 * (float)value;
+	float percentPassed = timePassed / maxTimeElapse;
+	scale = 1 - percentPassed;
+	m_fXScale = scale;
+	m_fYScale = scale;
+	// Delete the coins after some time
+	if (scale < 0.1) kill();
+}
+
+int Coin::getValue() { return value; }
\ No newline at end of file
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 72)
+++ Source/PlayerCharacter.cpp	(revision 73)
@@ -93,7 +93,7 @@
 }
 
 GameObject* PlayerCharacter::_createProjectile() {
-	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z + .001f));
+	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z));
 }
 
 void PlayerCharacter::_updateAnimation() {
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 72)
+++ Source/BaseLevelScene.cpp	(revision 73)
@@ -8,6 +8,7 @@
 #include "RangeTower.h"
 #include "BadGoblin.h"
 #include "BadMinotaur.h"
+#include "Coin.h"
 
 BaseLevelScene::BaseLevelScene(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coOp) :
 	TiledScene(game)
@@ -17,6 +18,16 @@
 	this->coOp = coOp;
 	waves = new WaveSpawner(this);
 
+	// Create the icon to indicate gold amounts
+	HUDObject* coins = addObject(new HUDObject(this, COIN_BAG, -0.92f, 0.9f));
+	coins->relativeXScale = 1.5f;
+	coins->relativeYScale = 1.5f;
+	coins->m_fAlpha = 0.7f;
+
+	// Create the tower shop menu
+	towerMenus.first = (ShopMenu*)addObject(new ShopMenu(this, -0.5f, -0.3f));
+	towerMenus.second = (ShopMenu*)addObject(new ShopMenu(this, 0.5f, -0.3f, "PLAYER2"));
+
 	// Define some spawn descriptors for the wave spawner
 	SpawnDesc goblins;
 	goblins.addPerWave = 10;
@@ -42,10 +53,6 @@
 	// Add the spawn descriptions
 	waves->addSpawnDesc(goblins);
 	waves->addSpawnDesc(minotaurs);
-
-	// Create the tower shop menu
-	towerMenus.first = (ShopMenu*)addObject(new ShopMenu(this, -0.5f, -0.3f));
-	towerMenus.second = (ShopMenu*)addObject(new ShopMenu(this, 0.5f, -0.3f, "PLAYER2"));
 }
 
 BaseLevelScene::~BaseLevelScene() {
@@ -152,10 +159,10 @@
 
 		//m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
 
-		string credString = "Credits: " + to_string(credits);
-		m_pRenderer->DrawScreenText(credString.c_str(), { 800.0f,60.0f }, Colors::White);
+		string credString = to_string(credits);
+		m_pRenderer->DrawScreenText(credString.c_str(), { 44.0f,30.0f }, Colors::Gold);
 
-		string priceString = "Range Tower: Press 1 (5 credits)\nMage Tower: Press 2 (10 credits)\nPress 'U' to upgrade a tower";
+		string priceString = "Press 'U' to upgrade a tower";
 		m_pRenderer->DrawScreenText(priceString.c_str(), { 100.0f,60.0f }, Colors::White);
 	}
 	else {
@@ -256,23 +263,6 @@
 	if (m_pKeyboard->TriggerDown(controlMap["DEBUG_SHOW_CLSN"]))
 		drawMapClsn = drawMapClsn ? false : true;
 
-	//Press T to place a tower at the PC's current location
-	if (m_pKeyboard->TriggerDown('1')) {
-		if (credits >= 5) {
-			Vector3 pos = players.first->getPosition();
-			addObject(new RangeTower(this, RANGE1, 0, pos.x, pos.y - 32.0f));
-			credits -= 5;
-		}
-
-	}
-	if (m_pKeyboard->TriggerDown('2')) {
-		if (credits >= 10) {
-			Vector3 pos = players.first->getPosition();
-			addObject(new MageTower(this, MAGE1, 0, pos.x, pos.y - 32.0f));
-			credits -= 10;
-		}
-	}
-
 	if (m_pKeyboard->TriggerDown('U')) {
 
 		GameObject* tow = getClosestTower();
@@ -428,6 +418,12 @@
 		// Force the second object to go around
 		obj2->setForceVelocity(force);
 	}
+	// Collecting of coins
+	if (obj1->is("player") && obj2->is("coins")) {
+		m_pAudio->play(COIN_GRAB);
+		addCredits(((Coin*)obj2)->getValue());
+		obj2->kill();
+	}
 	// Behavior when a projectile hits an enemy
 	if (obj1->is("projectile") && obj2->is("baddie")) {
 		Projectile* p = dynamic_cast<Projectile*>(obj1);
@@ -465,6 +461,8 @@
 			obj1->kill();
 		}
 	}
+	// Projectiles should die when hitting the spire
+	if (obj1->is("projectile") && obj2->is("spire")) obj1->kill();
 }
 
 void BaseLevelScene::TilemapClsn(GameObject* obj) {
Index: Source/Sndlist.h
===================================================================
--- Source/Sndlist.h	(revision 72)
+++ Source/Sndlist.h	(revision 73)
@@ -14,5 +14,6 @@
 	MENU_SONG,
 	MAP_SONG,
 	GUN_SOUND,
-	CLANG_SOUND
+	CLANG_SOUND,
+	COIN_GRAB
 }; //eSoundType
\ No newline at end of file
Index: Source/Coin.h
===================================================================
--- Source/Coin.h	(nonexistent)
+++ Source/Coin.h	(revision 73)
@@ -0,0 +1,16 @@
+#pragma once
+#include "GameObject.h"
+
+class Coin :
+	public GameObject
+{
+public:
+	Coin(Scene* scene, int value, float x, float y, float z = 1.15f);
+	void update() override;
+	int getValue();
+private:
+	int value = 1;
+	float scale = 1.0f;
+	float timeCreated;
+};
+

------------------------------------------------------------------------
r74 | amm0837 | 2020-11-24 15:29:24 -0600 (Tue, 24 Nov 2020) | 1 line

Added upgrades to towers. When upgraded range towers increase range and damage. Magic towers increase range, damage, and splash radius.

Index: Source/Bullet.cpp
===================================================================
--- Source/Bullet.cpp	(revision 73)
+++ Source/Bullet.cpp	(revision 74)
@@ -1,9 +1,19 @@
 #include "Bullet.h"
 
-Bullet::Bullet(Scene* scene, float x, float y, float z) :
+Bullet::Bullet(Scene* scene, float x, float y, float z,float level) :
 	GameObject(scene, BULLET1, x, y, z)
 {
 	tags.insert("projectile");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
 	damage = 10;
+	lvl = level;
+	if (lvl == 0) {
+		damage = 10;
+	}
+	if (lvl == 1) {
+		damage = 15;
+	}
+	if (lvl == 2) {
+		damage = 20;
+	}
 }
Index: Source/Tower.h
===================================================================
--- Source/Tower.h	(revision 73)
+++ Source/Tower.h	(revision 74)
@@ -12,6 +12,7 @@
 	void fire(GameObject* b);
 	void setRoll(float angle);
 	//void splashDmg();
+	float distToTarget();
 
 private:
 	GameObject* target = nullptr;
Index: Source/Bullet.h
===================================================================
--- Source/Bullet.h	(revision 73)
+++ Source/Bullet.h	(revision 74)
@@ -6,6 +6,7 @@
     public Projectile
 {
 public:
-    Bullet(Scene* scene, float x = 0, float y = 0, float z = 0);
+    Bullet(Scene* scene, float x = 0, float y = 0, float z = 0,float level = 0);
+    float lvl;
 };
 
Index: Source/RangeTower.h
===================================================================
--- Source/RangeTower.h	(revision 73)
+++ Source/RangeTower.h	(revision 74)
@@ -6,7 +6,7 @@
 	public Tower {
 
 public:
-	RangeTower(Scene* scene,eSpriteType t, float level, float x, float y,float z = 1.14);
+	RangeTower(Scene* scene,eSpriteType t, float level, float x, float y,float z =1.14);
 	virtual void update();
 	float getLevel();
 private:
Index: Source/Fireball.h
===================================================================
--- Source/Fireball.h	(revision 73)
+++ Source/Fireball.h	(revision 74)
@@ -10,10 +10,14 @@
 	public Explosive
 {
 public:
-	Fireball(Scene* scene, float x = 0, float y = 0, float z = 0);
+	Fireball(Scene* scene, float x = 0, float y = 0, float z = 0, float level =0);
 	void update() override;
 	void kill() override;
 	void onAnimationComplete(AnimationDesc& anim) override;
+	void setScale(float x,float y);
 protected:
 	AnimationDesc explodeAnimation;
+	float xScale;
+	float yScale;
+	float lvl;
 };
\ No newline at end of file
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 73)
+++ Source/Fireball.cpp	(revision 74)
@@ -1,6 +1,6 @@
 #include "Fireball.h"
 
-Fireball::Fireball(Scene* scene, float x, float y, float z) :
+Fireball::Fireball(Scene* scene, float x, float y, float z, float level) :
 	GameObject(scene, FIREBALL, x, y, z)
 {
 	tags.insert("projectile");
@@ -7,8 +7,21 @@
 	tags.insert("explosive");
 	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
 	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15f);
-	damage = 4;
-	splash = 3;
+	lvl = level;
+	if (lvl == 0) {
+		damage = 4;
+		splash = 3;
+	}
+	if (lvl == 1) {
+		damage = 8;
+		splash = 10;
+		radius = 30;
+	}
+	if (lvl == 2) {
+		damage = 15;
+		splash = 15;
+		radius = 40;
+	}
 }
 
 void Fireball::update() {
@@ -19,8 +32,19 @@
 void Fireball::kill() {
 	startAnimation(explodeAnimation);
 	// Size of the explosion
-	m_fXScale = 2.0;
-	m_fYScale = 2.0;
+	if (lvl == 0) {
+		m_fXScale = 2.0;
+		m_fYScale = 2.0;
+	}
+	if (lvl == 1) {
+		m_fXScale = 3.0;
+		m_fYScale = 3.0;
+	}
+	if (lvl == 2) {
+		m_fXScale = 4.0;
+		m_fYScale = 4.0;
+	}
+
 	// Set damage to nothing after initial hit
 	detonated = true;
 	damage = 0;
@@ -29,4 +53,9 @@
 
 void Fireball::onAnimationComplete(AnimationDesc& anim) {
 	if (anim == explodeAnimation) willCull = true;
+}
+
+void Fireball::setScale(float x, float y) {
+	xScale = x;
+	yScale = y;
 }
\ No newline at end of file
Index: Source/Explosive.h
===================================================================
--- Source/Explosive.h	(revision 73)
+++ Source/Explosive.h	(revision 74)
@@ -5,7 +5,7 @@
 {
 public:
 	Explosive() {}
-	float radius = 50.0f;
+	float radius = 20.0f;
 	int splash = 1;
 	bool detonated = false;
 };
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 73)
+++ Source/Tower.cpp	(revision 74)
@@ -16,18 +16,39 @@
 }
 void Tower::update() {
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
+		target = calcTarget();
 		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
 		if (this->is("tower")&& this->is("mage")) {		//add conditions for other towers here, set bullet type
 			Vector3 pos = this->getPosition();
 			//creating bullet and setting its bounding box
-			GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z));
-			fire(b);
+			if (this->is("lvl0") && this->distToTarget() <= 250) {
+				GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 0));
+				fire(b);
+			}
+			if (this->is("lvl1") && this->distToTarget() <= 350) {
+				GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 1));
+				fire(b);
+			}
+			else if (this->is("lvl2") && this->distToTarget() <= 500) {
+				GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 2));
+				fire(b);
+			}
 		}
 		else if (this->is("tower") && this->is("range")) {
 			Vector3 pos = this->getPosition();
 			//creating bullet and setting its bounding box
-			GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z));
-			fire(b);
+			if (this->is("lvl0") && this->distToTarget() <= 300) {
+				GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z,0));
+				fire(b);
+			}
+			if (this->is("lvl1") && this->distToTarget() <= 400 ) {
+				GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 1));
+				fire(b);
+			}
+			else if (this->is("lvl2") && this->distToTarget() <= 550) {
+				GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 2));
+				fire(b);
+			}
 		}
 	}
 }
@@ -59,11 +80,27 @@
 	return enemy;
 }
 
+float Tower::distToTarget() {
+	Vector3 towerPos;
+	Vector3 enemyPos;
+	float difX, difY, dist;
+	enemyPos = target->getPosition();
+	towerPos = this->getPosition();
+	//get tower and target pos
+	difX = abs(enemyPos.x - towerPos.x);		
+	difY = abs(enemyPos.y - towerPos.y);
+	dist = sqrt(pow(difX, 2) + pow(difY, 2));
+	//pythagorean to find nearest enemy object calculate dist between target and tower
+
+	return dist;
+
+}
+
 void Tower::fire(GameObject* b) {
 	
 	
 	//find target for tower
-	target = calcTarget();
+	//target = calcTarget();
 	
 	if (target != nullptr) {
 

------------------------------------------------------------------------
r75 | amm0837 | 2020-11-24 17:15:58 -0600 (Tue, 24 Nov 2020) | 1 line

must be very close to a tower to upgrade or sell it.

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 74)
+++ Source/BaseLevelScene.cpp	(revision 75)
@@ -266,7 +266,7 @@
 	if (m_pKeyboard->TriggerDown('U')) {
 
 		GameObject* tow = getClosestTower();
-		if (tow != NULL) {
+		if (tow != NULL && distToTower() <= 75) {
 			if (tow->is("range")) {
 				if (tow->is("lvl0")) {
 					if (credits >= 10) {
@@ -305,7 +305,7 @@
 
 	if (m_pKeyboard->TriggerDown('X')) {
 		GameObject* tow = getClosestTower();
-		if (tow != NULL) {
+		if (tow != NULL && distToTower() <= 75) {
 			if (tow->is("range")) {
 				credits += 3;
 			}
@@ -376,6 +376,18 @@
 
 }
 
+float BaseLevelScene::distToTower() {	//returns distance from player to closest tower
+	GameObject* tow = getClosestTower();
+	Vector3 towerPos = tow->getPosition();
+	Vector3 playerPos = players.first->getPosition();
+	float difX, difY, dist;
+	difX = abs(playerPos.x - towerPos.x);
+	difY = abs(playerPos.y - towerPos.y);
+	dist = sqrt(pow(difX, 2) + pow(difY, 2));
+
+	return dist;
+}
+
 void BaseLevelScene::endGame() {
 	if (!gameOver) {
 		gameOver = true;
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 74)
+++ Source/BaseLevelScene.h	(revision 75)
@@ -39,6 +39,7 @@
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	pair<PlayerCharacter*, PlayerCharacter*> BaseLevelScene::getPlayers();
 	GameObject* getClosestTower();//returns the tower closest to the PC
+	float distToTower();
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
 	Spire* getSpire() { return spire; }
 	void setSpire(Spire* sp) { spire = sp; }
Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 74)
+++ Source/Common.cpp	(revision 75)
@@ -25,6 +25,7 @@
 	{"PLAYER1_ACCEPT", 'E'},
 	{"PLAYER1_BACK", VK_ESCAPE},
 	{"PLAYER1_MENU", 'Q'},
+	{"PLAYER1_UPGRADE", 'Z'},
 	// Player 2 move keys
 	{"PLAYER2_UP", 'T'},
 	{"PLAYER2_DOWN", 'G'},
@@ -39,6 +40,7 @@
 	{"PLAYER2_ACCEPT", 'Y'},
 	{"PLAYER2_BACK", 'U'},
 	{"PLAYER2_MENU", 'R'},
+	{"PLAYER2_UPGRADE" , 'U'},
 	// Debugging keys
 	{"DEBUG_ZOOM", 'Z'},
 	{"DEBUG_SHOW_CLSN", VK_F4},
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 74)
+++ Source/Tower.cpp	(revision 75)
@@ -84,6 +84,7 @@
 	Vector3 towerPos;
 	Vector3 enemyPos;
 	float difX, difY, dist;
+	if(target != NULL)
 	enemyPos = target->getPosition();
 	towerPos = this->getPosition();
 	//get tower and target pos

------------------------------------------------------------------------
r76 | jdg0393 | 2020-11-24 23:02:40 -0600 (Tue, 24 Nov 2020) | 1 line

Added a new level. Need a level select scene ASAP.

Index: Source/TiledScene.h
===================================================================
--- Source/TiledScene.h	(revision 75)
+++ Source/TiledScene.h	(revision 76)
@@ -20,6 +20,7 @@
 	virtual void render() override;
 	void loadTileMap(std::string map_name, eSpriteType tileSpriteKey);
 	map<string, PathPoint> getPaths() { return paths; }
+	vector<PathPoint> getSpawnPoints() { return spawnPoints; }
 protected:
 	// Data about the tilemap
 	int tilemapWidth = 0; // Width of tilemap in tiles
@@ -33,6 +34,7 @@
 	std::vector<BoundingBox> clsnBoxes;
 	// List of points on the level's path
 	map<string, PathPoint> paths;
+	vector<PathPoint> spawnPoints;
 	// Boolean determining if we draw tilemap aabbs
 	bool drawMapClsn = false;
 	// Functions to add a single layer of a map
Index: Source/HatSelectScene.h
===================================================================
--- Source/HatSelectScene.h	(revision 75)
+++ Source/HatSelectScene.h	(revision 76)
@@ -15,10 +15,13 @@
 	void create() override;
 	void update() override;
 	void render() override;
+	void startLevel();
 protected:
 	vector<pair<string, eSpriteType>> hatsMenu;
 	pair<HUDObject*, HUDObject*> hats;
 	pair<int, int> selection;
+	pair<bool, bool> ready;
+	GameObject* controllerPrompt;
 	bool coOp;
 	bool controllerReady = true;
 };
Index: Source/WaveSpawner.cpp
===================================================================
--- Source/WaveSpawner.cpp	(revision 75)
+++ Source/WaveSpawner.cpp	(revision 76)
@@ -20,8 +20,12 @@
 			// If we haven't exceeded this waves max number of spawns and if it's time to spawn
 			if (spawnState.numberSpawned < maxSpawns && m_pStepTimer->GetTotalSeconds() > spawnState.nextSpawn) {
 
-				// Random spawning location out of 3 possible
-				string sp = "enSpawn" + to_string(m_pRandom->randn(1, 3));
+				// Get the spawn locations from the level
+				vector<PathPoint> spawnOptions = level->getSpawnPoints();
+				int numSpawnPoints = spawnOptions.size();
+				// Choose a random spawn location
+				PathPoint spawnPoint = spawnOptions[m_pRandom->randn(0, numSpawnPoints - 1)];
+
 				// Retrieve paths for starting points from level
 				map<string, PathPoint> paths = level->getPaths();
 
@@ -31,9 +35,9 @@
 				float yoffset = m_pRandom->randf();
 				float xoffset = m_pRandom->randf();
 				// Move the enemy to a spawn point
-				baddie->setPosition({ paths[sp].x + xoffset, paths[sp].y + yoffset, 1.15f });
+				baddie->setPosition({ spawnPoint.x + xoffset, spawnPoint.y + yoffset, 1.15f });
 				// Set the enemie's destination to be their starting point initially
-				baddie->setDestinationID(sp);
+				baddie->setDestinationID(spawnPoint.next);
 
 				// Increase the counter of number of enemies spawned
 				spawnState.numberSpawned++;
Index: Source/DesolateDesertLevel.h
===================================================================
--- Source/DesolateDesertLevel.h	(nonexistent)
+++ Source/DesolateDesertLevel.h	(revision 76)
@@ -0,0 +1,10 @@
+#pragma once
+#include "BaseLevelScene.h"
+class DesolateDesertLevel :
+	public BaseLevelScene
+{
+public:
+	DesolateDesertLevel(CGame* game, eSpriteType ply1Hat = WIZARD_HAT, eSpriteType ply2Hat = WIZARD_HAT, bool coop = false);
+	~DesolateDesertLevel();
+};
+
Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(revision 75)
+++ Source/TiledScene.cpp	(revision 76)
@@ -67,7 +67,8 @@
 	inData.close();
 
 	// Load each of the main 3 display layers
-	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey, 1.3f);
+	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey, 1.31f);
+	_loadTileLayer(map_name + "_bg2.txt", tileSpriteKey, 1.30f);
 	_loadTileLayer(map_name + "_fg.txt", tileSpriteKey, 1.2f);
 	_loadTileLayer(map_name + "_oh.txt", tileSpriteKey, 1.1f);
 	// Load the collision layer
@@ -150,7 +151,10 @@
 		PathPoint p;
 		inPath >> p.name >> p.x >> p.y >> p.next;
 		p.y = top - p.y;
-		paths[p.name] = p;
+		if (p.name == "spawn")
+			spawnPoints.push_back(p);
+		else
+			paths[p.name] = p;
 	}
 	inPath.close();
 }
\ No newline at end of file
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 75)
+++ Source/BaseLevelScene.h	(revision 76)
@@ -49,7 +49,9 @@
 	// Finds objects which are flagged to be removed and deletes them, removes from game lists
 	void cullObjects() override;
 
-private:
+protected:
+	string tileMapFileName = "simple";
+	eSpriteType tileSetSprite = SIMPLE_TILE;
 	pair<ShopMenu*, ShopMenu*> towerMenus;
 	bool gameOver = false;
 	float endTime = 0;
@@ -69,6 +71,8 @@
 	Vector3 defPos;
 	// Whether the camera is following
 	bool shouldFollow = false;
+	// Function to create the wave spawning descriptors
+	virtual void createSpawnDescriptors();
 	// Controlling the game
 	void handleControls();
 	// Creates a player object
Index: Source/DesolateDesertLevel.cpp
===================================================================
--- Source/DesolateDesertLevel.cpp	(nonexistent)
+++ Source/DesolateDesertLevel.cpp	(revision 76)
@@ -0,0 +1,9 @@
+#include "DesolateDesertLevel.h"
+
+DesolateDesertLevel::DesolateDesertLevel(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coop)
+	: BaseLevelScene(game, ply1Hat, ply2Hat, coop)
+{
+	tileMapFileName = "desolate_desert";
+	tileSetSprite = DESERT_TILE;
+}
+DesolateDesertLevel::~DesolateDesertLevel() {}
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 75)
+++ Source/Source.vcxproj	(revision 76)
@@ -171,6 +171,7 @@
     <ClCompile Include="Character.cpp" />
     <ClCompile Include="Coin.cpp" />
     <ClCompile Include="Common.cpp" />
+    <ClCompile Include="DesolateDesertLevel.cpp" />
     <ClCompile Include="Fireball.cpp" />
     <ClCompile Include="Game.cpp" />
     <ClCompile Include="GameObject.cpp" />
@@ -203,6 +204,7 @@
     <ClInclude Include="Character.h" />
     <ClInclude Include="Coin.h" />
     <ClInclude Include="Common.h" />
+    <ClInclude Include="DesolateDesertLevel.h" />
     <ClInclude Include="Explosive.h" />
     <ClInclude Include="Fireball.h" />
     <ClInclude Include="Game.h" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 75)
+++ Source/Source.vcxproj.filters	(revision 76)
@@ -76,6 +76,9 @@
     <ClCompile Include="Coin.cpp">
       <Filter>Objects</Filter>
     </ClCompile>
+    <ClCompile Include="DesolateDesertLevel.cpp">
+      <Filter>Scenes\Levels</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -162,6 +165,9 @@
     <ClInclude Include="Coin.h">
       <Filter>Objects</Filter>
     </ClInclude>
+    <ClInclude Include="DesolateDesertLevel.h">
+      <Filter>Scenes\Levels</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 75)
+++ Source/Renderer.cpp	(revision 76)
@@ -28,7 +28,6 @@
 	BeginResourceUpload();
 
 	// Loading of images goes here
-	Load(SIMPLE_TILE, "simple_tile");
 	Load(VIKING_HAT, "viking_hat");
 	Load(WIZARD_HAT, "wizard_hat");
 	Load(BULLET1, "bullet1");
@@ -43,6 +42,9 @@
 	Load(FIREBALL, "fireball");
 	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
+	// Tilesets
+	Load(SIMPLE_TILE, "simple_tile");
+	Load(DESERT_TILE, "desert_tile");
 	// Currency
 	Load(COIN, "coin");
 	Load(COIN_STACK, "coin_stack");
@@ -52,6 +54,7 @@
 	Load(MENU_BOX, "menu_box");
 	Load(BLACK_SQUARE, "black_square");
 	Load(GREENLINE_SPRITE, "greenline");
+	Load(BUTTON_GREEN, "button_green");
 	// Characters
 	Load(HUMAN_IDLE, "human_idle");
 	Load(HUMAN_WALK, "human_walk");
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 75)
+++ Source/GameDefines.h	(revision 76)
@@ -10,7 +10,6 @@
 ///
 /// Note: NUM_SPRITES must be last.
 enum eSpriteType {
-	SIMPLE_TILE,
 	VIKING_HAT,
 	WIZARD_HAT,
 	BULLET1,
@@ -25,6 +24,9 @@
 	FIREBALL,
 	EXPLOSION,
 	SMOKE,
+	// Tilesets
+	SIMPLE_TILE,
+	DESERT_TILE,
 	// Currency
 	COIN,
 	COIN_STACK,
@@ -34,6 +36,7 @@
 	MENU_BOX,
 	BLACK_SQUARE,
 	GREENLINE_SPRITE,
+	BUTTON_GREEN,
 	// Characters
 	HUMAN_IDLE,
 	HUMAN_WALK,
Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 75)
+++ Source/HatSelectScene.cpp	(revision 76)
@@ -3,6 +3,7 @@
 #include "Controller.h"
 #include "GamepadWrapper.h"
 #include "BaseLevelScene.h"
+#include "DesolateDesertLevel.h"
 
 HatSelectScene::HatSelectScene(CGame* game, bool coOp) : Scene(game) {
 	this->coOp = coOp;
@@ -12,6 +13,10 @@
 	};
 	selection.first = 0;
 	selection.second = 0;
+	controllerPrompt = addObject(new GameObject(this, BUTTON_GREEN));
+	controllerPrompt->m_fAlpha = 0.0f;
+	controllerPrompt->m_fXScale = 0.2f;
+	controllerPrompt->m_fYScale = 0.2f;
 }
 
 HatSelectScene::~HatSelectScene() {}
@@ -44,6 +49,15 @@
 		(selection.first + 1) % (int)hatsMenu.size();
 	// Control the selection with controller
 	if (controllerOwner == 1) {
+		if (!ready.first) {
+			controllerPrompt->m_fAlpha = 1.0f;
+			if (coOp) {
+				controllerPrompt->m_vPos = { 246.0f, 174.0f, 0.0f };
+			}
+			else {
+				controllerPrompt->m_vPos = { 545.0f, 174.0f, 0.0f };
+			}
+		}
 		if (gamepad.isPressed("LSTICK_LEFT")) selection.first--;
 		else if (gamepad.isPressed("LSTICK_RIGHT")) selection.first =
 			(selection.first + 1) % (int)hatsMenu.size();
@@ -60,6 +74,10 @@
 			(selection.second + 1) % (int)hatsMenu.size();
 		// Control the selection with controller
 		if (controllerOwner == 2) {
+			if (!ready.second) {
+				controllerPrompt->m_fAlpha = 1.0f;
+				controllerPrompt->m_vPos = { 869.5f, 174.0f, 0.0f };
+			}
 			if (gamepad.isPressed("LSTICK_LEFT")) selection.second--;
 			else if (gamepad.isPressed("LSTICK_RIGHT")) selection.second =
 				(selection.second + 1) % (int)hatsMenu.size();
@@ -68,13 +86,21 @@
 		if (selection.second < 0) selection.second = (int)hatsMenu.size() - 1;
 	}
 
-	// Check for selection confirmation and proceed
-	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_ACCEPT"]) || gamepad.isPressed("BUTTON_A")) {
-		m_pAudio->stop();
-		game->startScene(new BaseLevelScene(game,
-			hatsMenu[selection.first].second,
-			hatsMenu[selection.second].second, coOp));
+	// Check for selection confirmation
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_ACCEPT"])) {
+		ready.first = true;
 	}
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER2_ACCEPT"])) {
+		ready.second = true;
+	}
+	if (gamepad.isPressed("BUTTON_A")) {
+		if (controllerOwner == 1) ready.first = true;
+		else if (controllerOwner == 2) ready.second = true;
+		controllerPrompt->m_fAlpha = 0.0f;
+	}
+
+	// Proceed when both players have readied.
+	if (ready.first && (ready.second || !coOp)) startLevel();
 }
 
 void HatSelectScene::render() {
@@ -86,10 +112,57 @@
 	// Position hat name text of Player 1
 	float x = hats.first->m_vPos.x - (7.0f * hatsMenu[selection.first].first.size());
 	m_pRenderer->DrawScreenText(hatsMenu[selection.first].first.c_str(), Vector2(x, 420), Colors::Black);
+	// Display the player's ready status
+	if (ready.first) {
+		if (coOp)
+			m_pRenderer->DrawScreenText("Ready!", Vector2(290, 530), Colors::Black);
+		else
+			m_pRenderer->DrawScreenText("Ready!", Vector2(540, 530), Colors::Black);
+	}
+	else
+	{
+		string prompt = "Press ";
+		if (controllerOwner == 1) {
+			prompt += " A ";
+		}
+		else {
+			prompt += keyboardKeys[controlMap["PLAYER1_ACCEPT"]];
+		}
+		prompt += " to confirm your choice!";
+		if (coOp)
+			m_pRenderer->DrawScreenText(prompt.c_str(), Vector2(150, 530), Colors::Black);
+		else
+			m_pRenderer->DrawScreenText(prompt.c_str(), Vector2(450, 530), Colors::Black);
+	}
 	if (coOp) {
 		// Position hat name text of Player 2
 		x = hats.second->m_vPos.x - (7.0f * hatsMenu[selection.second].first.size());
 		m_pRenderer->DrawScreenText(hatsMenu[selection.second].first.c_str(), Vector2(x, 420), Colors::Black);
+		// Display the player's ready status
+		if (ready.second) {
+			m_pRenderer->DrawScreenText("Ready!", Vector2(915, 530), Colors::Black);
+		}
+		else
+		{
+			string prompt = "Press ";
+			if (controllerOwner == 2) {
+				prompt += " A ";
+			}
+			else {
+				prompt += keyboardKeys[controlMap["PLAYER2_ACCEPT"]];
+			}
+			prompt += " to confirm your choice!";
+			m_pRenderer->DrawScreenText(prompt.c_str(), Vector2(775, 530), Colors::Black);
+		}
 	}
+}
 
+void HatSelectScene::startLevel() {
+	m_pAudio->stop();
+	//game->startScene(new BaseLevelScene(game,
+	//	hatsMenu[selection.first].second,
+	//	hatsMenu[selection.second].second, coOp));
+	game->startScene(new DesolateDesertLevel(game,
+		hatsMenu[selection.first].second,
+		hatsMenu[selection.second].second, coOp));
 }
\ No newline at end of file
Index: Source/Renderer.h
===================================================================
--- Source/Renderer.h	(revision 75)
+++ Source/Renderer.h	(revision 76)
@@ -15,6 +15,8 @@
 			1.15 -> Player & most objects
 		1.2 -> Foreground Tile Layer
 	    1.3 -> Background Tiles Layer
+			1.30 -> Background 2
+			1.31 -> Background 1
 	10
 		10.0 -> Black Background
 	(Lower depth means closer to the camera)
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 75)
+++ Source/BaseLevelScene.cpp	(revision 76)
@@ -28,31 +28,8 @@
 	towerMenus.first = (ShopMenu*)addObject(new ShopMenu(this, -0.5f, -0.3f));
 	towerMenus.second = (ShopMenu*)addObject(new ShopMenu(this, 0.5f, -0.3f, "PLAYER2"));
 
-	// Define some spawn descriptors for the wave spawner
-	SpawnDesc goblins;
-	goblins.addPerWave = 10;
-	goblins.multiplyPerWave = 1.1f;
-	goblins.nextSpawn = m_pStepTimer->GetTotalSeconds();
-	goblins.numberSpawned = 0;
-	goblins.ready = true;
-	goblins.startWave = 1;
-	goblins.timeAddPerSpawn = -0.01f;
-	goblins.timeMultiplyPerSpawn = 0.9f;
-	goblins.timeToSpawn = 3.0f;
-	SpawnDesc minotaurs;
-	minotaurs.key = "minotaur";
-	minotaurs.addPerWave = 3;
-	minotaurs.multiplyPerWave = 1.2f;
-	minotaurs.nextSpawn = m_pStepTimer->GetTotalSeconds() + 6.0f;
-	minotaurs.numberSpawned = 0;
-	minotaurs.ready = true;
-	minotaurs.startWave = 2;
-	minotaurs.timeAddPerSpawn = -3.0f;
-	minotaurs.timeMultiplyPerSpawn = 1.0f;
-	minotaurs.timeToSpawn = 12.0f;
-	// Add the spawn descriptions
-	waves->addSpawnDesc(goblins);
-	waves->addSpawnDesc(minotaurs);
+	// Spawn descriptors that can be changed in inherited classes
+	createSpawnDescriptors();
 }
 
 BaseLevelScene::~BaseLevelScene() {
@@ -67,10 +44,10 @@
 	// Track the original camera position for easy scaling
 	defPos = m_pRenderer->GetCameraPos();
 	// Create the simple tilemap
-	loadTileMap("simple", SIMPLE_TILE);
+	loadTileMap(tileMapFileName, tileSetSprite);
 	backgroundSprite->m_vPos = { (tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, 10.0f };
-	backgroundSprite->m_fYScale = backgroundSprite->m_fYScale * 1.5f;
-	backgroundSprite->m_fXScale = backgroundSprite->m_fXScale * 1.5f;
+	backgroundSprite->m_fYScale = tilemapHeight * tileSize;
+	backgroundSprite->m_fXScale = tilemapWidth * tileSize;
 	// Place the player on the map
 	_createPlayer(players.first, hats.first);
 	if (coOp) _createPlayer(players.second, hats.second, "PLAYER2");
@@ -198,7 +175,7 @@
 		shouldFollow = false;
 		followTargets.first = nullptr;
 		followTargets.second = nullptr;
-		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, defPos.z * 2.0f));
+		m_pRenderer->SetCameraPos(Vector3((tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, -70.0f * tilemapHeight));
 	}
 }
 
@@ -490,4 +467,32 @@
 }
 void BaseLevelScene::removeCredits(int amount) {
 	credits -= amount;
+}
+
+void BaseLevelScene::createSpawnDescriptors() {
+	// Define some spawn descriptors for the wave spawner
+	SpawnDesc goblins;
+	goblins.addPerWave = 10;
+	goblins.multiplyPerWave = 1.1f;
+	goblins.nextSpawn = m_pStepTimer->GetTotalSeconds();
+	goblins.numberSpawned = 0;
+	goblins.ready = true;
+	goblins.startWave = 1;
+	goblins.timeAddPerSpawn = -0.01f;
+	goblins.timeMultiplyPerSpawn = 0.9f;
+	goblins.timeToSpawn = 3.0f;
+	SpawnDesc minotaurs;
+	minotaurs.key = "minotaur";
+	minotaurs.addPerWave = 3;
+	minotaurs.multiplyPerWave = 1.2f;
+	minotaurs.nextSpawn = m_pStepTimer->GetTotalSeconds() + 6.0f;
+	minotaurs.numberSpawned = 0;
+	minotaurs.ready = true;
+	minotaurs.startWave = 2;
+	minotaurs.timeAddPerSpawn = -3.0f;
+	minotaurs.timeMultiplyPerSpawn = 1.0f;
+	minotaurs.timeToSpawn = 12.0f;
+	// Add the spawn descriptions
+	waves->addSpawnDesc(goblins);
+	waves->addSpawnDesc(minotaurs);
 }
\ No newline at end of file

------------------------------------------------------------------------
r77 | amm0837 | 2020-11-28 14:56:15 -0600 (Sat, 28 Nov 2020) | 1 line

fixed bug where towers kept shooting at enemies while their death animation was playing

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 76)
+++ Source/BaseLevelScene.cpp	(revision 77)
@@ -278,8 +278,8 @@
 			}
 		}
 	}
+	
 
-
 	if (m_pKeyboard->TriggerDown('X')) {
 		GameObject* tow = getClosestTower();
 		if (tow != NULL && distToTower() <= 75) {
@@ -294,6 +294,10 @@
 	}
 }
 
+void BaseLevelScene::handleMouse() {
+	
+}
+
 void BaseLevelScene::cullObjects() {
 	size_t sz = objectList.size();
 	for (int i = 0; i < sz; i++) {
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 76)
+++ Source/Tower.cpp	(revision 77)
@@ -17,39 +17,42 @@
 void Tower::update() {
 	if (m_pStepTimer->GetTotalSeconds() > m_fGunTimer + 1) {
 		target = calcTarget();
-		m_fGunTimer = m_pStepTimer->GetTotalSeconds();
-		if (this->is("tower")&& this->is("mage")) {		//add conditions for other towers here, set bullet type
-			Vector3 pos = this->getPosition();
-			//creating bullet and setting its bounding box
-			if (this->is("lvl0") && this->distToTarget() <= 250) {
-				GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 0));
-				fire(b);
+		BadCharacter* baddie = dynamic_cast<BadCharacter*>(target);
+		
+			m_fGunTimer = m_pStepTimer->GetTotalSeconds();
+			if (this->is("tower") && this->is("mage")) {		//add conditions for other towers here, set bullet type
+				Vector3 pos = this->getPosition();
+				//creating bullet and setting its bounding box
+				if (this->is("lvl0") && this->distToTarget() <= 250) {
+					GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 0));
+					fire(b);
+				}
+				if (this->is("lvl1") && this->distToTarget() <= 350) {
+					GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 1));
+					fire(b);
+				}
+				else if (this->is("lvl2") && this->distToTarget() <= 500) {
+					GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 2));
+					fire(b);
+				}
 			}
-			if (this->is("lvl1") && this->distToTarget() <= 350) {
-				GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 1));
-				fire(b);
+			else if (this->is("tower") && this->is("range")) {
+				Vector3 pos = this->getPosition();
+				//creating bullet and setting its bounding box
+				if (this->is("lvl0") && this->distToTarget() <= 300) {
+					GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 0));
+					fire(b);
+				}
+				if (this->is("lvl1") && this->distToTarget() <= 400) {
+					GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 1));
+					fire(b);
+				}
+				else if (this->is("lvl2") && this->distToTarget() <= 550) {
+					GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 2));
+					fire(b);
+				}
 			}
-			else if (this->is("lvl2") && this->distToTarget() <= 500) {
-				GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 2));
-				fire(b);
-			}
-		}
-		else if (this->is("tower") && this->is("range")) {
-			Vector3 pos = this->getPosition();
-			//creating bullet and setting its bounding box
-			if (this->is("lvl0") && this->distToTarget() <= 300) {
-				GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z,0));
-				fire(b);
-			}
-			if (this->is("lvl1") && this->distToTarget() <= 400 ) {
-				GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 1));
-				fire(b);
-			}
-			else if (this->is("lvl2") && this->distToTarget() <= 550) {
-				GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 2));
-				fire(b);
-			}
-		}
+		
 	}
 }
 
@@ -58,26 +61,26 @@
 	Vector3 enemyPos;
 
 	GameObject* enemy = nullptr;
-
+	
 	float difX = 1000, difY = 1000, dif = 1000;
 	for (GameObject* obj : ((BaseLevelScene*)scene)->getBaddies()) {
 		enemyPos = obj->getPosition();		//enemy position
 		towerPos = this->getPosition();		//tower position
-
+		BadCharacter* baddie = dynamic_cast<BadCharacter*>(obj);
 		difX = abs(enemyPos.x - towerPos.x);		//pythagorean to find nearest enemy object
 		difY = abs(enemyPos.y - towerPos.y);
-		if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif) {
+		if (sqrt(pow(difX, 2) + pow(difY, 2)) < dif && (!baddie -> isDying())) {
 			dif = sqrt(pow(difX, 2) + pow(difY, 2));
 			enemy = obj;
 		}
 
 	}
-
-	if (((BaseLevelScene*)scene)->getBaddies().size() == 0){
+	
+	if (((BaseLevelScene*)scene)->getBaddies().size() == 0 ){
 		return nullptr;
 	}
 	else
-	return enemy;
+		return enemy;
 }
 
 float Tower::distToTarget() {
Index: Source/Game.cpp
===================================================================
--- Source/Game.cpp	(revision 76)
+++ Source/Game.cpp	(revision 77)
@@ -22,7 +22,7 @@
 	m_pRenderer->Initialize(NUM_SPRITES);
 	m_pRenderer->LoadImages(); //load images from xml file list
 	m_pAudio->Load(); //load the sounds for this game
-
+	
 	if (gamepad.connected()) controllerOwner = 2;
 
 	// Start the initial scene, maybe this should be a main menu?
@@ -38,7 +38,6 @@
 		DestroyWindow(m_Hwnd);
 
 	m_pAudio->BeginFrame(); //notify audio player that frame has begun
-
 	// Get key/control states
 	m_pKeyboard->GetState();
 	if (controllerOwner > -1) gamepad.getState();
Index: Source/Scene.h
===================================================================
--- Source/Scene.h	(revision 76)
+++ Source/Scene.h	(revision 77)
@@ -8,6 +8,7 @@
 #include "GameObject.h"
 #include "HUDObject.h"
 
+
 // Forward declarations of classes that will exist
 // (We can't just include it b/c of circular dependency
 class CGame;
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 76)
+++ Source/BaseLevelScene.h	(revision 77)
@@ -75,6 +75,7 @@
 	virtual void createSpawnDescriptors();
 	// Controlling the game
 	void handleControls();
+	void handleMouse();
 	// Creates a player object
 	void _createPlayer(PlayerCharacter*& player, eSpriteType hat, string id = "PLAYER1");
 	// Collision handling

------------------------------------------------------------------------
r78 | jdg0393 | 2020-11-29 16:22:52 -0600 (Sun, 29 Nov 2020) | 1 line

Pseudo-physics system and game prompting. This should have been two separate commits but I forgot. Oops.

Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 77)
+++ Source/Tower.cpp	(revision 78)
@@ -116,7 +116,8 @@
 		b->m_fRoll = atan2f(dir.y, dir.x) - XM_PI / 2.0f;
 		const Vector2 view = b->getViewVect();			//once the roll angle of bullet is set, we can use the view vector to set
 														//the direction of bullet velocity
-		b->setVelocity(500.0f * view);
+		//b->setVelocity(500.0f * view);
+		b->addForce(500.0f * view, 1000.0f);
 		b->setRoll(b->m_fRoll);
 	}
 	else {
Index: Source/TitleScreenScene.h
===================================================================
--- Source/TitleScreenScene.h	(revision 77)
+++ Source/TitleScreenScene.h	(revision 78)
@@ -6,10 +6,10 @@
 class CGame;
 
 class TitleScreenScene :
-    public Scene
+	public Scene
 {
 public:
-    TitleScreenScene(CGame* game);
+	TitleScreenScene(CGame* game);
 	virtual ~TitleScreenScene() override;
 	virtual void create() override;
 	virtual void update() override;
@@ -20,5 +20,6 @@
 	void _accept();
 	void _handleKeyboard();
 	void _handleController();
+	GameObject* physBall = nullptr;
 };
 
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 77)
+++ Source/GameObject.h	(revision 78)
@@ -6,6 +6,7 @@
 #include "Common.h"
 #include "StepTimer.h"
 #include "AnimationDesc.h"
+#include "PseudoForce.h"
 
 // Forward declarations of classes that will exist
 // (We can't just include it b/c of circular dependency
@@ -20,16 +21,13 @@
 	virtual ~GameObject();
 	virtual void update(); // Method runs every tick/update
 
-	// Motion related methods
+	// Positioning related methods
 	void setRoll(float angle);
 	float getRoll();
-	void setVelocity(const Vector2& v);
-	void setForceVelocity(const Vector2& v);
-	const Vector2& getVelocity();
 	const Vector3& getPosition();
+	const Vector2& getOldPosition();
 	void setPosition(const Vector3& pos);
 	bool inRadius(Vector3 pos, float dist);
-	virtual void move(); // Move the character once based on their velocity
 	virtual void unmove(); // Undo the character's last movement
 
 	// Description methods
@@ -47,16 +45,26 @@
 	Vector2 getViewVect();
 	bool getWillCull(); //true if dead, false otherwise
 	virtual void kill(); // set isdead flag to true;
-	void upgradeSprite(GameObject* obj);
 	void explode(); // particle effect for fireball explosion
+
+	// Physics
+	vector<PseudoForce> forces;
+	virtual void applyForces();
+	void updateForces();
+	Vector2 getNetForce();
+	void addForce(PseudoForce force);
+	void addForce(Vector2 initial, float decay);
+	void addForce(float magnitude, float angleInDegrees, float decay);
+	void pushBack();
+	void absoluteStop();
 protected:
-	Scene* scene; // Scene which manages this object
+	// Scene which manages this object
+	Scene* scene;
 	// Stores the position from the previous frame
 	Vector2 oldPosition;
-	// Speed and direction of motion
-	Vector2 velocity = Vector2::Zero;
-	Vector2 forceVelocity = Vector2::Zero;
+	// Whether the object should be deleted next frame
 	bool willCull = false;
+	// Descriptor tags for the object
 	unordered_set<string> tags;
 	// Animation related variables
 	AnimationDesc activeAnimation;
Index: Source/PseudoForce.h
===================================================================
--- Source/PseudoForce.h	(nonexistent)
+++ Source/PseudoForce.h	(revision 78)
@@ -0,0 +1,18 @@
+#pragma once
+#include "Component.h"
+#include "Common.h"
+
+class PseudoForce :
+	public CComponent,
+	public CCommon
+{
+public:
+	PseudoForce(Vector2 initial, float decayTime);
+	Vector2 get();
+	bool isDead();
+	Vector2 initial;
+	float startTime;
+	float decayTime;
+	static const float Instant;
+};
+
Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 77)
+++ Source/HatSelectScene.cpp	(revision 78)
@@ -159,10 +159,10 @@
 
 void HatSelectScene::startLevel() {
 	m_pAudio->stop();
-	//game->startScene(new BaseLevelScene(game,
+	game->startScene(new BaseLevelScene(game,
+		hatsMenu[selection.first].second,
+		hatsMenu[selection.second].second, coOp));
+	//game->startScene(new DesolateDesertLevel(game,
 	//	hatsMenu[selection.first].second,
 	//	hatsMenu[selection.second].second, coOp));
-	game->startScene(new DesolateDesertLevel(game,
-		hatsMenu[selection.first].second,
-		hatsMenu[selection.second].second, coOp));
 }
\ No newline at end of file
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 77)
+++ Source/GameObject.cpp	(revision 78)
@@ -16,26 +16,11 @@
 
 void GameObject::update() {
 	stepAnimation();
-	move();
+	//move();
+	applyForces();
+	updateForces();
 }
 
-void GameObject::move() {
-	// Store the current position
-	oldPosition = { m_vPos.x, m_vPos.y };
-	// Get the time passed since last frame
-	const float t = m_pStepTimer->GetElapsedSeconds();
-	// Adjusted velocity based on force velocity
-	Vector2 adjustedVelocity = velocity + forceVelocity;
-	// Move based on velocity (in px/s) * time (in s)
-	m_vPos.x += adjustedVelocity.x * t;
-	m_vPos.y += adjustedVelocity.y * t;
-	// Update the bounding box location
-	m_sAabb.Center.x = m_vPos.x;
-	m_sAabb.Center.y = m_vPos.y;
-	// Reduce the force velocity over time
-	forceVelocity /= 2;
-}
-
 void GameObject::unmove() {
 	// Store the current position
 	Vector2 nowPos = { m_vPos.x, m_vPos.y };
@@ -49,13 +34,6 @@
 	m_sAabb.Center.y = m_vPos.y;
 }
 
-void GameObject::upgradeSprite(GameObject* obj) {
-	//eSpriteType t = eSpriteType(obj->getSpriteType());
-	if (obj->is("range")) {
-
-	}
-}
-
 bool GameObject::inRadius(Vector3 pos, float dist) {		//returns true if object is within dist of pos
 	if (abs(sqrt(pow(pos.x, 2) + pow(pos.y, 2)) - sqrt(pow(this->getPosition().x, 2) + pow(this->getPosition().y, 2))) <= dist)
 		return true;
@@ -99,20 +77,14 @@
 	return m_vPos;
 }
 
+const Vector2& GameObject::getOldPosition() {
+	return oldPosition;
+}
+
 void GameObject::setPosition(const Vector3& pos) {
 	m_vPos = pos;
 }
 
-void GameObject::setVelocity(const Vector2& v) {
-	velocity = v;
-}
-void GameObject::setForceVelocity(const Vector2& v) {
-	forceVelocity = v;
-	//printf("Force Velocity: %f %f\n", forceVelocity.x, forceVelocity.y);
-}
-const Vector2& GameObject::getVelocity() {
-	return velocity;
-}
 int GameObject::getSpriteType() {
 	return m_nSpriteIndex;
 }
@@ -168,4 +140,66 @@
 
 bool GameObject::isPlayingAnimation(AnimationDesc& anim) {
 	return isAnimating && activeAnimation == anim;
+}
+
+// Pseudo physics stuff
+void GameObject::applyForces() {
+	// Update the tracker of object's previous position
+	oldPosition = { m_vPos.x, m_vPos.y };
+	// Get the time elapsed since last frame
+	float t = m_pStepTimer->GetElapsedSeconds();
+	// Get the force over time
+	Vector2 transform = getNetForce() * t;
+	// Safeguard, hopefully this never runs. Prevents mega-forces that shouldn't exist anyway
+	if (transform.Length() > 128.0f)
+		return;
+	// Move the object
+	m_vPos.x += transform.x;
+	m_vPos.y += transform.y;
+	// Update the bounding box location
+	m_sAabb.Center.x = m_vPos.x;
+	m_sAabb.Center.y = m_vPos.y;
+}
+void GameObject::updateForces() {
+	// Delete any forces which have expired
+	forces.erase(std::remove_if(forces.begin(), forces.end(),
+		[](auto& force) { return force.isDead(); }), forces.end());
+}
+Vector2 GameObject::getNetForce() {
+	Vector2 net = { 0, 0 };
+	for (auto force : forces) {
+		net += force.get();
+	}
+	return net;
+}
+void GameObject::addForce(PseudoForce force) {
+	forces.push_back(force);
+}
+void GameObject::addForce(Vector2 initial, float decay) {
+	forces.push_back(PseudoForce(initial, decay));
+}
+void GameObject::addForce(float magnitude, float angleInDegrees, float decay) {
+	// Convert the angle to radians for mathematics
+	float angleInRadians = angleInDegrees * (MY_PI / 180);
+	// X component and Y component calculations
+	float xComponent = magnitude * cosf(angleInRadians);
+	float yComponent = magnitude * sinf(angleInRadians);
+	// Add the force
+	forces.push_back(PseudoForce({ xComponent, yComponent }, decay));
+}
+void GameObject::pushBack() {
+	Vector2 oldp = getOldPosition();
+	Vector2 newp = Vector2(m_vPos.x, m_vPos.y);
+	// Get the direction the player was traveling
+	Vector2 motion = oldp - newp;
+	motion *= 2.0f;
+	//motion *= getNetForce();
+	// Move the player back to their old position
+	unmove();
+	addForce(motion, 0.3f);
+	applyForces();
+}
+void GameObject::absoluteStop() {
+	forces.clear();
+	pushBack();
 }
\ No newline at end of file
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 77)
+++ Source/BadCharacter.cpp	(revision 78)
@@ -36,14 +36,13 @@
 		}
 		else {
 			// Get some money
-			//level->addCredits(1);
 			scene->addObject(new Coin(scene, m_pRandom->randn(1, 10), m_vPos.x, m_vPos.y));
 			// Destroy this creature once it's faded out
 			kill();
 		}
 	}
-	// If targeting the tower and within range, attack it!
-	else if (destID == "end" && m_sAabb.Intersects(level->getSpire()->m_sAabb)) {
+	// If targeting the spire and within range, attack it!
+	else if (destID == "end" && m_sAabb.Intersects(level->getSpire()->attackZone)) {
 		Vector2 spire = level->getSpire()->getPosition();
 		isStopped = true;
 		isAttacking = true;
@@ -59,7 +58,9 @@
 	// Move the bad guy
 	if (!dying)
 		_updateVelocity();
-	if (!isStopped) move();
+	//if (!isStopped) move();
+	applyForces();
+	updateForces();
 	// Updates what animation is playing
 	_updateAnimation();
 }
@@ -117,5 +118,6 @@
 	// Calculate the angle in degrees
 	angle = angle_in_radians * (180 / MY_PI);
 	// Calculate the velocity
-	velocity = { 40 * cosf(angle_in_radians), 40 * sinf(angle_in_radians) };
+	Vector2 velocity = { 40 * cosf(angle_in_radians), 40 * sinf(angle_in_radians) };
+	if (!isStopped)addForce(velocity, PseudoForce::Instant);
 }
\ No newline at end of file
Index: Source/PseudoForce.cpp
===================================================================
--- Source/PseudoForce.cpp	(nonexistent)
+++ Source/PseudoForce.cpp	(revision 78)
@@ -0,0 +1,32 @@
+#include "PseudoForce.h"
+#include "StepTimer.h"
+
+const float PseudoForce::Instant = 0.0f;
+
+PseudoForce::PseudoForce(Vector2 velocity, float decayTime) {
+	this->initial = velocity;
+	this->decayTime = decayTime;
+	this->startTime = m_pStepTimer->GetTotalSeconds();
+}
+
+Vector2 PseudoForce::get() {
+	// "Instant Forces" should just return the force provided
+	if (decayTime == PseudoForce::Instant)
+		return initial;
+	else {
+		// Other forces should be proportional to their rate of decay
+		float elapsedTime = m_pStepTimer->GetTotalSeconds() - startTime;
+		float decayPercent = elapsedTime / decayTime;
+		Vector2 decay = initial * decayPercent;
+		return initial - decay;
+	}
+}
+
+bool PseudoForce::isDead() {
+	// "Instant Forces" die the first time they are checked
+	if (decayTime == PseudoForce::Instant) return true;
+	else {
+		float elapsedTime = m_pStepTimer->GetTotalSeconds() - startTime;
+		return decayTime - elapsedTime <= 0.0f;
+	}
+}
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 77)
+++ Source/BaseLevelScene.cpp	(revision 78)
@@ -46,8 +46,8 @@
 	// Create the simple tilemap
 	loadTileMap(tileMapFileName, tileSetSprite);
 	backgroundSprite->m_vPos = { (tilemapWidth / 2.0f) * tileSize, (tilemapHeight / 2.0f) * tileSize, 10.0f };
-	backgroundSprite->m_fYScale = tilemapHeight * tileSize;
-	backgroundSprite->m_fXScale = tilemapWidth * tileSize;
+	backgroundSprite->m_fYScale = (float)(tilemapHeight * tileSize);
+	backgroundSprite->m_fXScale = (float)(tilemapWidth * tileSize);
 	// Place the player on the map
 	_createPlayer(players.first, hats.first);
 	if (coOp) _createPlayer(players.second, hats.second, "PLAYER2");
@@ -278,8 +278,8 @@
 			}
 		}
 	}
-	
 
+
 	if (m_pKeyboard->TriggerDown('X')) {
 		GameObject* tow = getClosestTower();
 		if (tow != NULL && distToTower() <= 75) {
@@ -295,7 +295,7 @@
 }
 
 void BaseLevelScene::handleMouse() {
-	
+
 }
 
 void BaseLevelScene::cullObjects() {
@@ -395,21 +395,23 @@
 
 // Handler for collisions, check for specific object types and handle collisions for them
 void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
-	// Stop the player from moving into solid objects
-	if (obj1->is("player") && obj2->is("unpassable")) ((PlayerCharacter*)obj1)->unmove();
+	// Stop the player (or enemies) from moving into solid objects
+	if ((obj1->is("player") || obj1->is("baddie")) && obj2->is("unpassable")) {
+		obj1->pushBack();
+	}
 	// Enemies running into each other
 	if (obj1->is("baddie") && obj2->is("baddie")) {
 		// Get the vector between the two objects positions
-		Vector2 force = obj2->getPosition() - obj1->getPosition();
+		Vector2 between = obj2->getPosition() - obj1->getPosition();
 		// Get just the direction between the two objects
-		force.Normalize();
-		// Scale force to the size of the velocity to oppose it
-		force *= obj2->getVelocity().Length();
+		between.Normalize();
 		// Change the direction of the bad guy a little bit
-		if (force.x > force.y) force.x *= 2.5f;
-		else force.y *= 2.5f;
+		if (between.x > between.y) between.x *= 10.0f;
+		else between.y *= 10.0f;
 		// Force the second object to go around
-		obj2->setForceVelocity(force);
+		obj2->addForce(between, 0.05f);
+		// Prevent object overlap
+		obj2->pushBack();
 	}
 	// Collecting of coins
 	if (obj1->is("player") && obj2->is("coins")) {
@@ -424,7 +426,8 @@
 		if (!baddie->isDying()) {
 			baddie->damage(p->damage);
 			// Knockback from the projectile
-			obj2->setForceVelocity(obj1->getVelocity());
+			//obj2->setForceVelocity(obj1->getVelocity());
+			obj2->addForce(obj1->getNetForce(), 0.25f);
 			// Don't kill if object is explosive, we need it's properties until it's
 			// killed in the handler for explosives
 			if (!obj1->is("explosive"))
@@ -438,7 +441,7 @@
 			Explosive* expl = dynamic_cast<Explosive*>(obj1);
 			// Get all bad guys in the scene
 			for (BadCharacter* obj : this->getBaddies()) {
-				if (obj != obj2 && obj->inRadius(obj1->getPosition(), expl->radius) && !obj->isDying()) {
+				if (obj != obj2 && obj->inRadius(obj1->getPosition(), expl->radius) && !obj->isDying() && !expl->detonated) {
 					// Damage the bad guy
 					obj->damage(expl->splash);
 					// Get the vector between the explosion center and the object
@@ -445,9 +448,9 @@
 					Vector2 force = obj->getPosition() - obj1->getPosition();
 					force.Normalize();
 					// Scale the knockback force
-					force *= obj1->getVelocity().Length();
+					force *= 35.0f;
 					// Apply knockback to enemy
-					obj->setForceVelocity(force);
+					obj->addForce(force, 0.25f);
 				}
 			}
 			// Destroy the explosive
@@ -459,7 +462,9 @@
 }
 
 void BaseLevelScene::TilemapClsn(GameObject* obj) {
-	if (obj->is("player")) ((PlayerCharacter*)obj)->unmove();
+	if (obj->is("player") || obj->is("baddie")) {
+		obj->absoluteStop();
+	}
 	if (obj->is("projectile")) obj->kill();
 }
 
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 77)
+++ Source/Fireball.cpp	(revision 78)
@@ -26,7 +26,10 @@
 
 void Fireball::update() {
 	stepAnimation();
-	if (!detonated) move();
+	if (!detonated) {
+		applyForces();
+		updateForces();
+	}
 }
 
 void Fireball::kill() {
Index: Source/Character.cpp
===================================================================
--- Source/Character.cpp	(revision 77)
+++ Source/Character.cpp	(revision 78)
@@ -5,22 +5,13 @@
 {}
 Character::~Character() {}
 
-void Character::setVelocity(float speed, float angle_in_degrees) {
+void Character::setVelocity(float speed, float angleInDegrees) {
 	// The desired speed
 	this->speed = speed;
 	// Set the player's angle (we use this elsewhere as well)
-	angle = angle_in_degrees;
-	// Convert the angle to radians for mathematics
-	float angle_in_radians = angle_in_degrees * (MY_PI / 180);
-	// Calculate and round to 4 decimals the x component of the velocity
-	float xSpeed = speed * cos(angle_in_radians);
-	xSpeed = roundf(xSpeed * 10000) / 10000;
-	// Calculate and round to 4 decimals the y component of the velocity
-	float ySpeed = speed * sin(angle_in_radians);
-	ySpeed = roundf(ySpeed * 10000) / 10000;
-	//printf("%fvx %fvy\n", xSpeed, ySpeed);
-	// Set the player's velocity
-	velocity = { xSpeed, ySpeed };
+	angle = angleInDegrees;
+	// Add the force to the character
+	addForce(speed, angleInDegrees, PseudoForce::Instant);
 }
 
 void Character::calculateAnimationDirection() {
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 77)
+++ Source/Renderer.cpp	(revision 78)
@@ -65,6 +65,8 @@
 	// Load any additional fonts
 	loadNewFont("title_font");
 	loadNewFont("selection_font");
+	loadNewFont("prompt_font");
+	loadNewFont("big_prompt_font");
 
 	EndResourceUpload();
 
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 77)
+++ Source/BadCharacter.h	(revision 78)
@@ -23,7 +23,7 @@
 	map<string, PathPoint> paths;
 	Vector2 dest = { 0,0 };
 	string destID = "";
-	float dist = 0; // Distance from the destination
+	float dist = 100000.0f; // Distance from the destination
 	void _updateAnimation();
 	void _updateDestination();
 	void _updateVelocity();
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 77)
+++ Source/PlayerCharacter.cpp	(revision 78)
@@ -31,10 +31,19 @@
 	// Animate the character
 	stepAnimation();
 	// Move the character
-	move();
+	applyForces();
+	// Slightly adjust our bounding box for the player from just the player position
 	m_sAabb.Center.y += 4;
+	// Update the player's hat
+	//_updateHat();
 	// Update which animation is currently playing
 	_updateAnimation();
+	// Clear away expired forces
+	updateForces();
+}
+
+void PlayerCharacter::applyForces() {
+	GameObject::applyForces();
 	// Update the player's hat
 	_updateHat();
 }
@@ -51,7 +60,8 @@
 		Vector2 projectileVelocity = { xSpeed, ySpeed };
 		// Create the bullet object
 		GameObject* b = _createProjectile();
-		b->setVelocity(projectileVelocity);
+		//b->setVelocity(projectileVelocity);
+		b->addForce(projectileVelocity, 1000.0f);
 		// Update the next time I can shoot
 		shootTime = m_pStepTimer->GetTotalSeconds() + shootCooldown;
 	}
@@ -141,9 +151,8 @@
 	// Up
 	else if (m_pKeyboard->Down(controlMap[playerID + "_UP"]))
 		setVelocity(maxSpeed, 90);
-	// No movement
 	else
-		setVelocity(0, angle);
+		speed = 0;
 }
 
 void PlayerCharacter::_handleDirectionKeys() {
@@ -200,7 +209,7 @@
 		// Hat bounces a little with player movement
 		hat->m_vPos.y += 9 * (m_nCurrentFrame % 2);
 	}
-	if (abs(velocity.x) > 0.01f) {
+	if (abs(getNetForce().x) > 0.01f) {
 		// Hat tilts back a bit against the "wind" lol
 		hat->m_fRoll = .15f;
 	}
Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(revision 77)
+++ Source/Spire.h	(revision 78)
@@ -3,17 +3,19 @@
 #include "HUDObject.h"
 
 class Spire :
-    public GameObject
+	public GameObject
 {
 public:
-    int hp;
-    Spire(Scene* scene, float x, float y, float z = 1.15);
-    void update() override;
-    void onAnimationComplete(AnimationDesc& anim) override;
+	int hp;
+	Spire(Scene* scene, float x, float y, float z = 1.15);
+	void update() override;
+	void onAnimationComplete(AnimationDesc& anim) override;
+	// The area in which enemies can attack
+	BoundingBox attackZone;
 protected:
-    int maxHP = 1000;
-    AnimationDesc explodeAnimation;
-    GameObject* peak;
-    HUDObject* healthBar;
+	int maxHP = 1000;
+	AnimationDesc explodeAnimation;
+	GameObject* peak;
+	HUDObject* healthBar;
 };
 
Index: Source/TitleScreenScene.cpp
===================================================================
--- Source/TitleScreenScene.cpp	(revision 77)
+++ Source/TitleScreenScene.cpp	(revision 78)
@@ -1,4 +1,4 @@
-#include "TitleScreenScene.h"
+#include "TitleScreenScene.h"
 #include "HatSelectScene.h"
 #include "OptionsScene.h"
 #include "Game.h"
@@ -22,6 +22,12 @@
 	float x = m_pRenderer->getCenter().x;
 	float y = m_pRenderer->getCenter().y;
 	addObject(new GameObject(this, TITLE_SCREEN, x, y, 0));
+	// Create a background for the text prompt
+	HUDObject* box = addObject(new HUDObject(this, BLACK_SQUARE, -0.49f, -0.92f));
+	box->m_fAlpha = 0.3f;
+	box->relativeXScale = 220.0f;
+	box->relativeYScale = 25.0f;
+	box->adjust();
 }
 
 void TitleScreenScene::update() {
@@ -45,6 +51,13 @@
 			m_pRenderer->DrawScreenText(menu[i].c_str(), Vector2(780.0f, 180.0f + (40.0f * i)), Colors::Orange);
 		}
 	}
+	m_pRenderer->setFont("prompt_font");
+	string controllerPrompt = "h USE i m TO NAVIGATE MENU.  PRESS a TO CONFIRM";
+	string keyboardPrompt = "KEYBOARD USE " + keyboardKeys[controlMap["PLAYER1_UP"]]
+		+ "/" + keyboardKeys[controlMap["PLAYER1_DOWN"]] + " TO NAVIGATE MENU.  PRESS "
+		+ keyboardKeys[controlMap["PLAYER1_ACCEPT"]] + " TO CONFIRM";
+	m_pRenderer->DrawScreenText(controllerPrompt.c_str(), { 20,660 }, Colors::LightGreen);
+	m_pRenderer->DrawScreenText(keyboardPrompt.c_str(), { 20,690 }, Colors::LightCyan);
 }
 
 void TitleScreenScene::_handleKeyboard() {
Index: Source/WaveSpawner.cpp
===================================================================
--- Source/WaveSpawner.cpp	(revision 77)
+++ Source/WaveSpawner.cpp	(revision 78)
@@ -22,7 +22,7 @@
 
 				// Get the spawn locations from the level
 				vector<PathPoint> spawnOptions = level->getSpawnPoints();
-				int numSpawnPoints = spawnOptions.size();
+				int numSpawnPoints = (int)spawnOptions.size();
 				// Choose a random spawn location
 				PathPoint spawnPoint = spawnOptions[m_pRandom->randn(0, numSpawnPoints - 1)];
 
Index: Source/OptionsScene.cpp
===================================================================
--- Source/OptionsScene.cpp	(revision 77)
+++ Source/OptionsScene.cpp	(revision 78)
@@ -38,6 +38,7 @@
 
 void OptionsScene::render() {
 	Scene::render();
+	m_pRenderer->setFont("font");
 	render_controls();
 	string prompts = "Use "
 		+ keyboardKeys[controlMap["PLAYER1_UP"]] + " and "
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 77)
+++ Source/Source.vcxproj	(revision 78)
@@ -182,6 +182,7 @@
     <ClCompile Include="Main.cpp" />
     <ClCompile Include="OptionsScene.cpp" />
     <ClCompile Include="PlayerCharacter.cpp" />
+    <ClCompile Include="PseudoForce.cpp" />
     <ClCompile Include="RangeTower.cpp" />
     <ClCompile Include="Renderer.cpp" />
     <ClCompile Include="Scene.cpp" />
@@ -217,6 +218,7 @@
     <ClInclude Include="OptionsScene.h" />
     <ClInclude Include="PlayerCharacter.h" />
     <ClInclude Include="Projectile.h" />
+    <ClInclude Include="PseudoForce.h" />
     <ClInclude Include="RangeTower.h" />
     <ClInclude Include="Renderer.h" />
     <ClInclude Include="Scene.h" />
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 77)
+++ Source/PlayerCharacter.h	(revision 78)
@@ -9,6 +9,7 @@
 public:
 	PlayerCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15, string playerID = "PLAYER1");
 	void update() override; // Character's update loop, runs every frame
+	void applyForces() override;
 	void shoot(float angle_in_degrees);
 	float getMaxSpeed() { return maxSpeed; }
 	void setPlayerID(string id);
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 77)
+++ Source/Source.vcxproj.filters	(revision 78)
@@ -79,6 +79,7 @@
     <ClCompile Include="DesolateDesertLevel.cpp">
       <Filter>Scenes\Levels</Filter>
     </ClCompile>
+    <ClCompile Include="PseudoForce.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -168,6 +169,7 @@
     <ClInclude Include="DesolateDesertLevel.h">
       <Filter>Scenes\Levels</Filter>
     </ClInclude>
+    <ClInclude Include="PseudoForce.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 77)
+++ Source/Spire.cpp	(revision 78)
@@ -5,7 +5,9 @@
 Spire::Spire(Scene* scene, float x, float y, float z) :
 	GameObject(scene, SPIRE_BASE, x, y, z) {
 	hp = maxHP;
-	m_sAabb = BoundingBox({ x, y + 6, z }, { 64, 26, 32 });
+	XMFLOAT3 clsnCenter = { x - 8, y + 6, z };
+	m_sAabb = BoundingBox(clsnCenter, { 48, 26, 32 });
+	attackZone = BoundingBox(clsnCenter, m_sAabb.Extents * 2.0f);
 	peak = scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z - .1f));
 	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15f);
 	healthBar = scene->addObject(new HUDObject(scene, GREENLINE_SPRITE, 0, 0.9f, 0));

------------------------------------------------------------------------
r79 | jdg0393 | 2020-11-29 18:10:53 -0600 (Sun, 29 Nov 2020) | 1 line

Corner spawn stacking bug fix.

Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 78)
+++ Source/HatSelectScene.cpp	(revision 79)
@@ -13,10 +13,6 @@
 	};
 	selection.first = 0;
 	selection.second = 0;
-	controllerPrompt = addObject(new GameObject(this, BUTTON_GREEN));
-	controllerPrompt->m_fAlpha = 0.0f;
-	controllerPrompt->m_fXScale = 0.2f;
-	controllerPrompt->m_fYScale = 0.2f;
 }
 
 HatSelectScene::~HatSelectScene() {}
@@ -49,15 +45,6 @@
 		(selection.first + 1) % (int)hatsMenu.size();
 	// Control the selection with controller
 	if (controllerOwner == 1) {
-		if (!ready.first) {
-			controllerPrompt->m_fAlpha = 1.0f;
-			if (coOp) {
-				controllerPrompt->m_vPos = { 246.0f, 174.0f, 0.0f };
-			}
-			else {
-				controllerPrompt->m_vPos = { 545.0f, 174.0f, 0.0f };
-			}
-		}
 		if (gamepad.isPressed("LSTICK_LEFT")) selection.first--;
 		else if (gamepad.isPressed("LSTICK_RIGHT")) selection.first =
 			(selection.first + 1) % (int)hatsMenu.size();
@@ -74,10 +61,6 @@
 			(selection.second + 1) % (int)hatsMenu.size();
 		// Control the selection with controller
 		if (controllerOwner == 2) {
-			if (!ready.second) {
-				controllerPrompt->m_fAlpha = 1.0f;
-				controllerPrompt->m_vPos = { 869.5f, 174.0f, 0.0f };
-			}
 			if (gamepad.isPressed("LSTICK_LEFT")) selection.second--;
 			else if (gamepad.isPressed("LSTICK_RIGHT")) selection.second =
 				(selection.second + 1) % (int)hatsMenu.size();
@@ -96,7 +79,6 @@
 	if (gamepad.isPressed("BUTTON_A")) {
 		if (controllerOwner == 1) ready.first = true;
 		else if (controllerOwner == 2) ready.second = true;
-		controllerPrompt->m_fAlpha = 0.0f;
 	}
 
 	// Proceed when both players have readied.
@@ -113,22 +95,23 @@
 	float x = hats.first->m_vPos.x - (7.0f * hatsMenu[selection.first].first.size());
 	m_pRenderer->DrawScreenText(hatsMenu[selection.first].first.c_str(), Vector2(x, 420), Colors::Black);
 	// Display the player's ready status
+	m_pRenderer->setFont("prompt_font");
 	if (ready.first) {
 		if (coOp)
-			m_pRenderer->DrawScreenText("Ready!", Vector2(290, 530), Colors::Black);
+			m_pRenderer->DrawScreenText("READY!", Vector2(290, 530), Colors::Black);
 		else
-			m_pRenderer->DrawScreenText("Ready!", Vector2(540, 530), Colors::Black);
+			m_pRenderer->DrawScreenText("READY!", Vector2(540, 530), Colors::Black);
 	}
 	else
 	{
-		string prompt = "Press ";
+		string prompt = "PRESS ";
 		if (controllerOwner == 1) {
-			prompt += " A ";
+			prompt += "a";
 		}
 		else {
 			prompt += keyboardKeys[controlMap["PLAYER1_ACCEPT"]];
 		}
-		prompt += " to confirm your choice!";
+		prompt += " TO CONFIRM YOUR CHOICE!";
 		if (coOp)
 			m_pRenderer->DrawScreenText(prompt.c_str(), Vector2(150, 530), Colors::Black);
 		else
@@ -135,26 +118,29 @@
 			m_pRenderer->DrawScreenText(prompt.c_str(), Vector2(450, 530), Colors::Black);
 	}
 	if (coOp) {
+		m_pRenderer->setFont("font");
 		// Position hat name text of Player 2
 		x = hats.second->m_vPos.x - (7.0f * hatsMenu[selection.second].first.size());
 		m_pRenderer->DrawScreenText(hatsMenu[selection.second].first.c_str(), Vector2(x, 420), Colors::Black);
+		m_pRenderer->setFont("prompt_font");
 		// Display the player's ready status
 		if (ready.second) {
-			m_pRenderer->DrawScreenText("Ready!", Vector2(915, 530), Colors::Black);
+			m_pRenderer->DrawScreenText("READY!", Vector2(915, 530), Colors::Black);
 		}
 		else
 		{
-			string prompt = "Press ";
+			string prompt = "PRESS ";
 			if (controllerOwner == 2) {
-				prompt += " A ";
+				prompt += "a";
 			}
 			else {
 				prompt += keyboardKeys[controlMap["PLAYER2_ACCEPT"]];
 			}
-			prompt += " to confirm your choice!";
+			prompt += " TO CONFIRM YOUR CHOICE!";
 			m_pRenderer->DrawScreenText(prompt.c_str(), Vector2(775, 530), Colors::Black);
 		}
 	}
+	m_pRenderer->setFont("font");
 }
 
 void HatSelectScene::startLevel() {
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 78)
+++ Source/GameObject.cpp	(revision 79)
@@ -5,6 +5,7 @@
 GameObject::GameObject(Scene* scene, eSpriteType spriteKey, float x, float y, float z) {
 	this->scene = scene;
 	this->m_vPos = Vector3(x, y, z);
+	creationTime = m_pStepTimer->GetTotalSeconds();
 	m_nSpriteIndex = spriteKey;
 	activeAnimation = AnimationDesc(spriteKey, 0, 0, 0.5);
 	m_pParticleEngine = new CParticleEngine3D(); // each object has its own particle engine
@@ -21,6 +22,10 @@
 	updateForces();
 }
 
+float GameObject::timeExisted() {
+	return m_pStepTimer->GetTotalSeconds() - creationTime;
+}
+
 void GameObject::unmove() {
 	// Store the current position
 	Vector2 nowPos = { m_vPos.x, m_vPos.y };
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 78)
+++ Source/BaseLevelScene.cpp	(revision 79)
@@ -396,22 +396,28 @@
 // Handler for collisions, check for specific object types and handle collisions for them
 void BaseLevelScene::NarrowPhaseClsn(GameObject* obj1, GameObject* obj2) {
 	// Stop the player (or enemies) from moving into solid objects
-	if ((obj1->is("player") || obj1->is("baddie")) && obj2->is("unpassable")) {
+	if (obj1->is("player") && obj2->is("unpassable")) {
 		obj1->pushBack();
 	}
+	// Enemies running into the spire
+	if (obj1->is("baddie") && obj2->is("spire")) {
+		obj1->pushBack();
+	}
 	// Enemies running into each other
 	if (obj1->is("baddie") && obj2->is("baddie")) {
-		// Get the vector between the two objects positions
-		Vector2 between = obj2->getPosition() - obj1->getPosition();
-		// Get just the direction between the two objects
-		between.Normalize();
-		// Change the direction of the bad guy a little bit
-		if (between.x > between.y) between.x *= 10.0f;
-		else between.y *= 10.0f;
-		// Force the second object to go around
-		obj2->addForce(between, 0.05f);
-		// Prevent object overlap
-		obj2->pushBack();
+		if (obj2->timeExisted() > 1.5f) {
+			// Get the vector between the two objects positions
+			Vector2 between = obj2->getPosition() - obj1->getPosition();
+			// Get just the direction between the two objects
+			between.Normalize();
+			// Change the direction of the bad guy a little bit
+			if (between.x > between.y) between.x *= 10.0f;
+			else between.y *= 10.0f;
+			// Force the second object to go around
+			obj2->addForce(between, 0.05f);
+			// Prevent object overlap
+			obj2->pushBack();
+		}
 	}
 	// Collecting of coins
 	if (obj1->is("player") && obj2->is("coins")) {
Index: Source/HatSelectScene.h
===================================================================
--- Source/HatSelectScene.h	(revision 78)
+++ Source/HatSelectScene.h	(revision 79)
@@ -21,7 +21,6 @@
 	pair<HUDObject*, HUDObject*> hats;
 	pair<int, int> selection;
 	pair<bool, bool> ready;
-	GameObject* controllerPrompt;
 	bool coOp;
 	bool controllerReady = true;
 };
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 78)
+++ Source/GameObject.h	(revision 79)
@@ -21,6 +21,9 @@
 	virtual ~GameObject();
 	virtual void update(); // Method runs every tick/update
 
+	// Returns how long the object has existed
+	float timeExisted();
+
 	// Positioning related methods
 	void setRoll(float angle);
 	float getRoll();
@@ -60,6 +63,8 @@
 protected:
 	// Scene which manages this object
 	Scene* scene;
+	// Stores when the object was first created
+	float creationTime = 0.0f;
 	// Stores the position from the previous frame
 	Vector2 oldPosition;
 	// Whether the object should be deleted next frame
@@ -68,7 +73,7 @@
 	unordered_set<string> tags;
 	// Animation related variables
 	AnimationDesc activeAnimation;
-	float animationTimer = 0;
+	float animationTimer = 0.0f;
 	bool isAnimating = false;
 	bool loopAnimation = false;
 	CParticleEngine3D* m_pParticleEngine = nullptr; ///< Pointer to a particle engine.

------------------------------------------------------------------------
r80 | jdg0393 | 2020-11-29 19:56:52 -0600 (Sun, 29 Nov 2020) | 1 line

Enemies knock around player if it annoys them. (Is in a radius of them)

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 79)
+++ Source/BaseLevelScene.cpp	(revision 80)
@@ -398,6 +398,7 @@
 	// Stop the player (or enemies) from moving into solid objects
 	if (obj1->is("player") && obj2->is("unpassable")) {
 		obj1->pushBack();
+		if (obj2->is("baddie")) obj2->pushBack();
 	}
 	// Enemies running into the spire
 	if (obj1->is("baddie") && obj2->is("spire")) {
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 79)
+++ Source/Renderer.cpp	(revision 80)
@@ -54,7 +54,6 @@
 	Load(MENU_BOX, "menu_box");
 	Load(BLACK_SQUARE, "black_square");
 	Load(GREENLINE_SPRITE, "greenline");
-	Load(BUTTON_GREEN, "button_green");
 	// Characters
 	Load(HUMAN_IDLE, "human_idle");
 	Load(HUMAN_WALK, "human_walk");
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 79)
+++ Source/BadCharacter.h	(revision 80)
@@ -1,6 +1,7 @@
 #pragma once
 #include <map>
 #include "Character.h"
+#include "PlayerCharacter.h"
 
 // Forward declarations
 class BaseLevelScene;
@@ -11,21 +12,41 @@
 public:
 	bool isStopped = false;
 	bool isAttacking = false;
-	BadCharacter(Scene* scene, float x = 0, float y = 0, float z = 1.15);
+	BadCharacter(Scene* scene, float x = 0.0f, float y = 0.0f, float z = 1.15);
 	virtual ~BadCharacter() override;
 	virtual void update() override;
-	void setDestination(float x, float y);
-	void setDestinationID(string id);
+	void onAnimationComplete(AnimationDesc& anim) override;
+	bool readyToAttack();
+	void setDestinationCoordinates(float x, float y);
+	void setDestinationByID(string id);
 protected:
+	// Level that the baddie belongs to
 	BaseLevelScene* level = nullptr;
-	float attackCooldown = .6f;
-	float nextAttackTime = 0;
+	// Time between attacks
+	float attackCooldown = 0.6f;
+	// Next time that the enemy can attack
+	float nextAttackTime = 0.0f;
+	// Copy of the level's list of path poitns
 	map<string, PathPoint> paths;
-	Vector2 dest = { 0,0 };
-	string destID = "";
-	float dist = 100000.0f; // Distance from the destination
-	void _updateAnimation();
-	void _updateDestination();
-	void _updateVelocity();
+	// Coordinates of the destination
+	Vector2 destinationCoordinates = { 0,0 };
+	// ID of the destination in the level's list of pathpoints
+	string destinationID = "";
+	// Distance from the destination
+	float distanceToDestination = 100000.0f;
+	// Starts running the appropriate animation if it's not already
+	void update_PlayAnimations();
+	// Determines when the baddie reaches destination and what destination to switch to 
+	void update_DestinationLogic();
+	// Moves the baddie towards a given set of coordinates
+	void update_Move(Vector2 towards);
+	// Moves the enemy towards their destination
+	void update_StateMarch();
+	// Handles enemy behavior at game over
+	void update_StateDying();
+	// Handles the enemy attacking the spire
+	void update_StateAttackSpire();
+	// Combat behavior for when players are nearby
+	void update_StateCombat(PlayerCharacter* player);
 };
 
Index: Source/GameObject.h
===================================================================
--- Source/GameObject.h	(revision 79)
+++ Source/GameObject.h	(revision 80)
@@ -21,9 +21,6 @@
 	virtual ~GameObject();
 	virtual void update(); // Method runs every tick/update
 
-	// Returns how long the object has existed
-	float timeExisted();
-
 	// Positioning related methods
 	void setRoll(float angle);
 	float getRoll();
@@ -49,6 +46,8 @@
 	bool getWillCull(); //true if dead, false otherwise
 	virtual void kill(); // set isdead flag to true;
 	void explode(); // particle effect for fireball explosion
+	bool objInRange(GameObject* other, float range); // Object is within a defined range of this
+	float timeExisted(); // Returns how long the object has existed
 
 	// Physics
 	vector<PseudoForce> forces;
Index: Source/GameObject.cpp
===================================================================
--- Source/GameObject.cpp	(revision 79)
+++ Source/GameObject.cpp	(revision 80)
@@ -26,6 +26,11 @@
 	return m_pStepTimer->GetTotalSeconds() - creationTime;
 }
 
+// Object is within a defined range of this
+bool GameObject::objInRange(GameObject* other, float range) {
+	return inRadius(other->m_vPos, range);
+}
+
 void GameObject::unmove() {
 	// Store the current position
 	Vector2 nowPos = { m_vPos.x, m_vPos.y };
@@ -39,12 +44,16 @@
 	m_sAabb.Center.y = m_vPos.y;
 }
 
-bool GameObject::inRadius(Vector3 pos, float dist) {		//returns true if object is within dist of pos
-	if (abs(sqrt(pow(pos.x, 2) + pow(pos.y, 2)) - sqrt(pow(this->getPosition().x, 2) + pow(this->getPosition().y, 2))) <= dist)
-		return true;
-	else
-		return false;
+bool GameObject::inRadius(Vector3 pos, float radius) {		//returns true if object is within dist of pos
+	float dx = m_vPos.x - pos.x;
+	float dy = m_vPos.y - pos.y;
+	float dx2 = dx * dx;
+	float dy2 = dy * dy;
+	float distance = sqrt(dx2 + dy2);
+	distance = abs(distance);
+	return distance <= radius;
 }
+
 void GameObject::explode() {
 	//TODO: smoke effect is not appearing for some reason
 	const Vector3 pos = this->getPosition();
Index: Source/WaveSpawner.cpp
===================================================================
--- Source/WaveSpawner.cpp	(revision 79)
+++ Source/WaveSpawner.cpp	(revision 80)
@@ -37,7 +37,7 @@
 				// Move the enemy to a spawn point
 				baddie->setPosition({ spawnPoint.x + xoffset, spawnPoint.y + yoffset, 1.15f });
 				// Set the enemie's destination to be their starting point initially
-				baddie->setDestinationID(spawnPoint.next);
+				baddie->setDestinationByID(spawnPoint.next);
 
 				// Increase the counter of number of enemies spawned
 				spawnState.numberSpawned++;
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 79)
+++ Source/BadCharacter.cpp	(revision 80)
@@ -18,64 +18,53 @@
 }
 BadCharacter::~BadCharacter() {}
 
+// Functions labeled "update_State" are mutually exclusive states of behavior
+// Whereas other "update_" functions are simply sub-behaviors meant to occur on
+// all update states that I thought would best be separated into contained functions.
 void BadCharacter::update() {
-	// Animate the character
-	if (!dying)
-		stepAnimation();
-	// Set the bad guy's destination
-	_updateDestination();
-	// Check if the game is over or the monster is dead/dying
-	if (level->getGameOver() || hp < 0) {
-		isStopped = true;
-		isAttacking = false;
-		dying = true;
-		if (is("unpassable")) tags.erase(tags.find("unpassable"));
-		if (m_fAlpha > 0) {
-			// Fade the bad guy out on game over
-			m_fAlpha -= .01f;
-		}
-		else {
-			// Get some money
-			scene->addObject(new Coin(scene, m_pRandom->randn(1, 10), m_vPos.x, m_vPos.y));
-			// Destroy this creature once it's faded out
-			kill();
-		}
+	// If the enemy's health is zero, it is dying
+	if (hp < 0) {
+		update_StateDying();
 	}
-	// If targeting the spire and within range, attack it!
-	else if (destID == "end" && m_sAabb.Intersects(level->getSpire()->attackZone)) {
-		Vector2 spire = level->getSpire()->getPosition();
-		isStopped = true;
-		isAttacking = true;
-		if (m_pStepTimer->GetTotalSeconds() > nextAttackTime) {
-			level->getSpire()->hp -= 20;
-			nextAttackTime = m_pStepTimer->GetTotalSeconds() + attackCooldown;
-		}
+	// If the spire is within range, attack the spire
+	// (The spire has a designated "attack zone" where enemies can and do attack)
+	else if (m_sAabb.Intersects(level->getSpire()->attackZone)) {
+		update_StateAttackSpire();
 	}
-	else {
-		isStopped = false;
-		isAttacking = false;
+	// If a player is within range, use combat behavior (we have to check for both players)
+	else if (objInRange(level->getPlayers().first, 128.0f)) {
+		update_StateCombat(level->getPlayers().first);
 	}
-	// Move the bad guy
-	if (!dying)
-		_updateVelocity();
-	//if (!isStopped) move();
+	else if (level->getPlayers().second != nullptr && objInRange(level->getPlayers().second, 128.0f)) {
+		update_StateCombat(level->getPlayers().second);
+	}
+	// If none of the other states are active, and the enemy isn't dying, they
+	// should march towards the destination
+	else if (!dying) {
+		update_StateMarch();
+	}
+	// Set the bad guy's destination
+	update_DestinationLogic();
+	// If the bad guy isn't dying, move animate it (dying baddies freeze and fade out)
+	if (!dying) {
+		stepAnimation();
+	}
+	// Do physics stuff
 	applyForces();
 	updateForces();
-	// Updates what animation is playing
-	_updateAnimation();
+	// Starts running the appropriate animation if it's not already
+	update_PlayAnimations();
 }
 
-void BadCharacter::_updateAnimation() {
+// Starts running the appropriate animation if it's not already
+void BadCharacter::update_PlayAnimations() {
 	string key = "";
-
 	// Possible animation prefixes
 	if (isAttacking) key += "ATTACK_";
 	else key += "WALK_";
-
 	// Set the direction of the animation
 	calculateAnimationDirection();
 	key += animationDirection;
-
 	// Check if the animation is already running
 	if (!isPlayingAnimation(animations[key])) {
 		// Start the animation if it isn't already running
@@ -83,34 +72,31 @@
 	}
 }
 
-void BadCharacter::setDestination(float x, float y) {
-	dest = { x, y };
-}
-
-void BadCharacter::setDestinationID(string id) {
-	destID = id;
-	dest = { paths[id].x, paths[id].y };
-}
-
-void BadCharacter::_updateDestination() {
+void BadCharacter::update_DestinationLogic() {
 	// The the bad guy is within range of his destination
-	if (destID == "end") {
-		GameObject* spire = ((BaseLevelScene*)scene)->getSpire();
-		dest = { spire->getPosition().x, spire->getPosition().y - 22 };
+	if (destinationID == "end") {
+		GameObject* spire = level->getSpire();
+		destinationCoordinates = { spire->getPosition().x, spire->getPosition().y };
 	}
-	else if (dist < 3 && paths[destID].next != "null") {
-		destID = paths[destID].next;
-		dest = { paths[destID].x, paths[destID].y };
+	// If the bad guy has arrived at their current destination, and there is a next
+	// destination, update to the next destination.
+	else if (distanceToDestination < 3 && paths[destinationID].next != "null") {
+		destinationID = paths[destinationID].next;
+		destinationCoordinates = { paths[destinationID].x, paths[destinationID].y };
 	}
-	float dx = m_vPos.x - dest.x;
-	float dy = m_vPos.y - dest.y;
+	// Calculate distance remaining to the destination
+	float dx = m_vPos.x - destinationCoordinates.x;
+	float dy = m_vPos.y - destinationCoordinates.y;
 	float dx2 = dx * dx;
 	float dy2 = dy * dy;
-	dist = sqrt(dx2 + dy2);
+	distanceToDestination = sqrt(dx2 + dy2);
 }
 
-void BadCharacter::_updateVelocity() {
-	Vector2 travelVector = m_vPos - dest;
+
+// Moves the baddie towards a given set of coordinates
+void BadCharacter::update_Move(Vector2 towards) {
+	// Get the vector direction to travel along
+	Vector2 travelVector = m_vPos - towards;
 	// Calculate angle to destination in radians
 	float angle_in_radians = atan2f(travelVector.y, travelVector.x) + MY_PI;
 	// Normalize to [0,2pi)
@@ -119,5 +105,99 @@
 	angle = angle_in_radians * (180 / MY_PI);
 	// Calculate the velocity
 	Vector2 velocity = { 40 * cosf(angle_in_radians), 40 * sinf(angle_in_radians) };
+	// Finally, move the baddie. But only if they aren't stopped.
 	if (!isStopped)addForce(velocity, PseudoForce::Instant);
+}
+
+void BadCharacter::update_StateMarch() {
+	// Set baddie flags
+	isStopped = false;
+	// Move the baddie towards the destination
+	update_Move(destinationCoordinates);
+}
+
+void BadCharacter::update_StateDying() {
+	// Flag the enemy as dying
+	dying = true;
+	// Stop the dying enemy from moving or attacking
+	isStopped = true;
+	isAttacking = false;
+	// Enemy should be passable when it's in the dying state
+	if (is("unpassable")) tags.erase(tags.find("unpassable"));
+	// When the enemy is dying, it should fade away
+	if (m_fAlpha > 0) {
+		m_fAlpha -= .01f;
+	}
+	else {
+		// Unless the game is over, the enemy should drop money on death
+		if (!level->getGameOver())
+			scene->addObject(new Coin(scene, m_pRandom->randn(1, 10), m_vPos.x, m_vPos.y));
+		// Destroy this creature once it's faded out
+		kill();
+	}
+}
+
+void BadCharacter::update_StateAttackSpire() {
+	Spire* spire = level->getSpire();
+	// Stop the enemy from moving
+	isStopped = true;
+	// Flag the enemy as attacking
+	isAttacking = true;
+	// If the enemy is ready to attack, have it damage the spire
+	if (readyToAttack()) {
+		// Deal some damage to the spire
+		spire->hp -= 20;
+		// Assign a new time for the next attack
+		nextAttackTime = m_pStepTimer->GetTotalSeconds() + attackCooldown;
+	}
+}
+
+// Combat behavior for when players are nearby
+void BadCharacter::update_StateCombat(PlayerCharacter* player) {
+	// Move the baddie towards the player, if they aren't already too close
+	if (!objInRange(player, 24.0f)) {
+		isStopped = false;
+		update_Move({ player->m_vPos.x, player->m_vPos.y });
+	}
+	else {
+		isStopped = true;
+	}
+	// If the enemy is ready to attack, it should attack the player
+	if (readyToAttack() && objInRange(player, 48.0f)) {
+		// Flag the enemy as attacking
+		isAttacking = true;
+		// Actual handling of attack effects occur on the middle frame of attack animation
+		int middleFrameOffset = (activeAnimation.endFrame - activeAnimation.startFrame) / 2;
+		int middleFrame = activeAnimation.startFrame + middleFrameOffset;
+		if (m_nCurrentFrame == middleFrame) {
+			// Get the vector between the baddie and the player
+			Vector2 force = player->getPosition() - getPosition();
+			force.Normalize();
+			// Scale the knockback force
+			force *= 300.0f;
+			// Some knockback to teach that player a lesson
+			player->addForce(force, 0.5f);
+			// Assign a new time for the next attack
+			nextAttackTime = m_pStepTimer->GetTotalSeconds() + attackCooldown;
+		}
+	}
+}
+
+// Determines if the enemy can attack based or if it's still in cooldown
+bool BadCharacter::readyToAttack() {
+	return m_pStepTimer->GetTotalSeconds() > nextAttackTime;
+}
+
+void BadCharacter::setDestinationCoordinates(float x, float y) {
+	destinationCoordinates = { x, y };
+}
+
+void BadCharacter::setDestinationByID(string id) {
+	destinationID = id;
+	destinationCoordinates = { paths[id].x, paths[id].y };
+}
+
+
+void BadCharacter::onAnimationComplete(AnimationDesc& anim) {
+	if (isAttacking) isAttacking = false;
 }
\ No newline at end of file
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 79)
+++ Source/GameDefines.h	(revision 80)
@@ -36,7 +36,6 @@
 	MENU_BOX,
 	BLACK_SQUARE,
 	GREENLINE_SPRITE,
-	BUTTON_GREEN,
 	// Characters
 	HUMAN_IDLE,
 	HUMAN_WALK,

------------------------------------------------------------------------
r81 | amm0837 | 2020-11-29 20:29:15 -0600 (Sun, 29 Nov 2020) | 1 line

fixed tower image, added level select scene

Index: Source/LevelSelectScene.h
===================================================================
--- Source/LevelSelectScene.h	(nonexistent)
+++ Source/LevelSelectScene.h	(revision 81)
@@ -0,0 +1,29 @@
+#pragma once
+#include <utility>
+#include <string>
+#include <vector>
+#include "Scene.h"
+
+class CGame;
+
+class LevelSelectScene :
+	public Scene
+{
+public:
+	LevelSelectScene(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coOp = false);
+	~LevelSelectScene();
+	void create() override;
+	void update() override;
+	void render() override;
+	void startLevel();
+protected:
+	vector<pair<string, eSpriteType>> LevelMenu;
+	HUDObject* level;
+	pair<int, int> selection;
+	pair<bool, bool> ready;
+	GameObject* controllerPrompt;
+	bool coOp;
+	bool controllerReady = true;
+	eSpriteType p1Hat;
+	eSpriteType p2Hat;
+};
\ No newline at end of file
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 80)
+++ Source/Source.vcxproj	(revision 81)
@@ -178,6 +178,7 @@
     <ClCompile Include="GamepadWrapper.cpp" />
     <ClCompile Include="HatSelectScene.cpp" />
     <ClCompile Include="HUDObject.cpp" />
+    <ClCompile Include="LevelSelectScene.cpp" />
     <ClCompile Include="MageTower.cpp" />
     <ClCompile Include="Main.cpp" />
     <ClCompile Include="OptionsScene.cpp" />
@@ -214,6 +215,7 @@
     <ClInclude Include="GamepadWrapper.h" />
     <ClInclude Include="HatSelectScene.h" />
     <ClInclude Include="HUDObject.h" />
+    <ClInclude Include="LevelSelectScene.h" />
     <ClInclude Include="MageTower.h" />
     <ClInclude Include="OptionsScene.h" />
     <ClInclude Include="PlayerCharacter.h" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 80)
+++ Source/Source.vcxproj.filters	(revision 81)
@@ -80,6 +80,9 @@
       <Filter>Scenes\Levels</Filter>
     </ClCompile>
     <ClCompile Include="PseudoForce.cpp" />
+    <ClCompile Include="LevelSelectScene.cpp">
+      <Filter>Scenes</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -170,6 +173,9 @@
       <Filter>Scenes\Levels</Filter>
     </ClInclude>
     <ClInclude Include="PseudoForce.h" />
+    <ClInclude Include="LevelSelectScene.h">
+      <Filter>Scenes</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 80)
+++ Source/GameDefines.h	(revision 81)
@@ -24,6 +24,8 @@
 	FIREBALL,
 	EXPLOSION,
 	SMOKE,
+	DESERTLEVEL,
+	BASELEVEL,
 	// Tilesets
 	SIMPLE_TILE,
 	DESERT_TILE,
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 80)
+++ Source/BaseLevelScene.cpp	(revision 81)
@@ -243,11 +243,14 @@
 	if (m_pKeyboard->TriggerDown('U')) {
 
 		GameObject* tow = getClosestTower();
+		GameObject* newTow;
 		if (tow != NULL && distToTower() <= 75) {
 			if (tow->is("range")) {
 				if (tow->is("lvl0")) {
 					if (credits >= 10) {
-						addObject(new RangeTower(this, RANGE2, 1, tow->getPosition().x, tow->getPosition().y));
+						newTow = addObject(new RangeTower(this, RANGE2, 1, tow->getPosition().x, tow->getPosition().y));
+						newTow->m_fXScale = 1.7;
+						newTow->m_fYScale = 1.7;
 						tow->kill();
 						credits -= 10;
 					}
@@ -254,7 +257,9 @@
 				}
 				if (tow->is("lvl1")) {
 					if (credits >= 20) {
-						addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
+						newTow = addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
+						newTow->m_fXScale = 1.7;
+						newTow->m_fYScale = 1.7;
 						tow->kill();
 						credits -= 20;
 					}
@@ -263,7 +268,7 @@
 			if (tow->is("mage")) {
 				if (tow->is("lvl0")) {
 					if (credits >= 15) {
-						addObject(new MageTower(this, MAGE2, 1, tow->getPosition().x, tow->getPosition().y));
+						newTow = addObject(new MageTower(this, MAGE2, 1, tow->getPosition().x, tow->getPosition().y));
 						tow->kill();
 						credits -= 15;
 					}
@@ -270,8 +275,10 @@
 				}
 				if (tow->is("lvl1")) {
 					if (credits >= 30) {
-						addObject(new MageTower(this, MAGE3, 2, tow->getPosition().x, tow->getPosition().y));
+						newTow = addObject(new MageTower(this, MAGE3, 2, tow->getPosition().x, tow->getPosition().y));
 						tow->kill();
+						newTow->m_fXScale = 0.7;
+						newTow->m_fYScale = 0.7;
 						credits -= 30;
 					}
 				}
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 80)
+++ Source/Renderer.cpp	(revision 81)
@@ -42,6 +42,8 @@
 	Load(FIREBALL, "fireball");
 	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
+	Load(DESERTLEVEL, "desertLevel");
+	Load(BASELEVEL, "baseLevel");
 	// Tilesets
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(DESERT_TILE, "desert_tile");
Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 80)
+++ Source/HatSelectScene.cpp	(revision 81)
@@ -4,6 +4,7 @@
 #include "GamepadWrapper.h"
 #include "BaseLevelScene.h"
 #include "DesolateDesertLevel.h"
+#include "LevelSelectScene.h"
 
 HatSelectScene::HatSelectScene(CGame* game, bool coOp) : Scene(game) {
 	this->coOp = coOp;
@@ -145,10 +146,13 @@
 
 void HatSelectScene::startLevel() {
 	m_pAudio->stop();
-	game->startScene(new BaseLevelScene(game,
+	game->startScene(new LevelSelectScene(game, 
 		hatsMenu[selection.first].second,
 		hatsMenu[selection.second].second, coOp));
+	//game->startScene(new BaseLevelScene(game,
+		//hatsMenu[selection.first].second,
+		//hatsMenu[selection.second].second, coOp));
 	//game->startScene(new DesolateDesertLevel(game,
-	//	hatsMenu[selection.first].second,
-	//	hatsMenu[selection.second].second, coOp));
+		//hatsMenu[selection.first].second,
+		//hatsMenu[selection.second].second, coOp));
 }
\ No newline at end of file
Index: Source/LevelSelectScene.cpp
===================================================================
--- Source/LevelSelectScene.cpp	(nonexistent)
+++ Source/LevelSelectScene.cpp	(revision 81)
@@ -0,0 +1,74 @@
+#include "Game.h"
+#include "LevelSelectScene.h"
+#include "BaseLevelScene.h"
+#include "DesolateDesertLevel.h"
+
+LevelSelectScene::LevelSelectScene(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coOp) : Scene(game) {
+
+	this->coOp = coOp;
+
+	LevelMenu = {
+		{"Log Town", BASELEVEL},
+		{"Desert Town", DESERTLEVEL}
+	};
+
+	selection.first = 0;
+	selection.second = 0;
+	p1Hat = ply1Hat;
+	p2Hat = ply2Hat;
+}
+
+LevelSelectScene::~LevelSelectScene(){};
+
+void LevelSelectScene::create() {
+	m_pAudio->loop(MENU_SONG);
+	level = addObject(new HUDObject(this, BASELEVEL, -.5f, 0, 0));
+	level->m_fXScale = 0.7;
+	level->m_fYScale = 0.7;
+
+}
+
+void LevelSelectScene::update() {
+	level->m_nSpriteIndex = LevelMenu[selection.first].second;
+
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_LEFT"])) selection.first--;
+	else if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_RIGHT"])) selection.first =
+		(selection.first + 1) % (int)LevelMenu.size();
+
+	// Control the selection with controller
+	if (controllerOwner == 1) {
+		if (gamepad.isPressed("LSTICK_LEFT")) selection.first--;
+		else if (gamepad.isPressed("LSTICK_RIGHT")) selection.first =
+			(selection.first + 1) % (int)LevelMenu.size();
+	}
+
+	// If it's below zero, loop selection around
+	if (selection.first < 0) selection.first = (int)LevelMenu.size() - 1;
+
+	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_ACCEPT"])) {
+		ready.first = true;
+	}
+
+	if (ready.first) startLevel();
+}
+
+void LevelSelectScene::render() {
+	Scene::render();
+
+	m_pRenderer->setFont("title_font");
+	m_pRenderer->DrawScreenText("Level Select", Vector2(330, 10), Colors::Black);
+	m_pRenderer->setFont("font");
+	m_pRenderer->DrawScreenText(LevelMenu[selection.first].first.c_str(), Vector2(300, 650), Colors::Black);
+}
+
+void LevelSelectScene::startLevel() {
+	if (selection.first == 0) {
+		game->startScene(new BaseLevelScene(game,
+			p1Hat, p2Hat, coOp));
+	}
+	else if (selection.first == 1) {
+		game->startScene(new DesolateDesertLevel(game,
+			p1Hat, p2Hat, coOp));
+	}
+}
+

------------------------------------------------------------------------
r82 | amm0837 | 2020-11-29 20:34:54 -0600 (Sun, 29 Nov 2020) | 1 line

fixed little music thing

Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 81)
+++ Source/HatSelectScene.cpp	(revision 82)
@@ -145,7 +145,6 @@
 }
 
 void HatSelectScene::startLevel() {
-	m_pAudio->stop();
 	game->startScene(new LevelSelectScene(game, 
 		hatsMenu[selection.first].second,
 		hatsMenu[selection.second].second, coOp));
Index: Source/LevelSelectScene.cpp
===================================================================
--- Source/LevelSelectScene.cpp	(revision 81)
+++ Source/LevelSelectScene.cpp	(revision 82)
@@ -21,7 +21,6 @@
 LevelSelectScene::~LevelSelectScene(){};
 
 void LevelSelectScene::create() {
-	m_pAudio->loop(MENU_SONG);
 	level = addObject(new HUDObject(this, BASELEVEL, -.5f, 0, 0));
 	level->m_fXScale = 0.7;
 	level->m_fYScale = 0.7;
@@ -62,6 +61,7 @@
 }
 
 void LevelSelectScene::startLevel() {
+	m_pAudio->stop();
 	if (selection.first == 0) {
 		game->startScene(new BaseLevelScene(game,
 			p1Hat, p2Hat, coOp));

------------------------------------------------------------------------
r83 | jdg0393 | 2020-11-29 21:03:17 -0600 (Sun, 29 Nov 2020) | 1 line

Players die after 5 hits, though they currently lack a health bar.

Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 82)
+++ Source/PlayerCharacter.h	(revision 83)
@@ -16,6 +16,11 @@
 	// Keyboard handler just for the player, for use in the scenes keyboard handler
 	virtual void handleKeyboard();
 	virtual void handleController();
+	// Health and death
+	int maxHP = 100;
+	int hp = 100;
+	bool isDying = false;
+	bool isDead = false;
 protected:
 	string playerID;
 	float shootCooldown;
@@ -22,7 +27,11 @@
 	float shootTime;
 	float projectileSpeed;
 	float maxSpeed;
+	// The time the player died, stored for respawn purposes
+	float timeDied = -1.0f;
 	GameObject* hat = nullptr;
+	// A flag used for one small part of the death animation
+	bool _hatFalling = false;
 	virtual GameObject* _createProjectile();
 	void _updateAnimation();
 	void _updateHat();
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 82)
+++ Source/BadCharacter.cpp	(revision 83)
@@ -23,7 +23,7 @@
 // all update states that I thought would best be separated into contained functions.
 void BadCharacter::update() {
 	// If the enemy's health is zero, it is dying
-	if (hp < 0) {
+	if (hp < 0 || level->getGameOver()) {
 		update_StateDying();
 	}
 	// If the spire is within range, attack the spire
@@ -32,10 +32,17 @@
 		update_StateAttackSpire();
 	}
 	// If a player is within range, use combat behavior (we have to check for both players)
-	else if (objInRange(level->getPlayers().first, 128.0f)) {
+	// Check for either player if that player is alive as well as in range
+	else if (!level->getPlayers().first->isDead && !level->getPlayers().first->isDying
+		&& objInRange(level->getPlayers().first, 128.0f)) {
+		// Enter the combat state against player 1
 		update_StateCombat(level->getPlayers().first);
 	}
-	else if (level->getPlayers().second != nullptr && objInRange(level->getPlayers().second, 128.0f)) {
+	// With player 2, we also have to see if they exist (aren't nullptr)
+	else if (level->getPlayers().second != nullptr
+		&& !level->getPlayers().second->isDead && !level->getPlayers().second->isDying
+		&& objInRange(level->getPlayers().second, 128.0f)) {
+		// Enter the combat state against player 2
 		update_StateCombat(level->getPlayers().second);
 	}
 	// If none of the other states are active, and the enemy isn't dying, they
@@ -170,6 +177,8 @@
 		int middleFrameOffset = (activeAnimation.endFrame - activeAnimation.startFrame) / 2;
 		int middleFrame = activeAnimation.startFrame + middleFrameOffset;
 		if (m_nCurrentFrame == middleFrame) {
+			// Lower the player's health
+			player->hp -= 20;
 			// Get the vector between the baddie and the player
 			Vector2 force = player->getPosition() - getPosition();
 			force.Normalize();
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 82)
+++ Source/PlayerCharacter.cpp	(revision 83)
@@ -3,6 +3,7 @@
 #include "Bullet.h"
 #include "Scene.h"
 #include "Controller.h"
+#include "BaseLevelScene.h"
 
 PlayerCharacter::PlayerCharacter(Scene* scene, float x, float y, float z, string playerID) :
 	Character(scene, HUMAN_IDLE, x, y, z)
@@ -27,19 +28,78 @@
 }
 
 void PlayerCharacter::update() {
-	//printf("PlayerCharacter::update()");
-	// Animate the character
-	stepAnimation();
-	// Move the character
-	applyForces();
-	// Slightly adjust our bounding box for the player from just the player position
-	m_sAabb.Center.y += 4;
-	// Update the player's hat
-	//_updateHat();
-	// Update which animation is currently playing
-	_updateAnimation();
-	// Clear away expired forces
-	updateForces();
+	// Normal behavior for the player character
+	if (!isDying && !isDead) {
+		// Animate the character
+		stepAnimation();
+		// Move the character
+		applyForces();
+		// Slightly adjust our bounding box for the player from just the player position
+		m_sAabb.Center.y += 4;
+		// Update which animation is currently playing
+		_updateAnimation();
+		// Clear away expired forces
+		updateForces();
+	}
+	// If the player is dying
+	else if (isDying) {
+		// Fade the character
+		if (m_fAlpha > 0.05f) {
+			m_fAlpha -= 0.05f;
+		}
+		// Once the character is done fading, drop the hat (and fade)
+		else {
+			m_fAlpha = 0.0f;
+			if (!_hatFalling) {
+				addForce({ 0.0f, -16.0f }, 2.0f);
+				_hatFalling = true;
+			}
+			if (hat->m_fAlpha > 0.05f) {
+				hat->m_fAlpha -= 0.01f;
+			}
+		}
+		// Move the character
+		applyForces();
+		// Clear away expired forces
+		updateForces();
+	}
+	else if (isDead) {
+		// Set the time died (negative means it has not been set yet)
+		if (timeDied < 0.0f) {
+			timeDied = m_pStepTimer->GetTotalSeconds();
+		}
+		// The hat is no longer falling
+		_hatFalling = false;
+		// Make sure player and hat are invisible
+		m_fAlpha = 0.05f;
+		hat->m_fAlpha = 0.05f;
+		// Player should move to spawn point
+		m_vPos.x = ((BaseLevelScene*)scene)->getPaths()["plySpawn"].x;
+		m_vPos.y = ((BaseLevelScene*)scene)->getPaths()["plySpawn"].y;
+		m_sAabb.Center.x = m_vPos.x;
+		m_sAabb.Center.y = m_vPos.y + 4;
+		// Move the hat to the player
+		_updateHat();
+		// Respawn after 20 seconds
+		if (m_pStepTimer->GetTotalSeconds() > timeDied + 20.0f) {
+			hp = maxHP;
+			isDead = false;
+			m_fAlpha = 1.0f;
+			hat->m_fAlpha = 1.0f;
+			timeDied = -1.0f;
+		}
+	}
+	// Update whether we are dying
+	if (hp <= 0) {
+		if (hat->m_fAlpha > 0.1f) {
+			isDying = true;
+			isDead = false;
+		}
+		else {
+			isDying = false;
+			isDead = true;
+		}
+	}
 }
 
 void PlayerCharacter::applyForces() {
@@ -70,36 +130,40 @@
 void PlayerCharacter::setPlayerID(string id) { playerID = id; }
 
 void PlayerCharacter::handleKeyboard() {
-	_handleMovementKeys();
-	_handleDirectionKeys();
+	if (!isDying && !isDead) {
+		_handleMovementKeys();
+		_handleDirectionKeys();
+	}
 }
 
 void PlayerCharacter::handleController() {
-	// Get thumb vectors
-	Vector2 leftThumb = m_pController->GetLThumb();
-	Vector2 rightThumb = m_pController->GetRThumb();
-	// Check if sticks are significantly pressed
-	bool leftThumbUsed = abs(leftThumb.x) + abs(leftThumb.y) > 0.05f;
-	bool rightThumbUsed = abs(rightThumb.x) + abs(rightThumb.y) > 0.05f;
-	// Left stick handler
-	if (leftThumbUsed) {
-		// Calculate angles
-		float leftThumbAngle = atan2f(leftThumb.y, leftThumb.x);
-		float leftThumbAngleDegrees = leftThumbAngle * (180.0f / MY_PI);
-		if (leftThumbAngleDegrees < 0) leftThumbAngleDegrees += 360.0f;
-		// Set the player's velocity
-		if (leftThumbUsed) setVelocity(maxSpeed, leftThumbAngleDegrees);
+	if (!isDying && !isDead) {
+		// Get thumb vectors
+		Vector2 leftThumb = m_pController->GetLThumb();
+		Vector2 rightThumb = m_pController->GetRThumb();
+		// Check if sticks are significantly pressed
+		bool leftThumbUsed = abs(leftThumb.x) + abs(leftThumb.y) > 0.05f;
+		bool rightThumbUsed = abs(rightThumb.x) + abs(rightThumb.y) > 0.05f;
+		// Left stick handler
+		if (leftThumbUsed) {
+			// Calculate angles
+			float leftThumbAngle = atan2f(leftThumb.y, leftThumb.x);
+			float leftThumbAngleDegrees = leftThumbAngle * (180.0f / MY_PI);
+			if (leftThumbAngleDegrees < 0) leftThumbAngleDegrees += 360.0f;
+			// Set the player's velocity
+			if (leftThumbUsed) setVelocity(maxSpeed, leftThumbAngleDegrees);
+		}
+		else setVelocity(0, angle);
+		// Right stick handler
+		if (rightThumbUsed) {
+			// Calculate angles
+			float rightThumbAngle = atan2f(rightThumb.y, rightThumb.x);
+			float rightThumbAngleDegrees = rightThumbAngle * (180.0f / MY_PI);
+			if (rightThumbAngleDegrees < 0) rightThumbAngleDegrees += 360.0f;
+			// Control the player's shooting
+			if (rightThumbUsed) shoot(rightThumbAngleDegrees);
+		}
 	}
-	else setVelocity(0, angle);
-	// Right stick handler
-	if (rightThumbUsed) {
-		// Calculate angles
-		float rightThumbAngle = atan2f(rightThumb.y, rightThumb.x);
-		float rightThumbAngleDegrees = rightThumbAngle * (180.0f / MY_PI);
-		if (rightThumbAngleDegrees < 0) rightThumbAngleDegrees += 360.0f;
-		// Control the player's shooting
-		if (rightThumbUsed) shoot(rightThumbAngleDegrees);
-	}
 }
 
 GameObject* PlayerCharacter::_createProjectile() {

------------------------------------------------------------------------
r84 | jdg0393 | 2020-11-29 22:40:53 -0600 (Sun, 29 Nov 2020) | 1 line

Viking throws axes now and a new cyborg character shoots piercing lasers.

Index: Source/LaserBeam.h
===================================================================
--- Source/LaserBeam.h	(nonexistent)
+++ Source/LaserBeam.h	(revision 84)
@@ -0,0 +1,12 @@
+#pragma once
+#include "Projectile.h"
+#include "Piercing.h"
+class LaserBeam :
+	public Projectile,
+	public Piercing
+{
+public:
+	LaserBeam(Scene* scene, float x = 0, float y = 0, float z = 0);
+	void update() override;
+};
+
Index: Source/ThrowingAxe.h
===================================================================
--- Source/ThrowingAxe.h	(nonexistent)
+++ Source/ThrowingAxe.h	(revision 84)
@@ -0,0 +1,10 @@
+#pragma once
+#include "Projectile.h"
+class ThrowingAxe :
+	public Projectile
+{
+public:
+	ThrowingAxe(Scene* scene, float x = 0, float y = 0, float z = 0);
+	void update() override;
+};
+
Index: Source/VikingPlayer.cpp
===================================================================
--- Source/VikingPlayer.cpp	(revision 83)
+++ Source/VikingPlayer.cpp	(revision 84)
@@ -1,6 +1,6 @@
 #include "VikingPlayer.h"
 #include "Scene.h"
-#include "Bullet.h"
+#include "ThrowingAxe.h"
 
 VikingPlayer::VikingPlayer(Scene* scene, float x, float y, float z) :
 	PlayerCharacter(scene, x, y, z)
@@ -15,5 +15,5 @@
 
 // Creates the fireball as the projectile
 GameObject* VikingPlayer::_createProjectile() {
-	return scene->addObject(new Bullet(scene, m_vPos.x, m_vPos.y, m_vPos.z));
+	return scene->addObject(new ThrowingAxe(scene, m_vPos.x, m_vPos.y, m_vPos.z));
 }
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 83)
+++ Source/Renderer.cpp	(revision 84)
@@ -28,9 +28,6 @@
 	BeginResourceUpload();
 
 	// Loading of images goes here
-	Load(VIKING_HAT, "viking_hat");
-	Load(WIZARD_HAT, "wizard_hat");
-	Load(BULLET1, "bullet1");
 	Load(SPIRE_BASE, "spire_base");
 	Load(SPIRE_PEAK, "spire_peak");
 	Load(MAGE1, "mage1");
@@ -39,11 +36,19 @@
 	Load(RANGE1, "range1");
 	Load(RANGE2, "range2");
 	Load(RANGE3, "range3");
-	Load(FIREBALL, "fireball");
 	Load(EXPLOSION, "explosion");
 	Load(SMOKE, "smoke");
 	Load(DESERTLEVEL, "desertLevel");
 	Load(BASELEVEL, "baseLevel");
+	// Hats
+	Load(VIKING_HAT, "viking_hat");
+	Load(WIZARD_HAT, "wizard_hat");
+	Load(CYBORG_HAT, "cyborg_hat");
+	// Projectiles
+	Load(FIREBALL, "fireball");
+	Load(BULLET1, "bullet1");
+	Load(THROWING_AXE, "throwing_axe");
+	Load(REDLINE, "redline");
 	// Tilesets
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(DESERT_TILE, "desert_tile");
@@ -55,7 +60,7 @@
 	Load(TITLE_SCREEN, "title_screen");
 	Load(MENU_BOX, "menu_box");
 	Load(BLACK_SQUARE, "black_square");
-	Load(GREENLINE_SPRITE, "greenline");
+	Load(GREENLINE, "greenline");
 	// Characters
 	Load(HUMAN_IDLE, "human_idle");
 	Load(HUMAN_WALK, "human_walk");
@@ -80,7 +85,7 @@
 	const Vector3 extent = aabb.Extents;
 
 	CSpriteDesc3D clsnSprite;
-	clsnSprite.m_nSpriteIndex = GREENLINE_SPRITE;
+	clsnSprite.m_nSpriteIndex = GREENLINE;
 	clsnSprite.m_fAlpha = 0.5;
 	clsnSprite.m_vPos = { center.x, center.y, -5 };
 	clsnSprite.m_fXScale = extent.x;
Index: Source/HatSelectScene.cpp
===================================================================
--- Source/HatSelectScene.cpp	(revision 83)
+++ Source/HatSelectScene.cpp	(revision 84)
@@ -10,7 +10,8 @@
 	this->coOp = coOp;
 	hatsMenu = {
 		{"Loaf", WIZARD_HAT},
-		{"Doepler", VIKING_HAT}
+		{"Doepler", VIKING_HAT},
+		{"Neuro", CYBORG_HAT}
 	};
 	selection.first = 0;
 	selection.second = 0;
@@ -148,10 +149,4 @@
 	game->startScene(new LevelSelectScene(game, 
 		hatsMenu[selection.first].second,
 		hatsMenu[selection.second].second, coOp));
-	//game->startScene(new BaseLevelScene(game,
-		//hatsMenu[selection.first].second,
-		//hatsMenu[selection.second].second, coOp));
-	//game->startScene(new DesolateDesertLevel(game,
-		//hatsMenu[selection.first].second,
-		//hatsMenu[selection.second].second, coOp));
 }
\ No newline at end of file
Index: Source/LaserBeam.cpp
===================================================================
--- Source/LaserBeam.cpp	(nonexistent)
+++ Source/LaserBeam.cpp	(revision 84)
@@ -0,0 +1,22 @@
+#include "LaserBeam.h"
+
+LaserBeam::LaserBeam(Scene* scene, float x, float y, float z) :
+	GameObject(scene, REDLINE, x, y, z)
+{
+	tags.insert("projectile");
+	tags.insert("piercing");
+	lifespan = 2.0f;
+	m_fXScale = 20.0f;
+	m_fYScale = 1.3f;
+	m_sAabb.Extents = { 5.0f, 5.0f, 5.0f };
+}
+
+void LaserBeam::update() {
+	Piercing::update();
+	// Move the bouding box of the laser to the end of the laser
+	Vector2 directionVector = getNetForce();
+	directionVector.Normalize();
+	Vector2 transform = directionVector * 10.0f;
+	m_sAabb.Center.x += transform.x;
+	m_sAabb.Center.y += transform.y;
+}
\ No newline at end of file
Index: Source/ThrowingAxe.cpp
===================================================================
--- Source/ThrowingAxe.cpp	(nonexistent)
+++ Source/ThrowingAxe.cpp	(revision 84)
@@ -0,0 +1,17 @@
+#include "ThrowingAxe.h"
+
+ThrowingAxe::ThrowingAxe(Scene* scene, float x, float y, float z) :
+	GameObject(scene, THROWING_AXE, x, y, z)
+{
+	tags.insert("projectile");
+	m_sAabb = BoundingBox({ x,y,z }, { 5,5,5 });
+	damage = 20;
+	m_fXScale = 2.0f;
+	m_fYScale = 2.0f;
+	m_sAabb.Extents = { 16.0f, 16.0f, 16.0f };
+}
+
+void ThrowingAxe::update() {
+	m_fRoll += 0.1f;
+	GameObject::update();
+}
\ No newline at end of file
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 83)
+++ Source/BaseLevelScene.cpp	(revision 84)
@@ -4,6 +4,7 @@
 #include "HUDObject.h"
 #include "VikingPlayer.h"
 #include "WizardPlayer.h"
+#include "CyborgPlayer.h"
 #include "MageTower.h"
 #include "RangeTower.h"
 #include "BadGoblin.h"
@@ -125,7 +126,6 @@
 		}
 	}
 	if (!gameOver) {
-		//string hpString = "Spire Hit Points: " + to_string(spire->hp) + "/1000";
 		string hpString = "Spire";
 		float offset = hpString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(hpString.c_str(), { 640.0f - offset, 26.0f }, Colors::White);
@@ -134,8 +134,6 @@
 		offset = waveString.size() * 7.5f;
 		m_pRenderer->DrawScreenText(waveString.c_str(), { 640.0f - offset, 66.0f }, Colors::White);
 
-		//m_pRenderer->DrawScreenText(to_string(goblinWaves.nextSpawn - m_pStepTimer->GetTotalSeconds()).c_str(), { 10.0f, 680.0f }, Colors::White);
-
 		string credString = to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 44.0f,30.0f }, Colors::Gold);
 
@@ -161,6 +159,8 @@
 		player = (PlayerCharacter*)addObject(new WizardPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
 	else if (hat == VIKING_HAT)
 		player = (PlayerCharacter*)addObject(new VikingPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
+	else if (hat == CYBORG_HAT)
+		player = (PlayerCharacter*)addObject(new CyborgPlayer(this, paths["plySpawn"].x, paths["plySpawn"].y));
 	player->setPlayerID(id);
 }
 
@@ -249,8 +249,8 @@
 				if (tow->is("lvl0")) {
 					if (credits >= 10) {
 						newTow = addObject(new RangeTower(this, RANGE2, 1, tow->getPosition().x, tow->getPosition().y));
-						newTow->m_fXScale = 1.7;
-						newTow->m_fYScale = 1.7;
+						newTow->m_fXScale = 1.7f;
+						newTow->m_fYScale = 1.7f;
 						tow->kill();
 						credits -= 10;
 					}
@@ -258,8 +258,8 @@
 				if (tow->is("lvl1")) {
 					if (credits >= 20) {
 						newTow = addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
-						newTow->m_fXScale = 1.7;
-						newTow->m_fYScale = 1.7;
+						newTow->m_fXScale = 1.7f;
+						newTow->m_fYScale = 1.7f;
 						tow->kill();
 						credits -= 20;
 					}
@@ -277,8 +277,8 @@
 					if (credits >= 30) {
 						newTow = addObject(new MageTower(this, MAGE3, 2, tow->getPosition().x, tow->getPosition().y));
 						tow->kill();
-						newTow->m_fXScale = 0.7;
-						newTow->m_fYScale = 0.7;
+						newTow->m_fXScale = 0.7f;
+						newTow->m_fYScale = 0.7f;
 						credits -= 30;
 					}
 				}
@@ -440,11 +440,16 @@
 		if (!baddie->isDying()) {
 			baddie->damage(p->damage);
 			// Knockback from the projectile
-			//obj2->setForceVelocity(obj1->getVelocity());
-			obj2->addForce(obj1->getNetForce(), 0.25f);
-			// Don't kill if object is explosive, we need it's properties until it's
-			// killed in the handler for explosives
-			if (!obj1->is("explosive"))
+			if (obj1->is("piercing")) {
+				// Piercing projectiles have much lower knockback
+				obj2->addForce(obj1->getNetForce() * 0.1f, 0.25f);
+			}
+			else
+			{
+				obj2->addForce(obj1->getNetForce(), 0.25f);
+			}
+			// Don't kill if object is explosive, or piercing, they'll handle expiration elsewhere
+			if (!obj1->is("explosive") && !obj1->is("piercing"))
 				obj1->kill();
 		}
 	}
Index: Source/CyborgPlayer.cpp
===================================================================
--- Source/CyborgPlayer.cpp	(nonexistent)
+++ Source/CyborgPlayer.cpp	(revision 84)
@@ -0,0 +1,19 @@
+#include "CyborgPlayer.h"
+#include "Scene.h"
+#include "LaserBeam.h"
+
+CyborgPlayer::CyborgPlayer(Scene* scene, float x, float y, float z) :
+	PlayerCharacter(scene, x, y, z)
+{
+	hat = scene->addObject(new GameObject(scene, CYBORG_HAT, m_vPos.x, m_vPos.y, m_vPos.z));
+	maxSpeed = 350.0f;
+	// Projectile usage qualities
+	shootCooldown = 0.25f;
+	shootTime = 0.0f;
+	projectileSpeed = 800.0f;
+}
+
+// Creates the fireball as the projectile
+GameObject* CyborgPlayer::_createProjectile() {
+	return scene->addObject(new LaserBeam(scene, m_vPos.x, m_vPos.y, m_vPos.z));
+}
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 83)
+++ Source/GameDefines.h	(revision 84)
@@ -10,9 +10,6 @@
 ///
 /// Note: NUM_SPRITES must be last.
 enum eSpriteType {
-	VIKING_HAT,
-	WIZARD_HAT,
-	BULLET1,
 	SPIRE_BASE,
 	SPIRE_PEAK,
 	RANGE1,
@@ -21,11 +18,19 @@
 	MAGE1,
 	MAGE2,
 	MAGE3,
-	FIREBALL,
 	EXPLOSION,
 	SMOKE,
 	DESERTLEVEL,
 	BASELEVEL,
+	// Hats
+	VIKING_HAT,
+	WIZARD_HAT,
+	CYBORG_HAT,
+	// Projectiles
+	FIREBALL,
+	BULLET1,
+	THROWING_AXE,
+	REDLINE,
 	// Tilesets
 	SIMPLE_TILE,
 	DESERT_TILE,
@@ -37,7 +42,7 @@
 	TITLE_SCREEN,
 	MENU_BOX,
 	BLACK_SQUARE,
-	GREENLINE_SPRITE,
+	GREENLINE,
 	// Characters
 	HUMAN_IDLE,
 	HUMAN_WALK,
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 83)
+++ Source/Spire.cpp	(revision 84)
@@ -10,7 +10,7 @@
 	attackZone = BoundingBox(clsnCenter, m_sAabb.Extents * 2.0f);
 	peak = scene->addObject(new GameObject(scene, SPIRE_PEAK, x, y + 116, z - .1f));
 	explodeAnimation = AnimationDesc(EXPLOSION, 0, 4, 0.15f);
-	healthBar = scene->addObject(new HUDObject(scene, GREENLINE_SPRITE, 0, 0.9f, 0));
+	healthBar = scene->addObject(new HUDObject(scene, GREENLINE, 0, 0.9f, 0));
 	healthBar->relativeYScale = 10.0f;
 
 	// Descriptor tags
Index: Source/Piercing.h
===================================================================
--- Source/Piercing.h	(nonexistent)
+++ Source/Piercing.h	(revision 84)
@@ -0,0 +1,16 @@
+#pragma once
+#include "GameObject.h"
+
+class Piercing : virtual public GameObject
+{
+public:
+	Piercing() {}
+	float lifespan = 5.0f;
+	virtual void update() override {
+		GameObject::update();
+		if (m_pStepTimer->GetTotalSeconds() > creationTime + lifespan) {
+			kill();
+		}
+	}
+};
+
Index: Source/CyborgPlayer.h
===================================================================
--- Source/CyborgPlayer.h	(nonexistent)
+++ Source/CyborgPlayer.h	(revision 84)
@@ -0,0 +1,11 @@
+#pragma once
+#include "PlayerCharacter.h"
+class CyborgPlayer :
+    public PlayerCharacter
+{
+public:
+    CyborgPlayer(Scene* scene, float x, float y, float z = 1.15);
+protected:
+    GameObject* _createProjectile() override;
+};
+
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 83)
+++ Source/Source.vcxproj	(revision 84)
@@ -171,6 +171,7 @@
     <ClCompile Include="Character.cpp" />
     <ClCompile Include="Coin.cpp" />
     <ClCompile Include="Common.cpp" />
+    <ClCompile Include="CyborgPlayer.cpp" />
     <ClCompile Include="DesolateDesertLevel.cpp" />
     <ClCompile Include="Fireball.cpp" />
     <ClCompile Include="Game.cpp" />
@@ -178,6 +179,7 @@
     <ClCompile Include="GamepadWrapper.cpp" />
     <ClCompile Include="HatSelectScene.cpp" />
     <ClCompile Include="HUDObject.cpp" />
+    <ClCompile Include="LaserBeam.cpp" />
     <ClCompile Include="LevelSelectScene.cpp" />
     <ClCompile Include="MageTower.cpp" />
     <ClCompile Include="Main.cpp" />
@@ -190,6 +192,7 @@
     <ClCompile Include="BaseLevelScene.cpp" />
     <ClCompile Include="ShopMenu.cpp" />
     <ClCompile Include="Spire.cpp" />
+    <ClCompile Include="ThrowingAxe.cpp" />
     <ClCompile Include="TiledScene.cpp" />
     <ClCompile Include="TitleScreenScene.cpp" />
     <ClCompile Include="Tower.cpp" />
@@ -206,6 +209,7 @@
     <ClInclude Include="Character.h" />
     <ClInclude Include="Coin.h" />
     <ClInclude Include="Common.h" />
+    <ClInclude Include="CyborgPlayer.h" />
     <ClInclude Include="DesolateDesertLevel.h" />
     <ClInclude Include="Explosive.h" />
     <ClInclude Include="Fireball.h" />
@@ -215,9 +219,11 @@
     <ClInclude Include="GamepadWrapper.h" />
     <ClInclude Include="HatSelectScene.h" />
     <ClInclude Include="HUDObject.h" />
+    <ClInclude Include="LaserBeam.h" />
     <ClInclude Include="LevelSelectScene.h" />
     <ClInclude Include="MageTower.h" />
     <ClInclude Include="OptionsScene.h" />
+    <ClInclude Include="Piercing.h" />
     <ClInclude Include="PlayerCharacter.h" />
     <ClInclude Include="Projectile.h" />
     <ClInclude Include="PseudoForce.h" />
@@ -229,6 +235,7 @@
     <ClInclude Include="Sndlist.h" />
     <ClInclude Include="SpawnDesc.h" />
     <ClInclude Include="Spire.h" />
+    <ClInclude Include="ThrowingAxe.h" />
     <ClInclude Include="TiledScene.h" />
     <ClInclude Include="TitleScreenScene.h" />
     <ClInclude Include="Tower.h" />
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 83)
+++ Source/PlayerCharacter.cpp	(revision 84)
@@ -122,6 +122,9 @@
 		GameObject* b = _createProjectile();
 		//b->setVelocity(projectileVelocity);
 		b->addForce(projectileVelocity, 1000.0f);
+		// Rotate the projectile. Some projectiles this doesn't really matter, but
+		// assume that 0rads is to the right and adjust just in case
+		b->m_fRoll = angle_in_radians;
 		// Update the next time I can shoot
 		shootTime = m_pStepTimer->GetTotalSeconds() + shootCooldown;
 	}
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 83)
+++ Source/Source.vcxproj.filters	(revision 84)
@@ -83,6 +83,15 @@
     <ClCompile Include="LevelSelectScene.cpp">
       <Filter>Scenes</Filter>
     </ClCompile>
+    <ClCompile Include="ThrowingAxe.cpp">
+      <Filter>Objects\Projectiles</Filter>
+    </ClCompile>
+    <ClCompile Include="LaserBeam.cpp">
+      <Filter>Objects\Projectiles</Filter>
+    </ClCompile>
+    <ClCompile Include="CyborgPlayer.cpp">
+      <Filter>Objects\Players</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -176,6 +185,18 @@
     <ClInclude Include="LevelSelectScene.h">
       <Filter>Scenes</Filter>
     </ClInclude>
+    <ClInclude Include="ThrowingAxe.h">
+      <Filter>Objects\Projectiles</Filter>
+    </ClInclude>
+    <ClInclude Include="Piercing.h">
+      <Filter>Properties</Filter>
+    </ClInclude>
+    <ClInclude Include="LaserBeam.h">
+      <Filter>Objects\Projectiles</Filter>
+    </ClInclude>
+    <ClInclude Include="CyborgPlayer.h">
+      <Filter>Objects\Players</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/LevelSelectScene.cpp
===================================================================
--- Source/LevelSelectScene.cpp	(revision 83)
+++ Source/LevelSelectScene.cpp	(revision 84)
@@ -22,8 +22,8 @@
 
 void LevelSelectScene::create() {
 	level = addObject(new HUDObject(this, BASELEVEL, -.5f, 0, 0));
-	level->m_fXScale = 0.7;
-	level->m_fYScale = 0.7;
+	level->m_fXScale = 0.7f;
+	level->m_fYScale = 0.7f;
 
 }
 

------------------------------------------------------------------------
r86 | jdg0393 | 2020-11-29 23:59:44 -0600 (Sun, 29 Nov 2020) | 1 line

Fixed co-op and gamepad controls in various locations. Fully playable controls now.

Index: Source/LevelSelectScene.cpp
===================================================================
--- Source/LevelSelectScene.cpp	(revision 85)
+++ Source/LevelSelectScene.cpp	(revision 86)
@@ -18,7 +18,7 @@
 	p2Hat = ply2Hat;
 }
 
-LevelSelectScene::~LevelSelectScene(){};
+LevelSelectScene::~LevelSelectScene() {};
 
 void LevelSelectScene::create() {
 	level = addObject(new HUDObject(this, BASELEVEL, -.5f, 0, 0));
@@ -39,6 +39,9 @@
 		if (gamepad.isPressed("LSTICK_LEFT")) selection.first--;
 		else if (gamepad.isPressed("LSTICK_RIGHT")) selection.first =
 			(selection.first + 1) % (int)LevelMenu.size();
+		if (gamepad.isPressed("BUTTON_A")) {
+			startLevel();
+		}
 	}
 
 	// If it's below zero, loop selection around
@@ -45,10 +48,8 @@
 	if (selection.first < 0) selection.first = (int)LevelMenu.size() - 1;
 
 	if (m_pKeyboard->TriggerDown(controlMap["PLAYER1_ACCEPT"])) {
-		ready.first = true;
+		startLevel();
 	}
-
-	if (ready.first) startLevel();
 }
 
 void LevelSelectScene::render() {
Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 85)
+++ Source/PlayerCharacter.cpp	(revision 86)
@@ -136,6 +136,10 @@
 	if (!isDying && !isDead) {
 		_handleMovementKeys();
 		_handleDirectionKeys();
+		if (m_pKeyboard->TriggerDown(controlMap[playerID + "_UPGRADE"]))
+			((BaseLevelScene*)scene)->upgradeTower(this);
+		if (m_pKeyboard->TriggerDown(controlMap[playerID + "_DESTROY"]))
+			((BaseLevelScene*)scene)->destroyTower(this);
 	}
 }
 
@@ -166,6 +170,14 @@
 			// Control the player's shooting
 			if (rightThumbUsed) shoot(rightThumbAngleDegrees);
 		}
+
+		// Check if the tower upgrade button is pressed
+		if (gamepad.isPressed("BUTTON_X")) {
+			((BaseLevelScene*)scene)->upgradeTower(this);
+		}
+		if (gamepad.isPressed("BUTTON_B")) {
+			((BaseLevelScene*)scene)->destroyTower(this);
+		}
 	}
 }
 
Index: Source/TiledScene.cpp
===================================================================
--- Source/TiledScene.cpp	(revision 85)
+++ Source/TiledScene.cpp	(revision 86)
@@ -67,7 +67,7 @@
 	inData.close();
 
 	// Load each of the main 3 display layers
-	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey, 1.31f);
+	_loadTileLayer(map_name + "_bg.txt", tileSpriteKey, 1.35f);
 	_loadTileLayer(map_name + "_bg2.txt", tileSpriteKey, 1.30f);
 	_loadTileLayer(map_name + "_fg.txt", tileSpriteKey, 1.2f);
 	_loadTileLayer(map_name + "_oh.txt", tileSpriteKey, 1.1f);
Index: Source/Common.cpp
===================================================================
--- Source/Common.cpp	(revision 85)
+++ Source/Common.cpp	(revision 86)
@@ -25,7 +25,8 @@
 	{"PLAYER1_ACCEPT", 'E'},
 	{"PLAYER1_BACK", VK_ESCAPE},
 	{"PLAYER1_MENU", 'Q'},
-	{"PLAYER1_UPGRADE", 'Z'},
+	{"PLAYER1_UPGRADE", 'C'},
+	{"PLAYER1_DESTROY" , 'X'},
 	// Player 2 move keys
 	{"PLAYER2_UP", 'T'},
 	{"PLAYER2_DOWN", 'G'},
@@ -40,7 +41,8 @@
 	{"PLAYER2_ACCEPT", 'Y'},
 	{"PLAYER2_BACK", 'U'},
 	{"PLAYER2_MENU", 'R'},
-	{"PLAYER2_UPGRADE" , 'U'},
+	{"PLAYER2_UPGRADE" , 'N'},
+	{"PLAYER2_DESTROY" , 'B'},
 	// Debugging keys
 	{"DEBUG_ZOOM", 'Z'},
 	{"DEBUG_SHOW_CLSN", VK_F4},
@@ -56,6 +58,6 @@
 	{'1',"1"}, {'2',"2"}, {'3',"3"}, {'4',"4"}, {'5',"5"}, {'6',"6"}, {'7',"7"}, {'8',"8"}, {'9',"9"},
 	{VK_F1,"F1"}, {VK_F2,"F2"}, {VK_F3,"F3"}, {VK_F4,"F4"}, {VK_F5,"F5"}, {VK_F6,"F6"}, {VK_F7,"F7"},
 	{VK_F8,"F8"}, {VK_F9,"F9"}, {VK_F10,"F10"}, {VK_F11,"F11"}, {VK_F12,"F12"},
-	{VK_UP,"Up Arrow"}, {VK_DOWN,"Down Arrow"}, {VK_LEFT,"Left Arrow"}, {VK_RIGHT,"Right Arrow"},
-	{VK_RETURN, "Enter/Return"}, {VK_ESCAPE, "Escape"}
+	{VK_UP,"UP ARROW"}, {VK_DOWN,"DOWN ARROW"}, {VK_LEFT,"LEFT ARROW"}, {VK_RIGHT,"RIGHT ARROW"},
+	{VK_RETURN, "ENTER/RETURN"}, {VK_ESCAPE, "ESCAPE"}
 };
\ No newline at end of file
Index: Source/BaseLevelScene.h
===================================================================
--- Source/BaseLevelScene.h	(revision 85)
+++ Source/BaseLevelScene.h	(revision 86)
@@ -35,11 +35,13 @@
 	int getCredits();
 	void addCredits(int amount);
 	void removeCredits(int amount);
+	void destroyTower(PlayerCharacter* upgrader);
+	void upgradeTower(PlayerCharacter* upgrader);
 
 	PlayerCharacter* getPlayer(); // Returns the current player object as a pointer
 	pair<PlayerCharacter*, PlayerCharacter*> BaseLevelScene::getPlayers();
-	GameObject* getClosestTower();//returns the tower closest to the PC
-	float distToTower();
+	GameObject* getClosestTower(PlayerCharacter* player);//returns the tower closest to the PC
+	float distToTower(PlayerCharacter* player);
 	vector<BadCharacter*> getBaddies(); //returns the vector containing enemy objects
 	Spire* getSpire() { return spire; }
 	void setSpire(Spire* sp) { spire = sp; }
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 85)
+++ Source/BaseLevelScene.cpp	(revision 86)
@@ -74,8 +74,8 @@
 			Vector3 p1 = followTargets.first->getPosition();
 			Vector3 p2 = followTargets.second->getPosition();
 			Vector2 between = (p1 + p2) / 2.0f;
-			float dx = abs(p1.x - p2.x) * .002f;
-			float dy = abs(p1.y - p2.y) * .003f;
+			float dx = abs(p1.x - p2.x) * .0025f;
+			float dy = abs(p1.y - p2.y) * .005f;
 			float zMod = dx > dy ? dx : dy;
 			if (zMod > 1.0f)
 				m_pRenderer->SetCameraPos({ between.x, between.y, (.66f * defPos.z) * zMod });
@@ -136,9 +136,6 @@
 
 		string credString = to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 44.0f,30.0f }, Colors::Gold);
-
-		string priceString = "Press 'U' to upgrade a tower";
-		m_pRenderer->DrawScreenText(priceString.c_str(), { 100.0f,60.0f }, Colors::White);
 	}
 	else {
 		m_pRenderer->setFont("title_font");
@@ -151,6 +148,48 @@
 	// Render the text from the shop menus
 	towerMenus.first->renderText();
 	towerMenus.second->renderText();
+
+	// Create prompts for both players
+	string p1Prompt = "";
+	string p2Prompt = "";
+	if (controllerOwner == 1) {
+		p1Prompt += "x";
+	}
+	else {
+		p1Prompt += keyboardKeys[controlMap["PLAYER1_UPGRADE"]];
+	}
+	if (controllerOwner == 2) {
+		p2Prompt = "x";
+	}
+	else {
+		p2Prompt += keyboardKeys[controlMap["PLAYER2_UPGRADE"]];
+	}
+	p1Prompt += " UPGRADE\n";
+	p2Prompt += " UPGRADE\n";
+
+	if (controllerOwner == 1) {
+		p1Prompt += "b";
+	}
+	else {
+		p1Prompt += keyboardKeys[controlMap["PLAYER1_DESTROY"]];
+	}
+	if (controllerOwner == 2) {
+		p2Prompt += "b";
+	}
+	else {
+		p2Prompt += keyboardKeys[controlMap["PLAYER2_DESTROY"]];
+	}
+	p1Prompt += " DESTROY\n";
+	p2Prompt += " DESTROY\n";
+
+	// Draw the prompts for both players
+	m_pRenderer->setFont("prompt_font");
+	m_pRenderer->DrawScreenText(p1Prompt.c_str(), { 20,660 }, Colors::GhostWhite);
+	if (coOp) {
+		// Draw second player prompts
+		m_pRenderer->DrawScreenText(p2Prompt.c_str(), { 1130,660 }, Colors::GhostWhite);
+	}
+	m_pRenderer->setFont("font");
 }
 
 void BaseLevelScene::_createPlayer(PlayerCharacter*& player, eSpriteType hat, string id) {
@@ -239,66 +278,6 @@
 	// Toggle drawing of tilemap collision boxes
 	if (m_pKeyboard->TriggerDown(controlMap["DEBUG_SHOW_CLSN"]))
 		drawMapClsn = drawMapClsn ? false : true;
-
-	if (m_pKeyboard->TriggerDown('U')) {
-
-		GameObject* tow = getClosestTower();
-		GameObject* newTow;
-		if (tow != NULL && distToTower() <= 75) {
-			if (tow->is("range")) {
-				if (tow->is("lvl0")) {
-					if (credits >= 10) {
-						newTow = addObject(new RangeTower(this, RANGE2, 1, tow->getPosition().x, tow->getPosition().y));
-						newTow->m_fXScale = 1.7f;
-						newTow->m_fYScale = 1.7f;
-						tow->kill();
-						credits -= 10;
-					}
-				}
-				if (tow->is("lvl1")) {
-					if (credits >= 20) {
-						newTow = addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
-						newTow->m_fXScale = 1.7f;
-						newTow->m_fYScale = 1.7f;
-						tow->kill();
-						credits -= 20;
-					}
-				}
-			}
-			if (tow->is("mage")) {
-				if (tow->is("lvl0")) {
-					if (credits >= 15) {
-						newTow = addObject(new MageTower(this, MAGE2, 1, tow->getPosition().x, tow->getPosition().y));
-						tow->kill();
-						credits -= 15;
-					}
-				}
-				if (tow->is("lvl1")) {
-					if (credits >= 30) {
-						newTow = addObject(new MageTower(this, MAGE3, 2, tow->getPosition().x, tow->getPosition().y));
-						tow->kill();
-						newTow->m_fXScale = 0.7f;
-						newTow->m_fYScale = 0.7f;
-						credits -= 30;
-					}
-				}
-			}
-		}
-	}
-
-
-	if (m_pKeyboard->TriggerDown('X')) {
-		GameObject* tow = getClosestTower();
-		if (tow != NULL && distToTower() <= 75) {
-			if (tow->is("range")) {
-				credits += 3;
-			}
-			if (tow->is("mage")) {
-				credits += 8;
-			}
-			deleteObject(tow);
-		}
-	}
 }
 
 void BaseLevelScene::handleMouse() {
@@ -341,8 +320,8 @@
 }
 
 //returns the tower that is nearest to the player. used for deleting a tower now but could have some more future functionality
-GameObject* BaseLevelScene::getClosestTower() {
-	Vector3 playerPos = players.first->getPosition();
+GameObject* BaseLevelScene::getClosestTower(PlayerCharacter* player) {
+	Vector3 playerPos = player->getPosition();
 	Vector3 towerPos;
 	GameObject* tow = NULL;
 	float difX = 1000, difY = 1000, dif = 1000;
@@ -361,13 +340,12 @@
 		return NULL;
 	else
 		return tow;
-
 }
 
-float BaseLevelScene::distToTower() {	//returns distance from player to closest tower
-	GameObject* tow = getClosestTower();
+float BaseLevelScene::distToTower(PlayerCharacter* player) {	//returns distance from player to closest tower
+	GameObject* tow = getClosestTower(player);
 	Vector3 towerPos = tow->getPosition();
-	Vector3 playerPos = players.first->getPosition();
+	Vector3 playerPos = player->getPosition();
 	float difX, difY, dist;
 	difX = abs(playerPos.x - towerPos.x);
 	difY = abs(playerPos.y - towerPos.y);
@@ -497,6 +475,64 @@
 	credits -= amount;
 }
 
+void BaseLevelScene::upgradeTower(PlayerCharacter* upgrader) {
+	GameObject* tow = getClosestTower(upgrader);
+	GameObject* newTow;
+	if (tow != NULL && distToTower(upgrader) <= 75) {
+		if (tow->is("range")) {
+			if (tow->is("lvl0")) {
+				if (credits >= 10) {
+					newTow = addObject(new RangeTower(this, RANGE2, 1, tow->getPosition().x, tow->getPosition().y));
+					newTow->m_fXScale = 1.7f;
+					newTow->m_fYScale = 1.7f;
+					tow->kill();
+					credits -= 10;
+				}
+			}
+			if (tow->is("lvl1")) {
+				if (credits >= 20) {
+					newTow = addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
+					newTow->m_fXScale = 1.7f;
+					newTow->m_fYScale = 1.7f;
+					tow->kill();
+					credits -= 20;
+				}
+			}
+		}
+		if (tow->is("mage")) {
+			if (tow->is("lvl0")) {
+				if (credits >= 15) {
+					newTow = addObject(new MageTower(this, MAGE2, 1, tow->getPosition().x, tow->getPosition().y));
+					tow->kill();
+					credits -= 15;
+				}
+			}
+			if (tow->is("lvl1")) {
+				if (credits >= 30) {
+					newTow = addObject(new MageTower(this, MAGE3, 2, tow->getPosition().x, tow->getPosition().y));
+					tow->kill();
+					newTow->m_fXScale = 0.7f;
+					newTow->m_fYScale = 0.7f;
+					credits -= 30;
+				}
+			}
+		}
+	}
+}
+
+void BaseLevelScene::destroyTower(PlayerCharacter* upgrader) {
+	GameObject* tow = getClosestTower(upgrader);
+	if (tow != NULL && distToTower(upgrader) <= 75) {
+		if (tow->is("range")) {
+			credits += 3;
+		}
+		if (tow->is("mage")) {
+			credits += 8;
+		}
+		deleteObject(tow);
+	}
+}
+
 void BaseLevelScene::createSpawnDescriptors() {
 	// Define some spawn descriptors for the wave spawner
 	SpawnDesc goblins;
@@ -523,4 +559,4 @@
 	// Add the spawn descriptions
 	waves->addSpawnDesc(goblins);
 	waves->addSpawnDesc(minotaurs);
-}
\ No newline at end of file
+}

------------------------------------------------------------------------
r87 | jdg0393 | 2020-11-30 00:21:20 -0600 (Mon, 30 Nov 2020) | 1 line

Player faces the direction they're shooting instead of the direction they're moving. It looks nicer I think.

Index: Source/PlayerCharacter.cpp
===================================================================
--- Source/PlayerCharacter.cpp	(revision 86)
+++ Source/PlayerCharacter.cpp	(revision 87)
@@ -109,6 +109,7 @@
 }
 
 void PlayerCharacter::shoot(float angle_in_degrees) {
+	angle = angle_in_degrees;
 	if (m_pStepTimer->GetTotalSeconds() > shootTime) {
 		// Convert the angle to radians for mathematics
 		float angle_in_radians = angle_in_degrees * (MY_PI / 180);

------------------------------------------------------------------------
r88 | jdg0393 | 2020-11-30 15:29:36 -0600 (Mon, 30 Nov 2020) | 1 line

Sound for fireballs and spire explosion.

Index: Source/Spire.h
===================================================================
--- Source/Spire.h	(revision 87)
+++ Source/Spire.h	(revision 88)
@@ -17,5 +17,6 @@
 	AnimationDesc explodeAnimation;
 	GameObject* peak;
 	HUDObject* healthBar;
+	bool detonated = false;
 };
 
Index: Source/Spire.cpp
===================================================================
--- Source/Spire.cpp	(revision 87)
+++ Source/Spire.cpp	(revision 88)
@@ -23,6 +23,8 @@
 	stepAnimation();
 	if (hp <= 0) {
 		startAnimation(explodeAnimation);
+		if (!detonated) m_pAudio->play(EXPLOSION_SOUND);
+		detonated = true;
 		m_vPos = { m_vPos.x, m_vPos.y , -5 };
 		m_fXScale = 12.0;
 		m_fYScale = 12.0;
Index: Source/Sndlist.h
===================================================================
--- Source/Sndlist.h	(revision 87)
+++ Source/Sndlist.h	(revision 88)
@@ -15,5 +15,7 @@
 	MAP_SONG,
 	GUN_SOUND,
 	CLANG_SOUND,
-	COIN_GRAB
+	COIN_GRAB,
+	EXPLOSION_SOUND,
+	FIREBALL_SOUND
 }; //eSoundType
\ No newline at end of file
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 87)
+++ Source/Fireball.cpp	(revision 88)
@@ -34,6 +34,7 @@
 
 void Fireball::kill() {
 	startAnimation(explodeAnimation);
+	if (!detonated)m_pAudio->play(FIREBALL_SOUND);
 	// Size of the explosion
 	if (lvl == 0) {
 		m_fXScale = 2.0;

------------------------------------------------------------------------
r89 | amm0837 | 2020-11-30 15:30:22 -0600 (Mon, 30 Nov 2020) | 1 line

added timer for player character respawn

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 88)
+++ Source/BaseLevelScene.cpp	(revision 89)
@@ -136,6 +136,18 @@
 
 		string credString = to_string(credits);
 		m_pRenderer->DrawScreenText(credString.c_str(), { 44.0f,30.0f }, Colors::Gold);
+
+		if(getPlayers().first->isDead){
+			string respawnTimer = to_string(int((getPlayers().first->timeDied + 20) - m_pStepTimer->GetTotalSeconds()));
+			m_pRenderer->DrawScreenText("Oh Dear, You Have Died... Respawn in:", Vector2(500, 95), Colors::IndianRed);
+			m_pRenderer->DrawScreenText(respawnTimer.c_str(), Vector2(500, 120), Colors::IndianRed);
+			}
+		if (coOp&&getPlayers().second->isDead) {
+			string respawnTimer = to_string(int((getPlayers().second->timeDied + 20) - m_pStepTimer->GetTotalSeconds()));
+			m_pRenderer->DrawScreenText("Oh Dear, You Have Died... Respawn in:", Vector2(500, 95), Colors::IndianRed);
+			m_pRenderer->DrawScreenText(respawnTimer.c_str(), Vector2(500, 120), Colors::IndianRed);
+		}
+
 	}
 	else {
 		m_pRenderer->setFont("title_font");
Index: Source/LevelSelectScene.cpp
===================================================================
--- Source/LevelSelectScene.cpp	(revision 88)
+++ Source/LevelSelectScene.cpp	(revision 89)
@@ -21,7 +21,7 @@
 LevelSelectScene::~LevelSelectScene() {};
 
 void LevelSelectScene::create() {
-	level = addObject(new HUDObject(this, BASELEVEL, -.5f, 0, 0));
+	level = addObject(new HUDObject(this, BASELEVEL, 0, .05f, 0));
 	level->m_fXScale = 0.7f;
 	level->m_fYScale = 0.7f;
 
@@ -56,9 +56,10 @@
 	Scene::render();
 
 	m_pRenderer->setFont("title_font");
-	m_pRenderer->DrawScreenText("Level Select", Vector2(330, 10), Colors::Black);
+	m_pRenderer->DrawScreenText("Level Select", Vector2(400, 0), Colors::Black);
 	m_pRenderer->setFont("font");
-	m_pRenderer->DrawScreenText(LevelMenu[selection.first].first.c_str(), Vector2(300, 650), Colors::Black);
+	m_pRenderer->DrawScreenText(LevelMenu[selection.first].first.c_str(), Vector2(580, 600), Colors::Black);
+	m_pRenderer->DrawScreenText("Press E to confirm level and begin the game!\nDefend the spire from enemies!", Vector2(420,650), Colors::Black);
 }
 
 void LevelSelectScene::startLevel() {
Index: Source/PlayerCharacter.h
===================================================================
--- Source/PlayerCharacter.h	(revision 88)
+++ Source/PlayerCharacter.h	(revision 89)
@@ -21,6 +21,8 @@
 	int hp = 100;
 	bool isDying = false;
 	bool isDead = false;
+	// The time the player died, stored for respawn purposes
+	float timeDied = -1.0f;
 protected:
 	string playerID;
 	float shootCooldown;
@@ -27,8 +29,7 @@
 	float shootTime;
 	float projectileSpeed;
 	float maxSpeed;
-	// The time the player died, stored for respawn purposes
-	float timeDied = -1.0f;
+	
 	GameObject* hat = nullptr;
 	// A flag used for one small part of the death animation
 	bool _hatFalling = false;

------------------------------------------------------------------------
r90 | jdg0393 | 2020-11-30 16:31:07 -0600 (Mon, 30 Nov 2020) | 1 line

Updated projectile balance and added projectile sounds.

Index: Source/LaserBeam.cpp
===================================================================
--- Source/LaserBeam.cpp	(revision 89)
+++ Source/LaserBeam.cpp	(revision 90)
@@ -6,9 +6,11 @@
 	tags.insert("projectile");
 	tags.insert("piercing");
 	lifespan = 2.0f;
+	damage = 2;
 	m_fXScale = 20.0f;
 	m_fYScale = 1.3f;
 	m_sAabb.Extents = { 5.0f, 5.0f, 5.0f };
+	m_pAudio->play(LASER_SOUND);
 }
 
 void LaserBeam::update() {
Index: Source/ThrowingAxe.cpp
===================================================================
--- Source/ThrowingAxe.cpp	(revision 89)
+++ Source/ThrowingAxe.cpp	(revision 90)
@@ -9,6 +9,7 @@
 	m_fXScale = 2.0f;
 	m_fYScale = 2.0f;
 	m_sAabb.Extents = { 16.0f, 16.0f, 16.0f };
+	m_pAudio->play(AXE_SOUND);
 }
 
 void ThrowingAxe::update() {
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 89)
+++ Source/BaseLevelScene.cpp	(revision 90)
@@ -427,12 +427,12 @@
 	if (obj1->is("projectile") && obj2->is("baddie")) {
 		Projectile* p = dynamic_cast<Projectile*>(obj1);
 		BadCharacter* baddie = dynamic_cast<BadCharacter*>(obj2);
-		if (!baddie->isDying()) {
+		if (!baddie->isDying() && m_pStepTimer->GetTotalSeconds() > baddie->timeCanHit) {
 			baddie->damage(p->damage);
 			// Knockback from the projectile
 			if (obj1->is("piercing")) {
 				// Piercing projectiles have much lower knockback
-				obj2->addForce(obj1->getNetForce() * 0.1f, 0.25f);
+				obj2->addForce(obj1->getNetForce() * 0.05f, 0.25f);
 			}
 			else
 			{
@@ -441,6 +441,8 @@
 			// Don't kill if object is explosive, or piercing, they'll handle expiration elsewhere
 			if (!obj1->is("explosive") && !obj1->is("piercing"))
 				obj1->kill();
+			// Update when the baddie can next be hit
+			baddie->timeCanHit = m_pStepTimer->GetTotalSeconds() + baddie->invincibleTime;
 		}
 	}
 	// When explosive hits baddie, kill baddies within certain radius of fireball
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 89)
+++ Source/BadCharacter.h	(revision 90)
@@ -19,6 +19,9 @@
 	bool readyToAttack();
 	void setDestinationCoordinates(float x, float y);
 	void setDestinationByID(string id);
+	// Timers to track when the baddie can be hit, so they aren't spammed
+	float timeCanHit = 0.0f;
+	float invincibleTime = 0.1f;
 protected:
 	// Level that the baddie belongs to
 	BaseLevelScene* level = nullptr;
Index: Source/Sndlist.h
===================================================================
--- Source/Sndlist.h	(revision 89)
+++ Source/Sndlist.h	(revision 90)
@@ -17,5 +17,7 @@
 	CLANG_SOUND,
 	COIN_GRAB,
 	EXPLOSION_SOUND,
-	FIREBALL_SOUND
+	FIREBALL_SOUND,
+	LASER_SOUND,
+	AXE_SOUND
 }; //eSoundType
\ No newline at end of file
Index: Source/VikingPlayer.cpp
===================================================================
--- Source/VikingPlayer.cpp	(revision 89)
+++ Source/VikingPlayer.cpp	(revision 90)
@@ -6,14 +6,16 @@
 	PlayerCharacter(scene, x, y, z)
 {
 	hat = scene->addObject(new GameObject(scene, VIKING_HAT, m_vPos.x, m_vPos.y, m_vPos.z));
-	maxSpeed = 250;
+	maxSpeed = 200.0f;
 	// Projectile usage qualities
-	shootCooldown = .25;
+	shootCooldown = 0.6f;
 	shootTime = 0;
-	projectileSpeed = 400;
+	projectileSpeed = 300.0f;
 }
 
 // Creates the fireball as the projectile
 GameObject* VikingPlayer::_createProjectile() {
-	return scene->addObject(new ThrowingAxe(scene, m_vPos.x, m_vPos.y, m_vPos.z));
+	GameObject* obj = scene->addObject(new ThrowingAxe(scene, m_vPos.x, m_vPos.y, m_vPos.z));
+	ThrowingAxe* axe = dynamic_cast<ThrowingAxe*>(obj);
+	return obj;
 }

------------------------------------------------------------------------
r91 | jdg0393 | 2020-11-30 16:43:57 -0600 (Mon, 30 Nov 2020) | 1 line

Prompt and text ui changes

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 90)
+++ Source/BaseLevelScene.cpp	(revision 91)
@@ -139,13 +139,13 @@
 
 		if(getPlayers().first->isDead){
 			string respawnTimer = to_string(int((getPlayers().first->timeDied + 20) - m_pStepTimer->GetTotalSeconds()));
-			m_pRenderer->DrawScreenText("Oh Dear, You Have Died... Respawn in:", Vector2(500, 95), Colors::IndianRed);
-			m_pRenderer->DrawScreenText(respawnTimer.c_str(), Vector2(500, 120), Colors::IndianRed);
+			m_pRenderer->DrawScreenText("Oh Dear, You Have Died... Respawn in:", Vector2(430, 95), Colors::IndianRed);
+			m_pRenderer->DrawScreenText(respawnTimer.c_str(), Vector2(630, 120), Colors::IndianRed);
 			}
 		if (coOp&&getPlayers().second->isDead) {
 			string respawnTimer = to_string(int((getPlayers().second->timeDied + 20) - m_pStepTimer->GetTotalSeconds()));
-			m_pRenderer->DrawScreenText("Oh Dear, You Have Died... Respawn in:", Vector2(500, 95), Colors::IndianRed);
-			m_pRenderer->DrawScreenText(respawnTimer.c_str(), Vector2(500, 120), Colors::IndianRed);
+			m_pRenderer->DrawScreenText("Oh Dear, You Have Died... Respawn in:", Vector2(430, 160), Colors::DarkCyan);
+			m_pRenderer->DrawScreenText(respawnTimer.c_str(), Vector2(630, 185), Colors::IndianRed);
 		}
 
 	}
Index: Source/LevelSelectScene.cpp
===================================================================
--- Source/LevelSelectScene.cpp	(revision 90)
+++ Source/LevelSelectScene.cpp	(revision 91)
@@ -57,9 +57,19 @@
 
 	m_pRenderer->setFont("title_font");
 	m_pRenderer->DrawScreenText("Level Select", Vector2(400, 0), Colors::Black);
+	string prompt = "PRESS ";
+	if (controllerOwner == 1) {
+		prompt += "a";
+	}
+	else {
+		prompt += keyboardKeys[controlMap["PLAYER1_ACCEPT"]];
+	}
+	prompt += " TO BEGIN!\nDEFEND THE SPIRE!";
 	m_pRenderer->setFont("font");
 	m_pRenderer->DrawScreenText(LevelMenu[selection.first].first.c_str(), Vector2(580, 600), Colors::Black);
-	m_pRenderer->DrawScreenText("Press E to confirm level and begin the game!\nDefend the spire from enemies!", Vector2(420,650), Colors::Black);
+	m_pRenderer->setFont("prompt_font");
+	m_pRenderer->DrawScreenText(prompt.c_str(), Vector2(540, 650), Colors::Black);
+	m_pRenderer->setFont("font");
 }
 
 void LevelSelectScene::startLevel() {

------------------------------------------------------------------------
r92 | amm0837 | 2020-11-30 16:50:41 -0600 (Mon, 30 Nov 2020) | 1 line

nerfed towers. more expensive and less damage/range

Index: Source/ShopMenu.cpp
===================================================================
--- Source/ShopMenu.cpp	(revision 91)
+++ Source/ShopMenu.cpp	(revision 92)
@@ -50,13 +50,13 @@
 		selectedTower->m_nSpriteIndex = RANGE1;
 		selectionName = "Gun Tower";
 		selectionDescription = "Shoots bullets. Questions?     ";
-		cost = 5;
+		cost = 10;
 		break;
 	case 1:
 		selectedTower->m_nSpriteIndex = MAGE1;
 		selectionName = "Magic Tower";
 		selectionDescription = "Crowd control   for pyromaniacs";
-		cost = 10;
+		cost = 25;
 		break;
 	default:
 		break;
Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 91)
+++ Source/BaseLevelScene.cpp	(revision 92)
@@ -495,39 +495,39 @@
 	if (tow != NULL && distToTower(upgrader) <= 75) {
 		if (tow->is("range")) {
 			if (tow->is("lvl0")) {
-				if (credits >= 10) {
+				if (credits >= 25) {
 					newTow = addObject(new RangeTower(this, RANGE2, 1, tow->getPosition().x, tow->getPosition().y));
 					newTow->m_fXScale = 1.7f;
 					newTow->m_fYScale = 1.7f;
 					tow->kill();
-					credits -= 10;
+					credits -= 25;
 				}
 			}
 			if (tow->is("lvl1")) {
-				if (credits >= 20) {
+				if (credits >= 50) {
 					newTow = addObject(new RangeTower(this, RANGE3, 2, tow->getPosition().x, tow->getPosition().y));
 					newTow->m_fXScale = 1.7f;
 					newTow->m_fYScale = 1.7f;
 					tow->kill();
-					credits -= 20;
+					credits -= 50;
 				}
 			}
 		}
 		if (tow->is("mage")) {
 			if (tow->is("lvl0")) {
-				if (credits >= 15) {
+				if (credits >= 40) {
 					newTow = addObject(new MageTower(this, MAGE2, 1, tow->getPosition().x, tow->getPosition().y));
 					tow->kill();
-					credits -= 15;
+					credits -= 40;
 				}
 			}
 			if (tow->is("lvl1")) {
-				if (credits >= 30) {
+				if (credits >= 80) {
 					newTow = addObject(new MageTower(this, MAGE3, 2, tow->getPosition().x, tow->getPosition().y));
 					tow->kill();
 					newTow->m_fXScale = 0.7f;
 					newTow->m_fYScale = 0.7f;
-					credits -= 30;
+					credits -= 80;
 				}
 			}
 		}
Index: Source/Bullet.cpp
===================================================================
--- Source/Bullet.cpp	(revision 91)
+++ Source/Bullet.cpp	(revision 92)
@@ -8,12 +8,12 @@
 	damage = 10;
 	lvl = level;
 	if (lvl == 0) {
-		damage = 10;
+		damage = 5;
 	}
 	if (lvl == 1) {
-		damage = 15;
+		damage = 8;
 	}
 	if (lvl == 2) {
-		damage = 20;
+		damage = 12;
 	}
 }
Index: Source/Tower.cpp
===================================================================
--- Source/Tower.cpp	(revision 91)
+++ Source/Tower.cpp	(revision 92)
@@ -23,15 +23,15 @@
 			if (this->is("tower") && this->is("mage")) {		//add conditions for other towers here, set bullet type
 				Vector3 pos = this->getPosition();
 				//creating bullet and setting its bounding box
-				if (this->is("lvl0") && this->distToTarget() <= 250) {
+				if (this->is("lvl0") && this->distToTarget() <= 150) {
 					GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 0));
 					fire(b);
 				}
-				if (this->is("lvl1") && this->distToTarget() <= 350) {
+				if (this->is("lvl1") && this->distToTarget() <= 250) {
 					GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 1));
 					fire(b);
 				}
-				else if (this->is("lvl2") && this->distToTarget() <= 500) {
+				else if (this->is("lvl2") && this->distToTarget() <= 350) {
 					GameObject* b = objScene->addObject(new Fireball(objScene, pos.x, pos.y, pos.z, 2));
 					fire(b);
 				}
@@ -39,15 +39,15 @@
 			else if (this->is("tower") && this->is("range")) {
 				Vector3 pos = this->getPosition();
 				//creating bullet and setting its bounding box
-				if (this->is("lvl0") && this->distToTarget() <= 300) {
+				if (this->is("lvl0") && this->distToTarget() <= 200) {
 					GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 0));
 					fire(b);
 				}
-				if (this->is("lvl1") && this->distToTarget() <= 400) {
+				if (this->is("lvl1") && this->distToTarget() <= 300) {
 					GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 1));
 					fire(b);
 				}
-				else if (this->is("lvl2") && this->distToTarget() <= 550) {
+				else if (this->is("lvl2") && this->distToTarget() <= 400) {
 					GameObject* b = objScene->addObject(new Bullet(objScene, pos.x, pos.y, pos.z, 2));
 					fire(b);
 				}
Index: Source/Fireball.cpp
===================================================================
--- Source/Fireball.cpp	(revision 91)
+++ Source/Fireball.cpp	(revision 92)
@@ -13,13 +13,13 @@
 		splash = 3;
 	}
 	if (lvl == 1) {
-		damage = 8;
-		splash = 10;
+		damage = 6;
+		splash = 6;
 		radius = 30;
 	}
 	if (lvl == 2) {
-		damage = 15;
-		splash = 15;
+		damage = 10;
+		splash = 10;
 		radius = 40;
 	}
 }

------------------------------------------------------------------------
r93 | jdg0393 | 2020-11-30 16:57:08 -0600 (Mon, 30 Nov 2020) | 1 line

Waves are harder, enemies are faster, level previews are better quality.

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 92)
+++ Source/BaseLevelScene.cpp	(revision 93)
@@ -551,7 +551,7 @@
 	// Define some spawn descriptors for the wave spawner
 	SpawnDesc goblins;
 	goblins.addPerWave = 10;
-	goblins.multiplyPerWave = 1.1f;
+	goblins.multiplyPerWave = 1.6f;
 	goblins.nextSpawn = m_pStepTimer->GetTotalSeconds();
 	goblins.numberSpawned = 0;
 	goblins.ready = true;
@@ -562,7 +562,7 @@
 	SpawnDesc minotaurs;
 	minotaurs.key = "minotaur";
 	minotaurs.addPerWave = 3;
-	minotaurs.multiplyPerWave = 1.2f;
+	minotaurs.multiplyPerWave = 1.3f;
 	minotaurs.nextSpawn = m_pStepTimer->GetTotalSeconds() + 6.0f;
 	minotaurs.numberSpawned = 0;
 	minotaurs.ready = true;
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 92)
+++ Source/BadCharacter.cpp	(revision 93)
@@ -111,7 +111,7 @@
 	// Calculate the angle in degrees
 	angle = angle_in_radians * (180 / MY_PI);
 	// Calculate the velocity
-	Vector2 velocity = { 40 * cosf(angle_in_radians), 40 * sinf(angle_in_radians) };
+	Vector2 velocity = { 70.0f * cosf(angle_in_radians), 70.0f * sinf(angle_in_radians) };
 	// Finally, move the baddie. But only if they aren't stopped.
 	if (!isStopped)addForce(velocity, PseudoForce::Instant);
 }

------------------------------------------------------------------------
r94 | jdg0393 | 2020-11-30 17:50:24 -0600 (Mon, 30 Nov 2020) | 1 line

Added Wolf enemy and plains level.

Index: Source/BaseLevelScene.cpp
===================================================================
--- Source/BaseLevelScene.cpp	(revision 93)
+++ Source/BaseLevelScene.cpp	(revision 94)
@@ -570,7 +570,19 @@
 	minotaurs.timeAddPerSpawn = -3.0f;
 	minotaurs.timeMultiplyPerSpawn = 1.0f;
 	minotaurs.timeToSpawn = 12.0f;
+	SpawnDesc wolves;
+	wolves.key = "wolf";
+	wolves.addPerWave = 3;
+	wolves.multiplyPerWave = 1.3f;
+	wolves.nextSpawn = m_pStepTimer->GetTotalSeconds() + 6.0f;
+	wolves.numberSpawned = 0;
+	wolves.ready = true;
+	wolves.startWave = 2;
+	wolves.timeAddPerSpawn = -3.0f;
+	wolves.timeMultiplyPerSpawn = 1.0f;
+	wolves.timeToSpawn = 12.0f;
 	// Add the spawn descriptions
 	waves->addSpawnDesc(goblins);
 	waves->addSpawnDesc(minotaurs);
+	waves->addSpawnDesc(wolves);
 }
Index: Source/WaveSpawner.cpp
===================================================================
--- Source/WaveSpawner.cpp	(revision 93)
+++ Source/WaveSpawner.cpp	(revision 94)
@@ -2,6 +2,7 @@
 #include "BaseLevelScene.h"
 #include "BadGoblin.h"
 #include "BadMinotaur.h"
+#include "WolfBaddie.h"
 
 WaveSpawner::WaveSpawner(BaseLevelScene* level) {
 	this->level = level;
@@ -90,6 +91,9 @@
 	else if (key == "minotaur") {
 		return new BadMinotaur(level);
 	}
+	else if (key == "wolf") {
+		return new WolfBaddie(level);
+	}
 	else {
 		ABORT("Tried to spawn a baddie with an invalid key!");
 		// Return won't be used, just want to avoid the stupid compiler warning
Index: Source/Source.vcxproj
===================================================================
--- Source/Source.vcxproj	(revision 93)
+++ Source/Source.vcxproj	(revision 94)
@@ -184,6 +184,7 @@
     <ClCompile Include="MageTower.cpp" />
     <ClCompile Include="Main.cpp" />
     <ClCompile Include="OptionsScene.cpp" />
+    <ClCompile Include="PlainsLevel.cpp" />
     <ClCompile Include="PlayerCharacter.cpp" />
     <ClCompile Include="PseudoForce.cpp" />
     <ClCompile Include="RangeTower.cpp" />
@@ -199,6 +200,7 @@
     <ClCompile Include="VikingPlayer.cpp" />
     <ClCompile Include="WaveSpawner.cpp" />
     <ClCompile Include="WizardPlayer.cpp" />
+    <ClCompile Include="WolfBaddie.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="AnimationDesc.h" />
@@ -224,6 +226,7 @@
     <ClInclude Include="MageTower.h" />
     <ClInclude Include="OptionsScene.h" />
     <ClInclude Include="Piercing.h" />
+    <ClInclude Include="PlainsLevel.h" />
     <ClInclude Include="PlayerCharacter.h" />
     <ClInclude Include="Projectile.h" />
     <ClInclude Include="PseudoForce.h" />
@@ -242,6 +245,7 @@
     <ClInclude Include="VikingPlayer.h" />
     <ClInclude Include="WaveSpawner.h" />
     <ClInclude Include="WizardPlayer.h" />
+    <ClInclude Include="WolfBaddie.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/Source.vcxproj.filters
===================================================================
--- Source/Source.vcxproj.filters	(revision 93)
+++ Source/Source.vcxproj.filters	(revision 94)
@@ -92,6 +92,12 @@
     <ClCompile Include="CyborgPlayer.cpp">
       <Filter>Objects\Players</Filter>
     </ClCompile>
+    <ClCompile Include="WolfBaddie.cpp">
+      <Filter>Objects\Baddies</Filter>
+    </ClCompile>
+    <ClCompile Include="PlainsLevel.cpp">
+      <Filter>Scenes\Levels</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Common.h" />
@@ -197,6 +203,12 @@
     <ClInclude Include="CyborgPlayer.h">
       <Filter>Objects\Players</Filter>
     </ClInclude>
+    <ClInclude Include="WolfBaddie.h">
+      <Filter>Objects\Baddies</Filter>
+    </ClInclude>
+    <ClInclude Include="PlainsLevel.h">
+      <Filter>Scenes\Levels</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="Source.rc" />
Index: Source/LevelSelectScene.cpp
===================================================================
--- Source/LevelSelectScene.cpp	(revision 93)
+++ Source/LevelSelectScene.cpp	(revision 94)
@@ -2,6 +2,7 @@
 #include "LevelSelectScene.h"
 #include "BaseLevelScene.h"
 #include "DesolateDesertLevel.h"
+#include "PlainsLevel.h"
 
 LevelSelectScene::LevelSelectScene(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coOp) : Scene(game) {
 
@@ -9,7 +10,8 @@
 
 	LevelMenu = {
 		{"Log Town", BASELEVEL},
-		{"Desert Town", DESERTLEVEL}
+		{"Desert Town", DESERTLEVEL},
+		{"Forgotten Plains", PLAINSLEVEL}
 	};
 
 	selection.first = 0;
@@ -82,5 +84,9 @@
 		game->startScene(new DesolateDesertLevel(game,
 			p1Hat, p2Hat, coOp));
 	}
+	else if (selection.first == 2) {
+		game->startScene(new PlainsLevel(game,
+			p1Hat, p2Hat, coOp));
+	}
 }
 
Index: Source/Renderer.cpp
===================================================================
--- Source/Renderer.cpp	(revision 93)
+++ Source/Renderer.cpp	(revision 94)
@@ -40,6 +40,7 @@
 	Load(SMOKE, "smoke");
 	Load(DESERTLEVEL, "desertLevel");
 	Load(BASELEVEL, "baseLevel");
+	Load(PLAINSLEVEL, "plainsLevel");
 	// Hats
 	Load(VIKING_HAT, "viking_hat");
 	Load(WIZARD_HAT, "wizard_hat");
@@ -52,6 +53,7 @@
 	// Tilesets
 	Load(SIMPLE_TILE, "simple_tile");
 	Load(DESERT_TILE, "desert_tile");
+	Load(PLAINS_TILE, "plains_tile");
 	// Currency
 	Load(COIN, "coin");
 	Load(COIN_STACK, "coin_stack");
@@ -68,6 +70,8 @@
 	Load(GOBLIN_ATTACK, "goblin_attack");
 	Load(MINOTAUR_WALK, "minotaur_walk");
 	Load(MINOTAUR_ATTACK, "minotaur_attack");
+	Load(WOLF_WALK, "wolf_walk");
+	Load(WOLF_ATTACK, "wolf_attack");
 	// Load any additional fonts
 	loadNewFont("title_font");
 	loadNewFont("selection_font");
Index: Source/GameDefines.h
===================================================================
--- Source/GameDefines.h	(revision 93)
+++ Source/GameDefines.h	(revision 94)
@@ -22,6 +22,7 @@
 	SMOKE,
 	DESERTLEVEL,
 	BASELEVEL,
+	PLAINSLEVEL,
 	// Hats
 	VIKING_HAT,
 	WIZARD_HAT,
@@ -34,6 +35,7 @@
 	// Tilesets
 	SIMPLE_TILE,
 	DESERT_TILE,
+	PLAINS_TILE,
 	// Currency
 	COIN,
 	COIN_STACK,
@@ -50,5 +52,7 @@
 	GOBLIN_ATTACK,
 	MINOTAUR_WALK,
 	MINOTAUR_ATTACK,
+	WOLF_WALK,
+	WOLF_ATTACK,
 	NUM_SPRITES //MUST BE LAST
 }; //eSpriteType
Index: Source/BadGoblin.cpp
===================================================================
--- Source/BadGoblin.cpp	(revision 93)
+++ Source/BadGoblin.cpp	(revision 94)
@@ -4,6 +4,7 @@
 BadGoblin::BadGoblin(Scene* scene, float x, float y, float z) :
 	BadCharacter(scene, x, y, z)
 {
+	hp = 14;
 	// Defining animations for the bad guy
 	animations["WALK_NE"] = AnimationDesc(GOBLIN_WALK, 0, 3, 0.15f);
 	animations["WALK_NW"] = AnimationDesc(GOBLIN_WALK, 4, 7, 0.15f);

------------------------------------------------------------------------
r95 | jdg0393 | 2020-11-30 18:02:35 -0600 (Mon, 30 Nov 2020) | 1 line

Forgot to upload source files in previous version

Index: Source/WolfBaddie.h
===================================================================
--- Source/WolfBaddie.h	(nonexistent)
+++ Source/WolfBaddie.h	(revision 95)
@@ -0,0 +1,10 @@
+#pragma once
+#include "BadCharacter.h"
+class WolfBaddie :
+    public BadCharacter
+{
+public:
+    WolfBaddie(Scene* scene, float x = 0, float y = 0, float z = 1.15);
+    ~WolfBaddie() override;
+};
+
Index: Source/WolfBaddie.cpp
===================================================================
--- Source/WolfBaddie.cpp	(nonexistent)
+++ Source/WolfBaddie.cpp	(revision 95)
@@ -0,0 +1,18 @@
+#include "WolfBaddie.h"
+#include "BaseLevelScene.h"
+
+WolfBaddie::WolfBaddie(Scene* scene, float x, float y, float z) :
+	BadCharacter(scene, x, y, z)
+{
+	hp = 6;
+	// Defining animations for the bad guy
+	animations["WALK_NE"] = AnimationDesc(WOLF_WALK, 0, 3, 0.15f);
+	animations["WALK_NW"] = AnimationDesc(WOLF_WALK, 4, 7, 0.15f);
+	animations["WALK_SW"] = AnimationDesc(WOLF_WALK, 8, 11, 0.15f);
+	animations["WALK_SE"] = AnimationDesc(WOLF_WALK, 12, 15, 0.15f);
+	animations["ATTACK_NE"] = AnimationDesc(WOLF_ATTACK, 0, 3, 0.15f);
+	animations["ATTACK_NW"] = AnimationDesc(WOLF_ATTACK, 4, 7, 0.15f);
+	animations["ATTACK_SW"] = AnimationDesc(WOLF_ATTACK, 8, 11, 0.15f);
+	animations["ATTACK_SE"] = AnimationDesc(WOLF_ATTACK, 12, 15, 0.15f);
+}
+WolfBaddie::~WolfBaddie() {}
Index: Source/PlainsLevel.h
===================================================================
--- Source/PlainsLevel.h	(nonexistent)
+++ Source/PlainsLevel.h	(revision 95)
@@ -0,0 +1,10 @@
+#pragma once
+#include "BaseLevelScene.h"
+class PlainsLevel :
+    public BaseLevelScene
+{
+public:
+    PlainsLevel(CGame* game, eSpriteType ply1Hat = WIZARD_HAT, eSpriteType ply2Hat = WIZARD_HAT, bool coop = false);
+    ~PlainsLevel();
+};
+
Index: Source/PlainsLevel.cpp
===================================================================
--- Source/PlainsLevel.cpp	(nonexistent)
+++ Source/PlainsLevel.cpp	(revision 95)
@@ -0,0 +1,9 @@
+#include "PlainsLevel.h"
+
+PlainsLevel::PlainsLevel(CGame* game, eSpriteType ply1Hat, eSpriteType ply2Hat, bool coop)
+	: BaseLevelScene(game, ply1Hat, ply2Hat, coop)
+{
+	tileMapFileName = "forgotten_plains";
+	tileSetSprite = PLAINS_TILE;
+}
+PlainsLevel::~PlainsLevel() {}
\ No newline at end of file

------------------------------------------------------------------------
r97 | jdg0393 | 2020-11-30 18:24:11 -0600 (Mon, 30 Nov 2020) | 1 line

Bonus Update: Enemies move at different speeds.

Index: Source/WolfBaddie.cpp
===================================================================
--- Source/WolfBaddie.cpp	(revision 96)
+++ Source/WolfBaddie.cpp	(revision 97)
@@ -5,6 +5,7 @@
 	BadCharacter(scene, x, y, z)
 {
 	hp = 6;
+	speed = 100.0f;
 	// Defining animations for the bad guy
 	animations["WALK_NE"] = AnimationDesc(WOLF_WALK, 0, 3, 0.15f);
 	animations["WALK_NW"] = AnimationDesc(WOLF_WALK, 4, 7, 0.15f);
Index: Source/BadCharacter.cpp
===================================================================
--- Source/BadCharacter.cpp	(revision 96)
+++ Source/BadCharacter.cpp	(revision 97)
@@ -111,7 +111,7 @@
 	// Calculate the angle in degrees
 	angle = angle_in_radians * (180 / MY_PI);
 	// Calculate the velocity
-	Vector2 velocity = { 70.0f * cosf(angle_in_radians), 70.0f * sinf(angle_in_radians) };
+	Vector2 velocity = { speed * cosf(angle_in_radians), speed * sinf(angle_in_radians) };
 	// Finally, move the baddie. But only if they aren't stopped.
 	if (!isStopped)addForce(velocity, PseudoForce::Instant);
 }
Index: Source/BadMinotaur.cpp
===================================================================
--- Source/BadMinotaur.cpp	(revision 96)
+++ Source/BadMinotaur.cpp	(revision 97)
@@ -6,6 +6,8 @@
 {
 	// Minotaur has big HP
 	hp = 35;
+	// Minotaur is slow
+	speed = 40.0f;
 	// Defining animations for the bad guy
 	animations["WALK_NE"] = AnimationDesc(MINOTAUR_WALK, 0, 5, 0.15f);
 	animations["WALK_NW"] = AnimationDesc(MINOTAUR_WALK, 6, 11, 0.15f);
Index: Source/BadCharacter.h
===================================================================
--- Source/BadCharacter.h	(revision 96)
+++ Source/BadCharacter.h	(revision 97)
@@ -23,6 +23,7 @@
 	float timeCanHit = 0.0f;
 	float invincibleTime = 0.1f;
 protected:
+	float speed = 70.0f;
 	// Level that the baddie belongs to
 	BaseLevelScene* level = nullptr;
 	// Time between attacks

------------------------------------------------------------------------
